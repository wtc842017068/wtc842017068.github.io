<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>cpp 构造与析构（侯捷）</title>
    <url>/2022/03/20/cpp-%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84/</url>
    <content><![CDATA[<h2 id="inline（内联函数）"><a href="#inline（内联函数）" class="headerlink" title="inline（内联函数）"></a>inline（内联函数）</h2><p><em>若在函数体内定义完成，变为内联函数的候选人</em><br>inline 函数运行更快，inline 只是建议，具体是否使用由编译器决定</p>
<span id="more"></span>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>函数重载 :由编译器负责将函数命名唯一化，使用<strong>函数名</strong>和<strong>参数</strong> 有关</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __COMPLEX__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __COMPLEX__</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">complex</span>(T r=<span class="number">0</span>,T i=<span class="number">0</span>):<span class="built_in">re</span>(r),<span class="built_in">im</span>(i)&#123;&#125; <span class="comment">//inline 使用初始化构造列表,优点构造函数运行更快：因为在变量初始化时就进行了赋值</span></span><br><span class="line">    <span class="comment">// (T r=0,T i=0) 默认实参</span></span><br><span class="line">    <span class="built_in">complex</span>():<span class="built_in">re</span>(<span class="number">0</span>),<span class="built_in">im</span>(<span class="number">0</span>)&#123;&#125;<span class="comment">// 与 上面的构造函数冲突，因此这种构造不允许存在</span></span><br><span class="line">	complex&amp; <span class="keyword">operator</span> +=(<span class="type">const</span> complex&amp;);</span><br><span class="line">	<span class="function">T <span class="title">real</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> re;&#125; <span class="comment">//inline</span></span><br><span class="line">	<span class="function">T <span class="title">imag</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> im;&#125;<span class="comment">//inline</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T re,im;</span><br><span class="line">	<span class="keyword">friend</span> complex&amp; __doapl(complex*,<span class="type">const</span> complex&amp;); <span class="comment">//友元 可以直接访问类的私有成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>尽量inline由编译器决定</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">imag</span><span class="params">(<span class="type">const</span> conplex&amp; x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.<span class="built_in">imag</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> complex&amp;</span><br><span class="line">__doapl (complex* ths,<span class="type">const</span> comlex&amp; r)&#123;</span><br><span class="line">    ths-&gt;re +=r.re;</span><br><span class="line">    ths-&gt;im +=r.im;</span><br><span class="line">    <span class="keyword">return</span> *ths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p><strong>同一个class的各个objects互为友元</strong></p>
<h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><h3 id="尽量使用引用传递，入参以及返回值"><a href="#尽量使用引用传递，入参以及返回值" class="headerlink" title="尽量使用引用传递，入参以及返回值"></a>尽量使用引用传递，入参以及返回值</h3><p><em>引用实际上是由编译器使用指针实现</em></p>
<h3 id="返回值不能使用引用，若返回的值在离开函数后不存在"><a href="#返回值不能使用引用，若返回的值在离开函数后不存在" class="headerlink" title="返回值不能使用引用，若返回的值在离开函数后不存在"></a>返回值不能使用引用，若返回的值在离开函数后不存在</h3><p>使用引用的方式<strong>传递着</strong>，无需知道<strong>接受者是以引用</strong>的方式接受的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> complex&amp;</span><br><span class="line">comolex::operayor += (<span class="type">const</span> comlex&amp; r)&#123;</span><br><span class="line">   <span class="keyword">return</span> __doapl(<span class="keyword">this</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c2 +=c1;</span><br><span class="line">c2+=c2+=c1;<span class="comment">// 因为是引用的方式，所以这种写法是可以的。既传递着无需关心接受者的接收方式</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h2><h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">complex c1;</span><br><span class="line">complex c2;</span><br><span class="line">c2+=c1;<span class="comment">//操作符被作用到左侧的这个类型上</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">inline</span> complex&amp;</span><br><span class="line"><span class="comment">//由于这个函数其他地方可能会用到，因此我们需要把它独立出来</span></span><br><span class="line">__doapl (complex* ths,<span class="type">const</span> comlex&amp; r)&#123;<span class="comment">//第二个参数不会改动，因此添加const关键字</span></span><br><span class="line">    ths-&gt;re +=r.re;</span><br><span class="line">    ths-&gt;im +=r.im;</span><br><span class="line">    <span class="keyword">return</span> *ths;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> complex&amp;</span><br><span class="line">comolex::operayor += (<span class="type">const</span> comlex&amp; r)&#123;</span><br><span class="line">   <span class="keyword">return</span> __doapl(<span class="keyword">this</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="非成员函数"><a href="#非成员函数" class="headerlink" title="非成员函数"></a>非成员函数</h3><p><em>临时对象</em><br>特殊操作符要使用全局的操作符重载<br>cout&lt;&lt; conj(c1);<br>cout&lt;&lt; c1&lt;&lt; conj(c1);</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局函数</span></span><br><span class="line"><span class="keyword">inline</span> compelx</span><br><span class="line"><span class="keyword">operator</span> +(<span class="type">const</span> compelx&amp;x,<span class="type">const</span> complex&amp;y)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span>(<span class="built_in">real</span>(x)+<span class="built_in">real</span>(y),<span class="built_in">imag</span>(x)+<span class="built_in">imag</span>(y));<span class="comment">//类型（）创建临时变量。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> compelx</span><br><span class="line"><span class="keyword">operator</span> +(<span class="type">const</span> compelx&amp;x, <span class="type">double</span> y)&#123;</span><br><span class="line">    <span class="built_in">complex</span>(<span class="built_in">real</span>(x)+<span class="built_in">real</span>(y),<span class="built_in">imag</span>(x)+y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> compelx</span><br><span class="line"><span class="keyword">operator</span> +( <span class="type">double</span> x, <span class="type">const</span> complex&amp;y)&#123;</span><br><span class="line">    <span class="built_in">complex</span>(x+<span class="built_in">real</span>(y),<span class="built_in">imag</span>(x)+<span class="built_in">imag</span>(y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> complex <span class="keyword">operator</span> +(<span class="type">const</span> complex&amp;x)&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> complex <span class="keyword">operator</span> -(<span class="type">const</span> complex&amp;x)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span>(-<span class="built_in">real</span>(x),-<span class="built_in">imag</span>(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">operator</span> ==(<span class="type">const</span> comolex&amp; x,<span class="type">const</span> comolex&amp; y)&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">real</span>(x)==<span class="built_in">real</span>(y) &amp;&amp;<span class="built_in">imag</span>(x)==<span class="built_in">imag</span>(y);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">operator</span> ==(<span class="type">const</span> comolex&amp; x,<span class="type">double</span> y)&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">real</span>(x)==y &amp;&amp;<span class="built_in">imag</span>(x)==<span class="number">0</span>;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">operator</span> ==(<span class="type">double</span> x,<span class="type">const</span> comolex&amp; y)&#123;</span><br><span class="line"> <span class="keyword">return</span> x==<span class="built_in">real</span>(y) &amp;&amp;<span class="built_in">imag</span>(x)==<span class="number">0</span>;  </span><br><span class="line">&#125;</span><br><span class="line">ostream &amp;</span><br><span class="line"><span class="keyword">operator</span> &lt;&lt; (ostream&amp; os,<span class="type">const</span> compelx&amp;x)&#123;<span class="comment">//os 不能const，因为每次输出改变os的状态</span></span><br><span class="line">    <span class="keyword">return</span> os&lt;&lt;<span class="string">&quot;&quot;</span>&lt;&lt;<span class="built_in">real</span>(x)&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;<span class="built_in">imag</span>(x)&lt;&lt;<span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
        <category>后端</category>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>构造</tag>
        <tag>析构</tag>
        <tag>侯捷</tag>
        <tag>内联函数</tag>
        <tag>操作符重载</tag>
        <tag>临时对象</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp 11&amp;14 可变参数模板与空指针,auto</title>
    <url>/2022/03/20/cpp-11-14-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF%E4%B8%8E%E7%A9%BA%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<!-- <blockquote class="blockquote-center">this is note</blockquote> -->
<ul>
<li><p>Variadic Templates(可变参数模板)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可变参数模板</span></span><br><span class="line"><span class="comment">// 无参数函数，用于结束调用 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printX</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 包含一个参数固定参数的可变模板函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... types&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printX</span><span class="params">(<span class="type">const</span> T&amp; firstArg,<span class="type">const</span> Types&amp;... args)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt; firstArg&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">printX</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>空指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;&#125;<span class="comment">//function1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">void</span>* a)</span></span>&#123;&#125;<span class="comment">//funtion2</span></span><br><span class="line"><span class="built_in">f</span>(<span class="literal">NULL</span>);<span class="comment">//call function1 </span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">0</span>);<span class="comment">//call function1 </span></span><br><span class="line"><span class="built_in">f</span>(<span class="literal">nullptr</span>);<span class="comment">//call function2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>模板函数书写变化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;<span class="comment">//</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="comment">//Ok since c++11</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1 id="cpp-11-amp-14-可变参数模板与空指针-auto"><a href="#cpp-11-amp-14-可变参数模板与空指针-auto" class="headerlink" title="cpp 11&amp;14 可变参数模板与空指针,auto"></a>cpp 11&amp;14 可变参数模板与空指针,auto</h1></li>
</ul>
<h2 id="Variadic-Templates-可变参数模板"><a href="#Variadic-Templates-可变参数模板" class="headerlink" title="Variadic Templates(可变参数模板)"></a>Variadic Templates(可变参数模板)</h2><h3 id="帮助我们实现递归"><a href="#帮助我们实现递归" class="headerlink" title="帮助我们实现递归"></a><strong>帮助我们实现递归</strong></h3><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可变参数模板</span></span><br><span class="line"><span class="comment">// 无参数函数，用于结束调用 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printX</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 包含一个参数固定参数的可变模板函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... types&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// type2 和 type 3 可以并存 2为特</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// type2 接收1个和各式各样的入参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printX</span><span class="params">(<span class="type">const</span> T&amp; firstArg,<span class="type">const</span> Types&amp;... args)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt; firstArg&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt; <span class="keyword">sizeof</span>...(args...)&lt;&lt;endl;<span class="comment">// 可以使用sizeof...(args) 获取args的个数</span></span><br><span class="line">    <span class="built_in">printX</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// type3 接收各式各样的入参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printX</span><span class="params">(<span class="type">const</span> Types&amp;... args)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt; firstArg&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt; <span class="keyword">sizeof</span>...(args...)&lt;&lt;endl;<span class="comment">// 可以使用sizeof...(args) 获取args的个数</span></span><br><span class="line">    <span class="built_in">printX</span>(args...);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="cpp库函数举例"><a href="#cpp库函数举例" class="headerlink" title="cpp库函数举例"></a>cpp库函数举例</h4><h5 id="calculate-Hash"><a href="#calculate-Hash" class="headerlink" title="calculate Hash"></a>calculate Hash</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// another file</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">hash_combine</span><span class="params">(<span class="type">size_t</span>&amp; seed,<span class="type">const</span> T&amp; val)</span></span>&#123;</span><br><span class="line">    seed^=std::<span class="built_in">hash</span>&lt;T&gt;()(val)+<span class="number">0x9e3779b9</span>+(seed&lt;&lt;<span class="number">6</span>)+(seed&gt;&gt;<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// call sequence 1-&gt;2-&gt;recurse-&gt;3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// function 1</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>.. Type&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">hash_val</span><span class="params">(<span class="type">size_t</span>&amp; seed, <span class="type">const</span> T&amp; val,<span class="type">const</span> Types&amp;... args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">hash_combine</span>(seed,val);</span><br><span class="line">    <span class="built_in">hash_val</span>(seed,args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// function 2</span></span><br><span class="line"><span class="comment">// auxiliary generic function</span></span><br><span class="line"><span class="keyword">template</span> &lt;typeame... Types&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">size_t</span> <span class="title">hash_val</span><span class="params">(<span class="type">const</span> Types&amp;... args)</span></span>&#123;</span><br><span class="line">    <span class="type">size_t</span> seed=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">hash_val</span>(seed,args);</span><br><span class="line">    <span class="keyword">return</span> seed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function 3</span></span><br><span class="line"><span class="comment">// auxiliary generic function</span></span><br><span class="line"><span class="keyword">template</span> &lt;typeame T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">size_t</span> <span class="title">hash_val</span><span class="params">(<span class="type">size_t</span>&amp; seed,<span class="type">const</span> T&amp; val)</span></span>&#123;</span><br><span class="line">    <span class="built_in">hash_combine</span>(seed,val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="tuple-realise"><a href="#tuple-realise" class="headerlink" title="tuple realise"></a>tuple realise</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Values&gt;<span class="keyword">class</span> <span class="title class_">tuple</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;<span class="keyword">class</span> <span class="title class_">tuple</span>&lt;&gt;&#123;&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head,<span class="keyword">typename</span>... Tail&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tuple</span>&lt;Head,Tail...&gt;:<span class="keyword">private</span> typle&lt;Tail...&gt;&#123;</span><br><span class="line">    <span class="keyword">typedef</span> typle&lt;Tail...&gt; inherited;</span><br><span class="line"> </span><br><span class="line">pubic:</span><br><span class="line">    <span class="built_in">tuple</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">tuple</span>(Head v,Tail... vtail):<span class="built_in">m_head</span>(v),<span class="built_in">inherited</span>(vtail...)&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">typename</span> Head::type <span class="title">head</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_head;&#125;</span><br><span class="line"><span class="function">inherited&amp; <span class="title">tail</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">Head m_head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="tuple-sample"><a href="#tuple-sample" class="headerlink" title="tuple sample"></a>tuple sample</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">tuple&lt;<span class="type">int</span>,<span class="type">float</span>,string&gt; <span class="title">t</span><span class="params">(<span class="number">41</span>,<span class="number">6.3</span>,<span class="string">&quot;nico&quot;</span>)</span></span>;</span><br><span class="line">t.<span class="built_in">head</span>();<span class="comment">//-&gt;4.1</span></span><br><span class="line">t.<span class="built_in">tail</span>().<span class="built_in">head</span>()<span class="comment">//-&gt;6.3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="nullptr-空指针"><a href="#nullptr-空指针" class="headerlink" title="nullptr(空指针)"></a>nullptr(空指针)</h2><h3 id="用于区分空指针与NULL"><a href="#用于区分空指针与NULL" class="headerlink" title="用于区分空指针与NULL"></a><strong>用于区分空指针与NULL</strong></h3><h3 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;&#125;<span class="comment">//function1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">void</span>* a)</span></span>&#123;&#125;<span class="comment">//funtion2</span></span><br><span class="line"><span class="built_in">f</span>(<span class="literal">NULL</span>);<span class="comment">//call function1 </span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">0</span>);<span class="comment">//call function1 </span></span><br><span class="line"><span class="built_in">f</span>(<span class="literal">nullptr</span>);<span class="comment">//call function2</span></span><br></pre></td></tr></table></figure>
<p><strong>file_name</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> <span class="keyword">define</span>(__cplusplus)&amp;&amp; __cplusplus&gt;=201103L</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _GXX_NULLPTR_T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GXX_NULLPTR_T</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(<span class="literal">nullptr</span>)</span> <span class="type">nullptr_t</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// ...</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="keyword">endif</span></span></span></span><br></pre></td></tr></table></figure>

<h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><h3 id="在类型繁琐以及无法确定返回参数类型时使用-lambda-function"><a href="#在类型繁琐以及无法确定返回参数类型时使用-lambda-function" class="headerlink" title="在类型繁琐以及无法确定返回参数类型时使用(lambda function)"></a><strong>在类型繁琐以及无法确定返回参数类型时使用(lambda function)</strong></h3><h3 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;string&gt; v;</span><br><span class="line"><span class="keyword">auto</span> pos=v.<span class="built_in">begin</span>();<span class="comment">// 类型写起来繁琐</span></span><br><span class="line"><span class="keyword">auto</span> i=[](<span class="type">int</span> x)-&gt;<span class="type">bool</span>&#123; <span class="comment">// lambda</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
        <category>cpp</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>cpp11&amp;14</tag>
        <tag>可变参数模板</tag>
        <tag>nullptr</tag>
        <tag>auto</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp 面向对象基础--基础与头文件声明</title>
    <url>/2022/03/19/cpp-%E4%BE%AF%E6%8D%B7Note/</url>
    <content><![CDATA[<!-- HTML方式: 直接在 Markdown 文件中编写 HTML 来调用 -->
<!-- 其中 class="blockquote-center" 是必须的 -->
<!-- <blockquote class="blockquote-center">this is note</blockquote> -->

<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="c与cpp-的区别"><a href="#c与cpp-的区别" class="headerlink" title="c与cpp 的区别"></a>c与cpp 的区别</h3><table>
<thead>
<tr>
<th>语言</th>
<th>c</th>
<th>cpp</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>Object Base(基于对象)</td>
<td>Object Oriented(面向对象)</td>
</tr>
<tr>
<td></td>
<td>面对**单一的class(类)**设计</td>
<td>面对多重classes的设计，着重于<strong>class之间的关系</strong></td>
</tr>
<tr>
<td>头文件的书写区别 注（头文件的后缀名在不同平台可能不同）引用c的头文件要在前面加c</td>
<td>&lt;stdio&gt;</td>
<td>&lt;cstdio&gt; &lt;iostream&gt;</td>
</tr>
</tbody></table>
<span id="more"></span>

<h3 id="防卫式生命"><a href="#防卫式生命" class="headerlink" title="防卫式生命"></a>防卫式生命</h3><p><em>为了解决引用顺序的问题</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __FILENAME__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __FILENAME__</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="头文件布局"><a href="#头文件布局" class="headerlink" title="头文件布局"></a>头文件布局</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __FILENAME__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __FILENAME__</span></span><br><span class="line"><span class="comment">// 前项生命</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类定义</span></span><br><span class="line">complex::<span class="built_in">method</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="class声明-模板类"><a href="#class声明-模板类" class="headerlink" title="class声明(模板类)"></a>class声明(模板类)</h2><ul>
<li>complex.h</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __COMPLEX__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __COMPLEX__</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">complex</span>(T r=<span class="number">0</span>,T i=<span class="number">0</span>):<span class="built_in">re</span>(r),<span class="built_in">im</span>(i)&#123;&#125;</span><br><span class="line">	complex&amp; <span class="keyword">operator</span> +=(<span class="type">const</span> complex&amp;);</span><br><span class="line">	<span class="function">T <span class="title">real</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> re;&#125; <span class="comment">//表示函数不会修改任何东西</span></span><br><span class="line">	<span class="function">T <span class="title">imag</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> im;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T re,im;</span><br><span class="line">	<span class="keyword">friend</span> complex&amp; __doapl(complex*,<span class="type">const</span> complex&amp;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>Complex 类的使用</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">complex&lt;<span class="type">double</span>&gt; <span class="title">complexDouble</span><span class="params">(<span class="number">1.0</span>,<span class="number">2.0</span>)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
        <category>cpp</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>侯捷</tag>
        <tag>头文件</tag>
      </tags>
  </entry>
</search>
