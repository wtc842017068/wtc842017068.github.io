<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>class template</title>
    <url>/2022/03/22/class-template/</url>
    <content><![CDATA[<!-- <blockquote class="blockquote-center">this is note</blockquote> -->
<ul>
<li><p>class Template</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">complex</span>(T r=<span class="number">0</span>;T i=<span class="number">0</span>):<span class="built_in">re</span>(r),<span class="built_in">im</span>(i)&#123;&#125;</span><br><span class="line">    complex&amp; <span class="keyword">operator</span> +=(<span class="type">const</span> complex&amp;);</span><br><span class="line">    <span class="function">T <span class="title">real</span><span class="params">()</span><span class="type">const</span></span>&#123;<span class="keyword">return</span> re;&#125;</span><br><span class="line">    <span class="function">T <span class="title">imag</span><span class="params">()</span><span class="type">const</span></span>&#123;<span class="keyword">return</span> im;&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    T re,im;</span><br><span class="line">    <span class="keyword">friend</span> complex&amp; __doapl(complex*, <span class="type">const</span> complex)</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">complex&lt;<span class="type">double</span>&gt; <span class="title">c1</span><span class="params">(<span class="number">2.5</span>,<span class="number">1.4</span>)</span></span>;</span><br><span class="line">    <span class="function">complex&lt;<span class="type">int</span>&gt; <span class="title">c2</span><span class="params">(<span class="number">2</span>,<span class="number">6</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数模板</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="comment">//class 可以换位typename</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span></span></span><br><span class="line"><span class="function"><span class="type">const</span> T&amp; <span class="title">min</span><span class="params">(<span class="type">const</span> T&amp;a,<span class="type">const</span> T&amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b&lt;a ? b:a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">* 成员模板</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pair</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    T1 first;</span><br><span class="line">    T2 second;</span><br><span class="line">    <span class="built_in">pair</span>():<span class="built_in">first</span>(<span class="built_in">T1</span>()),<span class="built_in">second</span>(<span class="built_in">T2</span>())&#123;&#125;</span><br><span class="line">    <span class="built_in">pair</span>(<span class="type">const</span> T1&amp; a,<span class="type">const</span> T2&amp; b):<span class="built_in">first</span>(a),<span class="built_in">second</span>(b)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U1</span>,<span class="keyword">class</span> <span class="title class_">U2</span>&gt;</span><br><span class="line">    <span class="built_in">pair</span>(<span class="type">const</span> pair&lt;U1,U2&gt;&amp; p):<span class="built_in">first</span>(p.first),<span class="built_in">second</span>(p.second)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- more --&gt;</span><br><span class="line"><span class="meta"># class Template</span></span><br><span class="line">```cpp</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">complex</span>(T r=<span class="number">0</span>;T i=<span class="number">0</span>):<span class="built_in">re</span>(r),<span class="built_in">im</span>(i)&#123;&#125;</span><br><span class="line">    complex&amp; <span class="keyword">operator</span> +=(<span class="type">const</span> complex&amp;);</span><br><span class="line">    <span class="function">T <span class="title">real</span><span class="params">()</span><span class="type">const</span></span>&#123;<span class="keyword">return</span> re;&#125;</span><br><span class="line">    <span class="function">T <span class="title">imag</span><span class="params">()</span><span class="type">const</span></span>&#123;<span class="keyword">return</span> im;&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    T re,im;</span><br><span class="line">    <span class="keyword">friend</span> complex&amp; __doapl(complex*, <span class="type">const</span> complex)</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">complex&lt;<span class="type">double</span>&gt; <span class="title">c1</span><span class="params">(<span class="number">2.5</span>,<span class="number">1.4</span>)</span></span>;</span><br><span class="line">    <span class="function">complex&lt;<span class="type">int</span>&gt; <span class="title">c2</span><span class="params">(<span class="number">2</span>,<span class="number">6</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="function-Template"><a href="#function-Template" class="headerlink" title="function Template"></a>function Template</h1><p><em>函数模板不用指明类型</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="comment">//class 可以换位typename</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span></span></span><br><span class="line"><span class="function"><span class="type">const</span> T&amp; <span class="title">min</span><span class="params">(<span class="type">const</span> T&amp;a,<span class="type">const</span> T&amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b&lt;a ? b:a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是类对象要看对象是否重载了操作符&lt;</span></span><br></pre></td></tr></table></figure>


<h1 id="成员模板"><a href="#成员模板" class="headerlink" title="成员模板"></a>成员模板</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pair</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    T1 first;</span><br><span class="line">    T2 second;</span><br><span class="line">    <span class="built_in">pair</span>():<span class="built_in">first</span>(<span class="built_in">T1</span>()),<span class="built_in">second</span>(<span class="built_in">T2</span>())&#123;&#125;</span><br><span class="line">    <span class="built_in">pair</span>(<span class="type">const</span> T1&amp; a,<span class="type">const</span> T2&amp; b):<span class="built_in">first</span>(a),<span class="built_in">second</span>(b)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U1</span>,<span class="keyword">class</span> <span class="title class_">U2</span>&gt;</span><br><span class="line">    <span class="built_in">pair</span>(<span class="type">const</span> pair&lt;U1,U2&gt;&amp; p):<span class="built_in">first</span>(p.first),<span class="built_in">second</span>(p.second)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived1</span>:<span class="keyword">public</span> Base1&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dervied2</span>:<span class="keyword">public</span> Base2&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    T1   ,T2             U1     ,  U2</span></span><br><span class="line"><span class="function">pair&lt;Base1,Base2&gt; <span class="title">p2</span><span class="params">(pair&lt;Dervied1,Derived2&gt;())</span></span>;</span><br></pre></td></tr></table></figure>

<p><em>例子</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_prt</span>:<span class="keyword">public</span> __share_ptr&lt;_Tp&gt;&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp1&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">(_Tp1 __p)</span>:__shared_ptr&lt;_Tp&gt;(__p)&#123;</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Base1* prt=<span class="keyword">new</span> Derived; <span class="comment">// up-cast</span></span><br><span class="line"><span class="function">shared_ptr&lt;Base1&gt; <span class="title">sptr</span><span class="params">(<span class="keyword">new</span> Derived1)</span></span>;<span class="comment">// 模拟 up-cast</span></span><br></pre></td></tr></table></figure>

<h1 id="特化"><a href="#特化" class="headerlink" title="特化"></a>特化</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">has</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">char</span>&gt;&#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">char</span> x)</span><span class="type">const</span> </span>&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">int</span>&gt;&#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span><span class="type">const</span> </span>&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">long</span>&gt;&#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">long</span> x)</span><span class="type">const</span> </span>&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="偏特化"><a href="#偏特化" class="headerlink" title="偏特化"></a>偏特化</h1><ul>
<li><p>个数的偏特化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从左向右特化，个数的特化，只有一个模板参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> Alloc=...&gt;</span><br><span class="line"><span class="keyword">class</span> Vector&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Alloc=...&gt;</span><br><span class="line"><span class="keyword">class</span> vector&lt;<span class="type">bool</span>,Alloc&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>范围上的偏</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指定是指针</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&lt;T*&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">C&lt;string&gt; obj1;</span><br><span class="line">C&lt;string*&gt; obj2;</span><br></pre></td></tr></table></figure>

<h1 id="模板模板参数（template-template-parameter）"><a href="#模板模板参数（template-template-parameter）" class="headerlink" title="模板模板参数（template template parameter）"></a>模板模板参数（template template parameter）</h1><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">template</span> T ,<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Container</span>&gt; <span class="comment">//template&lt;template T ,template&lt;class T&gt; class Container&gt; </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XCls</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Container&lt;T&gt; c; <span class="comment">//用第一个模板参数做参数</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ....;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Lst = list&lt;T,allocator&lt;T&gt;&gt;;<span class="comment">//别名</span></span><br><span class="line"></span><br><span class="line">XCls&lt;string, list&gt; mylst1;<span class="comment">//Error 默认模板的第二参数，</span></span><br><span class="line"></span><br><span class="line">XCls&lt;string, Lst&gt; mylst1;<span class="comment">//</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">template</span> T ,<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">SmartPtr</span>&gt; <span class="comment">//template&lt;template T ,template&lt;class T&gt; class Container&gt; </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XCls</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        SmartPtr&lt;T&gt; c; <span class="comment">//用第一个模板参数做参数</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">XCls</span>():<span class="built_in">sp</span>(<span class="keyword">new</span> T)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Lst = list&lt;T,allocator&lt;T&gt;&gt;;<span class="comment">//别名</span></span><br><span class="line"></span><br><span class="line">XCls&lt;string, list&gt; mylst1;<span class="comment">//Error 默认模板的第二参数，</span></span><br><span class="line"></span><br><span class="line">XCls&lt;string, Lst&gt; mylst1;<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">XCls&lt;string,shared_ptr&gt; p1;</span><br><span class="line">XCls&lt;<span class="type">double</span>,unique_ptr&gt; p2; <span class="comment">// Error</span></span><br><span class="line">XCls&lt;<span class="type">int</span>,weak_ptr&gt; p3;<span class="comment">// Error</span></span><br><span class="line">XCls&lt;<span class="type">int</span>,auto_ptr&gt; p4;</span><br></pre></td></tr></table></figure>

<h2 id="是否是模板模板参数"><a href="#是否是模板模板参数" class="headerlink" title="是否是模板模板参数"></a>是否是模板模板参数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Sequence</span> = deque&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> stack&#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> == &lt;&gt; (<span class="type">const</span> stack&amp;,<span class="type">const</span> stack)</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; &lt;&gt; (<span class="type">const</span> stack&amp;,<span class="type">const</span> stack)</span><br><span class="line"></span><br><span class="line">    protect:</span><br><span class="line">    Sequence c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">stack&lt;<span class="type">int</span>,list&lt;<span class="type">int</span>&gt;&gt; s2; <span class="comment">//没有模糊的地带了，是确定的。因此不是模板模板参数 </span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
        <category>cpp</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>class-template</tag>
        <tag>function-template</tag>
        <tag>成员模板</tag>
        <tag>特化</tag>
        <tag>偏特话</tag>
        <tag>模板模板参数</tag>
        <tag>别名</tag>
      </tags>
  </entry>
  <entry>
    <title>OOP&amp;OOD</title>
    <url>/2022/03/20/OOP-OOD/</url>
    <content><![CDATA[<!-- <blockquote class="blockquote-center">this is note</blockquote> -->
<ul>
<li>继承</li>
<li>复合</li>
<li>委托<span id="more"></span>
<h1 id="复合"><a href="#复合" class="headerlink" title="复合"></a>复合</h1></li>
<li>表示有<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="comment">//设计模式是Adapter 适配器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">queue</span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    deque&lt;T&gt; c;<span class="comment">// 底层容器</span></span><br><span class="line">    <span class="keyword">public</span>：</span><br><span class="line">     <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> c.<span class="built_in">empty</span>();&#125;</span><br><span class="line">     <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">size</span>();&#125;</span><br><span class="line">     <span class="function">reference <span class="title">front</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> c.<span class="built_in">front</span>();&#125;</span><br><span class="line">     <span class="function">reference <span class="title">back</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> c.<span class="built_in">back</span>();&#125;</span><br><span class="line">     <span class="comment">//</span></span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span></span>&#123;c.<span class="built_in">push_back</span>(x);&#125;</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;c.<span class="built_in">pop_front</span>();&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入默认构造不符合要求，可以显示制定调用的内部构造</span></span><br><span class="line">Container::<span class="built_in">Container</span>():<span class="built_in">Component</span>()&#123;....&#125;;</span><br><span class="line">Container::~<span class="built_in">Container</span>():~<span class="built_in">Component</span>()&#123;....&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="构造-amp-析构"><a href="#构造-amp-析构" class="headerlink" title="构造&amp;析构"></a>构造&amp;析构</h2></li>
<li>构造由内而外</li>
<li>析构由外而内</li>
</ul>
<h1 id="委托-Composition-by-Referce"><a href="#委托-Composition-by-Referce" class="headerlink" title="委托 Composition by Referce"></a>委托 Composition by Referce</h1><ul>
<li>内部有一个指针<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file String.hpp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringRep</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">String</span>();</span><br><span class="line">        <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* s);</span><br><span class="line">        <span class="built_in">String</span>(<span class="type">const</span> String&amp; s);</span><br><span class="line">        String &amp;<span class="keyword">operator</span>=(<span class="type">const</span> String&amp; s);</span><br><span class="line">        ~<span class="built_in">String</span>();</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        StringRep* rep;<span class="comment">//pimpl 当前文件只是接口，具体实现由另一个类实现</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="构造-amp-析构-1"><a href="#构造-amp-析构-1" class="headerlink" title="构造&amp;析构"></a>构造&amp;析构</h2></li>
<li>因为是引用所以生命周期可能不一致</li>
</ul>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><ul>
<li>is a<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">_List_node_base</span></span><br><span class="line">&#123;</span><br><span class="line">    _List_node_base* _M_next;</span><br><span class="line">    _List_node_base* _M_prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_List_node</span>:<span class="keyword">public</span> _List_node_base&#123;</span><br><span class="line">    _Tp _M_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="构造-amp-析构-2"><a href="#构造-amp-析构-2" class="headerlink" title="构造&amp;析构"></a>构造&amp;析构</h2></li>
<li>构造由内而外</li>
<li>析构由外而内</li>
</ul>
<p><strong>父类函数的析构函数要是virtual</strong></p>
<h2 id="继承与虚函数"><a href="#继承与虚函数" class="headerlink" title="继承与虚函数"></a>继承与虚函数</h2><ul>
<li>non-virtual 函数：不希望子类重新定义</li>
<li>virtual：希望子类重新定义,但已有默认定义</li>
<li>pure vitual: 希望子类重新定义，当前没有默认定义</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>=<span class="number">0</span>; <span class="comment">//纯虚函数</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">error</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>; <span class="comment">// 虚函数</span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">objectID</span><span class="params">()</span><span class="type">const</span></span>; <span class="comment">//non-virtual</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sample"><a href="#sample" class="headerlink" title="sample"></a>sample</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CDocument::<span class="built_in">OnFileOpen</span>()&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">Serialize</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Class CMyDoc:<span class="keyword">public</span> CDocument&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">Serialize</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">main</span>()&#123;</span><br><span class="line">    CMyDoc myDoc;</span><br><span class="line">    ....</span><br><span class="line">    myDoc.<span class="built_in">OnFileOpen</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Template-Method-设计模式"><a href="#Template-Method-设计模式" class="headerlink" title="Template Method(设计模式)"></a>Template Method(设计模式)</h3><ol>
<li>构建子类对象</li>
<li>调用父类方法（父类方法中调用了，虚函数）</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
        <category>cpp</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>虚函数</tag>
        <tag>复合</tag>
        <tag>继承</tag>
        <tag>委托</tag>
      </tags>
  </entry>
  <entry>
    <title>conversion function(转换函数)</title>
    <url>/2022/03/21/conversion-function-%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<!-- <blockquote class="blockquote-center">this is note</blockquote> -->
<ul>
<li>转换函数<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span></span>&#123; <span class="comment">//表示在需要转换为double时调用这个函数,将对象转换为double 返回值不需要编写</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="type">double</span>)(m_numertor / m_denominator)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h1><h2 id="将对象转换出去"><a href="#将对象转换出去" class="headerlink" title="将对象转换出去"></a>将对象转换出去</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fraction</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">         <span class="built_in">Fraction</span>(<span class="type">int</span> num,<span class="type">int</span> den=<span class="number">1</span>):<span class="built_in">m_numertor</span>(num),<span class="built_in">m_denominator</span>(den)&#123;&#125; <span class="comment">// one argument(只需要一个实参就够了),two paramenter。</span></span><br><span class="line">        <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span></span>&#123; <span class="comment">//表示在需要转换为double时调用这个函数,可以写多个</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="type">double</span>)(m_numertor / m_denominator)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> m_numertor;</span><br><span class="line">        <span class="type">int</span> m_denominator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">double</span> d=<span class="number">4</span>+f;</span><br></pre></td></tr></table></figure>
<p>编译器会做如下操作:</p>
<ol>
<li>查找全局函数+,并且第一个参数是int 或者double 第二个参数是Fraction</li>
<li>尝试将Fraction 转换为double；这个存在，既可以编译通过</li>
<li>将4 转换为Fraction<h2 id="将其他的转换为特定类型"><a href="#将其他的转换为特定类型" class="headerlink" title="将其他的转换为特定类型"></a>将其他的转换为特定类型</h2></li>
</ol>
<p><em>non-explicit-one-argument 构造</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fraction</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//non explicit 函数</span></span><br><span class="line">        <span class="built_in">Fraction</span>(<span class="type">int</span> num,<span class="type">int</span> den=<span class="number">1</span>):<span class="built_in">m_numertor</span>(num),<span class="built_in">m_denominator</span>(den)&#123;&#125; <span class="comment">// one argument(只需要一个实参就够了),two paramenter。</span></span><br><span class="line">        <span class="keyword">operator</span> + (<span class="type">const</span> Fraction&amp; f)&#123; <span class="comment">//表示在需要转换为double时调用这个函数,可以写多个</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Fraction</span>(f);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> m_numertor;</span><br><span class="line">        <span class="type">int</span> m_denominator;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line">Fraction d=<span class="number">4</span>+f;<span class="comment">//这个与设计不同，设计的在d=f+4 时调用</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="冲突情况"><a href="#冲突情况" class="headerlink" title="冲突情况"></a>冲突情况</h3><ul>
<li>编译失败<ul>
<li>存在多个情况，<ul>
<li>将4转换为Fraction ，相加</li>
<li>将Fraction 转换为double，得到double再转换为Fraction的情况<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fraction</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//non explicit 函数</span></span><br><span class="line">        <span class="built_in">Fraction</span>(<span class="type">int</span> num,<span class="type">int</span> den=<span class="number">1</span>):<span class="built_in">m_numertor</span>(num),<span class="built_in">m_denominator</span>(den)&#123;&#125; </span><br><span class="line">        <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span></span>&#123; </span><br><span class="line">            <span class="keyword">return</span> (<span class="type">double</span>)(m_numertor / m_denominator)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">operator</span> + (<span class="type">const</span> Fraction&amp; f)&#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Fraction</span>(f);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> m_numertor;</span><br><span class="line">        <span class="type">int</span> m_denominator;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line">Fraction d=f+<span class="number">4</span>; <span class="comment">//Error ambiguous</span></span><br></pre></td></tr></table></figure>
<h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fraction</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//explicit 函数，构造函数前面</span></span><br><span class="line">     <span class="function"><span class="keyword">explicit</span>   <span class="title">Fraction</span><span class="params">(<span class="type">int</span> num,<span class="type">int</span> den=<span class="number">1</span>)</span>:m_numertor(num),m_denominator(den)&#123;</span>&#125; </span><br><span class="line">        <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span></span>&#123; </span><br><span class="line">            <span class="keyword">return</span> (<span class="type">double</span>)(m_numertor / m_denominator)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">operator</span> + (<span class="type">const</span> Fraction&amp; f)&#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Fraction</span>(f);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> m_numertor;</span><br><span class="line">        <span class="type">int</span> m_denominator;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line">Fraction d=f+<span class="number">4</span>; <span class="comment">//Error 4 不会默认转化为 Fraction，因为explicit，所以编译失败</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
        <category>cpp</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>转换函数</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp 11&amp;14 decltype&amp;lambdas</title>
    <url>/2022/04/16/cpp-11-14-decltype&amp;lambdas/</url>
    <content><![CDATA[<!-- <blockquote class="blockquote-center">this is note</blockquote> -->
<ul>
<li>decltype<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;string,<span class="type">float</span>&gt; coll;</span><br><span class="line"><span class="keyword">decltype</span>(coll)::value_type elem; <span class="comment">// map&lt;string,float&gt;::value ele;</span></span><br></pre></td></tr></table></figure></li>
<li>lambdas<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mutable 关键字，表示是否可以改写</span></span><br><span class="line"><span class="comment">//thorwSpec 表示可以抛出的异常</span></span><br><span class="line"><span class="comment">//retType 表示返回值</span></span><br><span class="line"><span class="comment">//三个都没有(parameters)可以不写</span></span><br><span class="line"><span class="comment">//             ^</span></span><br><span class="line"><span class="comment">//[] 这个里面可以放外部的变量，不放入就看不见。可以传值和引用</span></span><br><span class="line">[...](parameters)<span class="built_in">mutable</span>(opt),<span class="built_in">thorwSpec</span>(opt)-&gt;<span class="built_in">retType</span>(opt)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> i=[...](parameters)<span class="built_in">mutable</span>(opt),<span class="built_in">thorwSpec</span>(opt)-&gt;<span class="built_in">retType</span>(opt)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;()<span class="comment">//表示直接调用</span></span><br></pre></td></tr></table></figure>
<span id="more"></span></li>
</ul>
<h1 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h1><p><strong>获取一个表达式的类型</strong></p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;string,<span class="type">float</span>&gt; coll;</span><br><span class="line"><span class="keyword">decltype</span>(coll)::value_type elem; <span class="comment">// map&lt;string,float&gt;::value ele;</span></span><br></pre></td></tr></table></figure>
<h2 id="sample"><a href="#sample" class="headerlink" title="sample"></a>sample</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//**************************************//</span></span><br><span class="line">map&lt;string,<span class="type">float</span>&gt; coll;</span><br><span class="line"><span class="keyword">decltype</span>(coll)::value_type elem; <span class="comment">// map&lt;string,float&gt;::value ele;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//**************************************//</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="title">decltype</span><span class="params">(x+y)</span> <span class="title">add</span><span class="params">(T1 x,T2 y)</span></span>; <span class="comment">//表示表达式返回值的结果是x+y之后的类型，编译不过，</span></span><br><span class="line"><span class="comment">//改进方法</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T1 x,T2 y)</span>-&gt;<span class="title">decltype</span><span class="params">(x+y)</span></span>; <span class="comment">//函数返回类型的制定方式，与lambda 表达式类似</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//**************************************//</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test18_decltype</span><span class="params">(T obj)</span></span>&#123;</span><br><span class="line">    map&lt;string,<span class="type">float</span>&gt;::value_type elem1;</span><br><span class="line"></span><br><span class="line">    map&lt;string,<span class="type">float</span>&gt;coll;</span><br><span class="line">    <span class="keyword">decltype</span>(coll)::value_type elem2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="title">decltype</span><span class="params">(obj)</span>::iterator iType</span>;<span class="comment">//等价于 typedef typename T::iterator iType</span></span><br><span class="line"><span class="comment">// 我知道obj 是一个容器，因此一定有iterator, 一旦使用:: 前要跟上 typename 告诉编译器后面的是一个类型的名字</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//**************************************//</span></span><br><span class="line"><span class="keyword">auto</span> cmp=[](<span class="type">const</span> Person&amp; p1,<span class="type">const</span> Person&amp; p2)&#123;</span><br><span class="line">    <span class="keyword">return</span> p1.<span class="built_in">lastname</span>()&lt;p2.<span class="built_in">lastname</span>()||(p1.<span class="built_in">lastname</span>()==p2.<span class="built_in">lastname</span>()&amp;&amp;p1.firstname&lt;p2.<span class="built_in">firstname</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::set&lt;Person,<span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">coll</span>(cmp);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="lambdas"><a href="#lambdas" class="headerlink" title="lambdas"></a>lambdas</h1><p><strong>是一个对象，但是用起来像一个function</strong><br><strong>类型是一个匿名的函数对象</strong></p>
<h2 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mutable 关键字，表示是否可以改写</span></span><br><span class="line"><span class="comment">//thorwSpec 表示可以抛出的异常</span></span><br><span class="line"><span class="comment">//retType 表示返回值</span></span><br><span class="line"><span class="comment">//三个都没有(parameters)可以不写</span></span><br><span class="line"><span class="comment">//             ^</span></span><br><span class="line"><span class="comment">//[] 这个里面可以放外部的变量，不放入就看不见。可以传值和引用</span></span><br><span class="line">[...](parameters)<span class="built_in">mutable</span>(opt),<span class="built_in">thorwSpec</span>(opt)-&gt;<span class="built_in">retType</span>(opt)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> i=[...](parameters)<span class="built_in">mutable</span>(opt),<span class="built_in">thorwSpec</span>(opt)-&gt;<span class="built_in">retType</span>(opt)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;()<span class="comment">//表示直接调用</span></span><br></pre></td></tr></table></figure>
<h2 id="sample-1"><a href="#sample-1" class="headerlink" title="sample"></a>sample</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//******************************</span></span><br><span class="line"><span class="type">int</span> id=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f=[id]()<span class="keyword">mutable</span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;id:&quot;</span>&lt;&lt;id&lt;&lt;std&lt;&lt;endl;</span><br><span class="line">    ++id;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x=<span class="number">5</span>; <span class="comment">//声明静态变量</span></span><br><span class="line">    <span class="type">int</span> y=<span class="number">6</span>;</span><br><span class="line">    <span class="keyword">return</span> id; <span class="comment">//返回数值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上述表达式相当于如下代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Functor</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span></span>&#123;</span><br><span class="line">            std::cout&lt;&lt;<span class="string">&quot;id&quot;</span>&lt;&lt;id&lt;&lt;endl;</span><br><span class="line">            id++;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Functor f;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">id=<span class="number">42</span>;</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line">std::cout&lt;&lt;id&lt;&lt;std::endl;</span><br><span class="line"><span class="comment">// id:0</span></span><br><span class="line"><span class="comment">// id:1</span></span><br><span class="line"><span class="comment">// id:2</span></span><br><span class="line"><span class="comment">// 42</span></span><br><span class="line"><span class="comment">// 因为编译的时候id 已经变为0,因为[id]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//********************************</span></span><br><span class="line"><span class="type">int</span> tobefound=<span class="number">5l</span></span><br><span class="line"><span class="keyword">auto</span> lambda=[tobefound](<span class="type">int</span> val)&#123;<span class="keyword">return</span> val == tobefound;&#125;;</span><br><span class="line"><span class="comment">//上式等价于</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnNameLocalFunction</span>&#123;</span><br><span class="line">    <span class="type">int</span> localVar;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UnNamedLocalFunction</span>(<span class="type">int</span> var):<span class="built_in">localVar</span>(var)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val==localVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="type">bool</span> b1=<span class="built_in">lambda1</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">UnNameLocalFunction <span class="title">lambda2</span><span class="params">(tobefound)</span></span>;</span><br><span class="line"><span class="type">bool</span> b2=<span class="built_in">lambda2</span>(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//**********************</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vi&#123;<span class="number">5</span>,<span class="number">32</span>,<span class="number">56</span>,<span class="number">214</span>,<span class="number">777</span>,<span class="number">5543</span>,<span class="number">22</span>&#125;</span><br><span class="line"><span class="type">int</span> x=<span class="number">30</span>;</span><br><span class="line"><span class="type">int</span> y=<span class="number">100</span>;</span><br><span class="line">vi.<span class="built_in">erase</span>(<span class="built_in">remove_if</span>(vi.<span class="built_in">begin</span>(),vi.<span class="built_in">end</span>(),[x,y](<span class="type">int</span> n)&#123;<span class="keyword">return</span> x&lt;n &amp;&amp; n&lt;y&#125;))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i:vi)</span><br><span class="line">    cout&lt;&lt; i&lt;&lt;<span class="string">&quot;&quot;</span>; <span class="comment">//5,214,777,5543</span></span><br><span class="line">cout&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<h3 id="lambdas的对比"><a href="#lambdas的对比" class="headerlink" title="lambdas的对比"></a>lambdas的对比</h3><ul>
<li><p>类型1(值传递,mutable)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> id=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f=[id]()<span class="keyword">mutable</span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;id:&quot;</span>&lt;&lt;id&lt;&lt;std&lt;&lt;endl;</span><br><span class="line">    ++id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id=<span class="number">42</span>;</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line">std::cout&lt;&lt;id&lt;&lt;std::endl;</span><br><span class="line"><span class="comment">// id:0</span></span><br><span class="line"><span class="comment">// id:1</span></span><br><span class="line"><span class="comment">// id:2</span></span><br><span class="line"><span class="comment">// 42</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>类型2(引用传递)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> id=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f=[&amp;id]()<span class="keyword">mutable</span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;id:&quot;</span>&lt;&lt;id&lt;&lt;std&lt;&lt;endl;</span><br><span class="line">    ++id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id=<span class="number">42</span>;</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line">std::cout&lt;&lt;id&lt;&lt;std::endl;</span><br><span class="line"><span class="comment">// id:42</span></span><br><span class="line"><span class="comment">// id:43</span></span><br><span class="line"><span class="comment">// id:44</span></span><br><span class="line"><span class="comment">// 45</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>类型3(默认全部传递,值传递)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> id=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f=[=]()<span class="keyword">mutable</span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;id:&quot;</span>&lt;&lt;id&lt;&lt;std&lt;&lt;endl;</span><br><span class="line">    ++id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id=<span class="number">42</span>;</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line">std::cout&lt;&lt;id&lt;&lt;std::endl;</span><br><span class="line"><span class="comment">// id:42</span></span><br><span class="line"><span class="comment">// id:43</span></span><br><span class="line"><span class="comment">// id:44</span></span><br><span class="line"><span class="comment">// 45</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>类型4(值传递) Error</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> id=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//编译报错，因为id为只读不可修改</span></span><br><span class="line"><span class="keyword">auto</span> f=[id]()&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;id:&quot;</span>&lt;&lt;id&lt;&lt;std&lt;&lt;endl;</span><br><span class="line">    ++id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id=<span class="number">42</span>;</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line">std::cout&lt;&lt;id&lt;&lt;std::endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p><strong>当我们需要知道lambadas表达式的类型时，这种情况主要被应用在传递一个函数作为<em>hash函数</em>或者<em>排序函数</em>或者<em>排序的准则对于一个无序的容器</em></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> cmp=[](<span class="type">const</span> Person&amp; p1,<span class="type">const</span> Person&amp; p2)&#123;</span><br><span class="line">    <span class="keyword">return</span> p1.<span class="built_in">lastname</span>()&lt;p2.<span class="built_in">lastname</span>()||(p1.<span class="built_in">lastname</span>()==p2.<span class="built_in">lastname</span>()&amp;&amp;p1.firstname&lt;p2.<span class="built_in">firstname</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::set&lt;Person,<span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">coll</span>(cmp);</span><br><span class="line"><span class="comment">//对于这个实现，我们需要将cmp对象传入,要不然会默认调用Compare 的默认构造函数，但是由于传入的是匿名函数，所以没有默认构造。编译会报错</span></span><br></pre></td></tr></table></figure>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Compare</span>=less&lt;Key&gt;,</span><br><span class="line">                   <span class="keyword">class</span> Alloc=alloc&gt;</span><br><span class="line"><span class="keyword">class</span> set&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//typedefs:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">typedef</span> Compare key_compare;</span><br><span class="line">    <span class="keyword">typedef</span> Compare value_compare;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="keyword">typedef</span> rb_tree&lt;key_type,value_type,</span><br><span class="line">                identity&lt;value_type&gt;,</span><br><span class="line">                key_compare,Alloc&gt; rep_type;</span><br><span class="line"> rep_type t;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"> ...</span><br><span class="line"> <span class="built_in">set</span>():<span class="built_in">t</span>(<span class="built_in">Compare</span>())&#123;&#125;</span><br><span class="line"> <span class="function"><span class="keyword">explicit</span> <span class="title">set</span><span class="params">(<span class="type">const</span> Compare&amp; comp)</span>:t(comp)</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
        <category>cpp</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>decltype</tag>
        <tag>lambdas</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp 11&amp;14 default&amp;delete 以及template</title>
    <url>/2022/04/13/cpp-11-14-default&amp;delete%20%E4%BB%A5%E5%8F%8Atemplate/</url>
    <content><![CDATA[<!-- <blockquote class="blockquote-center">this is note</blockquote> -->
<ul>
<li>default&amp;delete<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Zoo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//big five 可以运用到default，其它函数上会报错</span></span><br><span class="line">        <span class="built_in">Zoo</span>(<span class="type">int</span> i1,<span class="type">int</span> i2):<span class="built_in">d1</span>(i1),<span class="built_in">d2</span>(i2)&#123;&#125;<span class="comment">//构造函数</span></span><br><span class="line">        <span class="built_in">Zoo</span>(<span class="type">const</span> Zoo&amp;)=<span class="keyword">delete</span>;<span class="comment">//拷贝构造函数，不要这个函数,不可以使用</span></span><br><span class="line">        <span class="built_in">Zoo</span>(Zoo&amp;&amp;)=<span class="keyword">default</span>;<span class="comment">//右值引用，使用编译器默认的版本</span></span><br><span class="line">        Zoo&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Zoo&amp;)=<span class="keyword">default</span>;<span class="comment">//拷贝赋值</span></span><br><span class="line">        Zoo&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Zoo&amp;&amp;)=<span class="keyword">delete</span>;<span class="comment">//移动赋值</span></span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Zoo</span>()&#123;&#125;;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> d1,d2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>alias Template<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Vec=std::vector&lt;T,MyAlloc&lt;T&gt;&gt;;</span><br><span class="line">Vec&lt;<span class="type">int</span>&gt; coll;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Vec<span class="string">&lt;T&gt;</span> template<span class="string">&lt;typename T&gt;</span> std::vector<span class="string">&lt;T,MyAlloc&lt;T&gt;</span>&gt;;</span></span><br><span class="line">Vec&lt;<span class="type">int</span>&gt; coll;</span><br><span class="line"><span class="comment">//template&lt;typename int&gt; std::vector&lt;int,MyAlloc&lt;int&gt;&gt; 是这样的效果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用typedef,因为typedef 不接收参数,只能使用如下所示</span></span><br><span class="line"><span class="keyword">typedef</span> std::vector&lt;<span class="type">int</span>,MyAlloc&lt;<span class="type">int</span>&gt;&gt; Vec;</span><br></pre></td></tr></table></figure></li>
<li>template template parameter</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">template</span>&lt;<span class="keyword">class</span>&gt; <span class="keyword">class</span> <span class="title class_">Container</span>&gt;</span><br><span class="line"><span class="comment">//template&lt;typename T,template&lt;typename&gt; class Container&gt;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XCIs</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Container&lt;T&gt; c;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">XCIs</span>()&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">long</span> i=<span class="number">0</span>;i&lt;SIZE;i++)&#123;</span><br><span class="line">                c.<span class="built_in">insert</span>(c.<span class="built_in">end</span>(),<span class="built_in">T</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">output_static_data</span>(<span class="built_in">T</span>());</span><br><span class="line">            <span class="function">Container&lt;T&gt; <span class="title">c1</span><span class="params">(c)</span></span>;</span><br><span class="line">            <span class="function">Container&lt;T&gt; <span class="title">c2</span><span class="params">(std::move(c))</span></span>;</span><br><span class="line">            c1.<span class="built_in">swap</span>(c2);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<span id="more"></span>
<h1 id="default-amp-delete"><a href="#default-amp-delete" class="headerlink" title="default&amp;delete"></a>default&amp;delete</h1><h2 id="何时需要写出big-5-函数，类中含有指针时需要写出"><a href="#何时需要写出big-5-函数，类中含有指针时需要写出" class="headerlink" title="何时需要写出big 5 函数，类中含有指针时需要写出"></a><strong>何时需要写出big 5 函数，类中含有指针时需要写出</strong></h2><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span> i):_i(i)&#123;&#125;</span><br><span class="line">    <span class="built_in">Foo</span>()=<span class="keyword">default</span>;<span class="comment">//默认构造</span></span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">const</span> Foo&amp;x):_i(x.i)&#123;&#125;</span><br><span class="line">    <span class="comment">// Foo(const Foo&amp;)=default;//存在重名函数</span></span><br><span class="line">    <span class="comment">// Foo(const Foo&amp;)=delete;//与函数定义冲突</span></span><br><span class="line">    Foo&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Foo&amp;x)&#123;_i=x.i;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">    <span class="comment">//Foo&amp; operator=(const Foo&amp; x)=default;//赋值构造函数</span></span><br><span class="line">    <span class="comment">//Foo&amp; operator=(const Foo&amp; x)=delete;</span></span><br><span class="line">    <span class="comment">// void func1()=default;//[Error] &#x27;void Foo::func1()&#x27; 没有默认的函数实现</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>=<span class="keyword">delete</span> </span><br><span class="line">    <span class="comment">// ~Foo()=delete;//析构函数不能被delete</span></span><br><span class="line">    ~<span class="built_in">Foo</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Foo <span class="title">f1</span><span class="params">(<span class="number">5</span>)</span><span class="comment">//构造</span></span></span><br><span class="line"><span class="function">Foo f2</span>;<span class="comment">//如果没有默认无参数构造会报错</span></span><br><span class="line"><span class="function">Foo <span class="title">f3</span><span class="params">(f1)</span><span class="comment">// 如果拷贝构造呗delete会报错</span></span></span><br><span class="line"><span class="function">f3</span>=f2 <span class="comment">//如果赋值构造被delete 会被报错</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NoCopy</span>&#123;</span><br><span class="line">    <span class="built_in">NoCopy</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">NoCopy</span>(<span class="type">const</span> NoCopy&amp;)=<span class="keyword">delete</span>; <span class="comment">//禁止拷贝构造</span></span><br><span class="line">    NoCopy &amp;<span class="keyword">operator</span>=(<span class="type">const</span> NoCopy&amp;)=<span class="keyword">delete</span> <span class="comment">//禁止赋值构造</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> PrivateCopy&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">PrivateCopy</span>(<span class="type">const</span> PrivateCopy&amp;);</span><br><span class="line">    PrivateCopy &amp;<span class="keyword">operator</span>=(<span class="type">const</span> PrivateCopy&amp;);</span><br><span class="line">    <span class="comment">//私有函数可被自己以及友元使用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> boost&#123;</span><br><span class="line">    <span class="keyword">namespace</span> noncopyable_ &#123;<span class="comment">//</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">noncopyable</span>&#123;</span><br><span class="line">            <span class="keyword">protected</span>:</span><br><span class="line">            <span class="built_in">noncopyable</span>()&#123;&#125;</span><br><span class="line">            ~<span class="built_in">noncopyable</span>()&#123;&#125;</span><br><span class="line">            <span class="keyword">private</span>:</span><br><span class="line">            <span class="built_in">noncopyable</span>(<span class="type">const</span> noncopyable&amp;);</span><br><span class="line">            <span class="type">const</span> noncopyable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> noncopuable&amp;);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于集成,以实现不允许拷贝的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span>&#123;&#125;;</span><br><span class="line"><span class="comment">//当函数被调用后，编译器会生成对应的默认函数,都是内联函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Empty</span>&#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment">//=======================//</span></span><br><span class="line">        <span class="comment">//*********************//</span></span><br><span class="line">        <span class="comment">// Empty e1; 使用默认构造,用于存放背后的代码，例如子类调用父类的构造函数</span></span><br><span class="line">        <span class="built_in">Empty</span>()&#123;...&#125;</span><br><span class="line">        ~<span class="built_in">Empty</span>()&#123;&#125;</span><br><span class="line">        <span class="comment">//*********************//</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//=======================//</span></span><br><span class="line">        <span class="comment">//*********************//</span></span><br><span class="line">        <span class="comment">// Empty e2(e1); 使用拷贝构造</span></span><br><span class="line">        <span class="built_in">Empty</span>(<span class="type">const</span> Empty&amp; rhs)&#123;...&#125;</span><br><span class="line">        <span class="comment">//*********************//</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//=======================//</span></span><br><span class="line">        <span class="comment">//*********************//</span></span><br><span class="line">        <span class="comment">// Empty e2(e1); 使用拷贝构造</span></span><br><span class="line">        <span class="built_in">Empty</span>(<span class="type">const</span> Empty&amp; rhs)&#123;...&#125;</span><br><span class="line">        <span class="comment">//*********************//</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//=======================//</span></span><br><span class="line">        <span class="comment">//*********************//</span></span><br><span class="line">        <span class="comment">// e2 = e1 生成赋值构造</span></span><br><span class="line">        Empty&amp; <span class="keyword">operator</span> = (<span class="type">const</span> Empty&amp; rhs)&#123;&#125; </span><br><span class="line">        <span class="comment">//*********************//</span></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Alias-别名"><a href="#Alias-别名" class="headerlink" title="Alias(别名)"></a>Alias(别名)</h1><h2 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Vec=std::vector&lt;T,MyAlloc&lt;T&gt;&gt;;</span><br><span class="line">Vec&lt;<span class="type">int</span>&gt; coll;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Vec<span class="string">&lt;T&gt;</span> template<span class="string">&lt;typename T&gt;</span> std::vector<span class="string">&lt;T,MyAlloc&lt;T&gt;</span>&gt;;</span></span><br><span class="line">Vec&lt;<span class="type">int</span>&gt; coll;</span><br><span class="line"><span class="comment">//template&lt;typename int&gt; std::vector&lt;int,MyAlloc&lt;int&gt;&gt; 是这样的效果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用typedef,因为typedef 不接收参数,只能使用如下所示</span></span><br><span class="line"><span class="keyword">typedef</span> std::vector&lt;<span class="type">int</span>,MyAlloc&lt;<span class="type">int</span>&gt;&gt; Vec;</span><br></pre></td></tr></table></figure>

<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 函数目的，测试当前类型，是否都禁止了移动构造函数</span></span><br><span class="line"><span class="comment">// 实现这样的效果需要使用 模板模板参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_moveable</span><span class="params">(Container cntr,T elem)</span></span>&#123;</span><br><span class="line">    Container&lt;T&gt; c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> i=<span class="number">0</span>;i&lt;SIZE;++i)</span><br><span class="line">        c.<span class="built_in">insert</span>(c.<span class="built_in">end</span>(),<span class="built_in">T</span>());</span><br><span class="line">    <span class="built_in">output_static_data</span>(<span class="built_in">T</span>());</span><br><span class="line">    <span class="function">Container&lt;T&gt; <span class="title">c1</span><span class="params">(c)</span></span>;</span><br><span class="line">    <span class="function">Container&lt;T&gt; <span class="title">c2</span><span class="params">(std::move(c))</span></span>;</span><br><span class="line">    c1.<span class="built_in">swap</span>(c2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test_moveable</span>(list,MyString);</span><br><span class="line"><span class="built_in">test_moveable</span>(list,MyStrNoMove);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改进</span></span><br><span class="line"><span class="comment">//Error expected nested-name-specifier before is Container</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container,<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_moveable</span><span class="params">(Container cntr,T elem)</span></span>&#123;</span><br><span class="line">    <span class="keyword">typename</span> Container&lt;T&gt; c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> i=<span class="number">0</span>;i&lt;SIZE;++i)</span><br><span class="line">        c.<span class="built_in">insert</span>(c.<span class="built_in">end</span>(),<span class="built_in">T</span>());</span><br><span class="line">    <span class="built_in">output_static_data</span>(<span class="built_in">T</span>());</span><br><span class="line">    <span class="function">Container&lt;T&gt; <span class="title">c1</span><span class="params">(c)</span></span>;</span><br><span class="line">    <span class="function">Container&lt;T&gt; <span class="title">c2</span><span class="params">(std::move(c))</span></span>;</span><br><span class="line">    c1.<span class="built_in">swap</span>(c2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test_moveable</span>(<span class="built_in">list</span>(),<span class="built_in">MyString</span>());</span><br><span class="line"><span class="built_in">test_moveable</span>(<span class="built_in">list</span>(),<span class="built_in">MyStrNoMove</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//最终版本</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_moveable</span><span class="params">(Container cntr)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取出容器的内部的类型</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;<span class="keyword">typename</span> Container::iterator&gt;::<span class="function">value_type <span class="title">Valtype</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">typename</span> Container&lt;T&gt; c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> i=<span class="number">0</span>;i&lt;SIZE;++i)</span><br><span class="line">        c.<span class="built_in">insert</span>(c.<span class="built_in">end</span>(),<span class="built_in">Valtype</span>());</span><br><span class="line">    <span class="built_in">output_static_data</span>(*(c.<span class="built_in">begin</span>()));<span class="comment">// 查看哪些静态数据被频繁的调用</span></span><br><span class="line">    <span class="function">Container&lt;T&gt; <span class="title">c1</span><span class="params">(c)</span></span>;</span><br><span class="line">    <span class="function">Container&lt;T&gt; <span class="title">c2</span><span class="params">(std::move(c))</span></span>;</span><br><span class="line">    c1.<span class="built_in">swap</span>(c2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test_moveable</span>(<span class="built_in">list</span>&lt;MyString&gt;());</span><br><span class="line"><span class="built_in">test_moveable</span>(<span class="built_in">list</span>&lt;MyStrNoMove&gt;());</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用RB-tree 时，元素需提供operator&lt;</span></span><br><span class="line"><span class="comment">//使用hashTable 时,元素需提供 operator &lt;,hash function&gt;</span></span><br><span class="line"><span class="comment">//使用multi-容器是，元素还需提供operator ==</span></span><br></pre></td></tr></table></figure>

<h2 id="模板模板参数"><a href="#模板模板参数" class="headerlink" title="模板模板参数"></a>模板模板参数</h2><h3 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span>&gt; <span class="keyword">class</span></span><br><span class="line"><span class="comment">// template&lt;class&gt; class 表示该位置是一个模板类</span></span><br><span class="line"><span class="comment">// template&lt;typename&gt; 效果相同</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">template</span>&lt;<span class="keyword">class</span>&gt; <span class="keyword">class</span> <span class="title class_">Container</span>&gt;</span><br><span class="line"><span class="comment">//template&lt;typename T,template&lt;typename&gt; class Container&gt;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XCIs</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Container&lt;T&gt; c;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">XCIs</span>()&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">long</span> i=<span class="number">0</span>;i&lt;SIZE;i++)&#123;</span><br><span class="line">                c.<span class="built_in">insert</span>(c.<span class="built_in">end</span>(),<span class="built_in">T</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">output_static_data</span>(<span class="built_in">T</span>());</span><br><span class="line">            <span class="function">Container&lt;T&gt; <span class="title">c1</span><span class="params">(c)</span></span>;</span><br><span class="line">            <span class="function">Container&lt;T&gt; <span class="title">c2</span><span class="params">(std::move(c))</span></span>;</span><br><span class="line">            c1.<span class="built_in">swap</span>(c2);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">XCIS&lt;Mystring,vector&gt;c1; <span class="comment">// 使用的时候报错,因为模板需要两个参数，而使用时只有一个模板册数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp,<span class="keyword">typename</span> _Alloc = std::allocator&lt;_Tp&gt;&gt;<span class="comment">//模板函数的默认值，第二个参数以第一个参数为参数</span></span><br><span class="line"><span class="keyword">class</span> vector :<span class="keyword">protected</span> _Vector_vase&lt;_tp,_Alloc&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终实现</span></span><br><span class="line"><span class="comment">// 不可以在函数体内声明</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Vec=vector&lt;T,allocator&lt;T&gt;&gt;;</span><br><span class="line">XCIS&lt;Mystring,Vec&gt;c1;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
        <category>cpp</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>模板模板参数</tag>
        <tag>default</tag>
        <tag>delete</tag>
        <tag>Alias(别名)</tag>
        <tag>alias template</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp 11&amp;14 type Alias,nonexcep和override</title>
    <url>/2022/04/15/cpp-11-14-type-Alias-nonexcep/</url>
    <content><![CDATA[<!-- <blockquote class="blockquote-center">this is note</blockquote> -->
<ul>
<li>Type ALias <strong>(与typedef 相似)</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//**************************//</span></span><br><span class="line"><span class="comment">//type alias,identical to</span></span><br><span class="line"><span class="comment">//typedef void(*func)(int,int);</span></span><br><span class="line"><span class="keyword">using</span> func=<span class="built_in">void</span>(*)(<span class="type">int</span>,<span class="type">int</span>);</span><br><span class="line"><span class="comment">//func 表示一个入参为(int,int)类型的函数指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">example</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span>&#123;&#125;</span><br><span class="line">func fn=example;</span><br><span class="line">typdef basic_string&lt;<span class="type">char</span>&gt; string;</span><br><span class="line"></span><br><span class="line"><span class="comment">//**************************//</span></span><br><span class="line"><span class="comment">//局部的typedef</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Container</span>&#123;</span><br><span class="line">    <span class="keyword">using</span> value_type=T;<span class="comment">//typedef T value_type</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//并且可以应用到原编程,如果上述定义了value_type</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Cntr&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn2</span><span class="params">(<span class="type">const</span> Cntr&amp; c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">typename</span> Cntr::value_type n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//**************************//</span></span><br><span class="line"><span class="comment">//用于隐藏模板参数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">CharT</span>&gt; <span class="keyword">using</span> mystring=std::basic_string&lt;CharT,std::char_traits&lt;Chart&gt;&gt;</span><br><span class="line">mystring&lt;<span class="type">char</span>&gt; str;</span><br></pre></td></tr></table></figure></li>
<li>nonexcep<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span>noexcep</span>;</span><br><span class="line"><span class="comment">//void foo()noexcept(true); 表示不会抛出异常</span></span><br></pre></td></tr></table></figure></li>
</ul>
<span id="more"></span>

<h1 id="Type-ALias"><a href="#Type-ALias" class="headerlink" title="Type ALias"></a>Type ALias</h1><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//**************************//</span></span><br><span class="line"><span class="comment">//type alias,identical to</span></span><br><span class="line"><span class="comment">//typedef void(*func)(int,int);</span></span><br><span class="line"><span class="keyword">using</span> func=<span class="built_in">void</span>(*)(<span class="type">int</span>,<span class="type">int</span>);</span><br><span class="line"><span class="comment">//func 表示一个入参为(int,int)类型的函数指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">example</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span>&#123;&#125;</span><br><span class="line">func fn=example;</span><br><span class="line">typdef basic_string&lt;<span class="type">char</span>&gt; string;</span><br><span class="line"></span><br><span class="line"><span class="comment">//**************************//</span></span><br><span class="line"><span class="comment">//局部的typedef</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Container</span>&#123;</span><br><span class="line">    <span class="keyword">using</span> value_type=T;<span class="comment">//typedef T value_type</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//并且可以应用到原编程,如果上述定义了value_type</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Cntr&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn2</span><span class="params">(<span class="type">const</span> Cntr&amp; c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">typename</span> Cntr::value_type n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//**************************//</span></span><br><span class="line"><span class="comment">//用于隐藏模板参数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">CharT</span>&gt; <span class="keyword">using</span> mystring=std::basic_string&lt;CharT,std::char_traits&lt;Chart&gt;&gt;</span><br><span class="line">mystring&lt;<span class="type">char</span>&gt; str;</span><br></pre></td></tr></table></figure>
<h2 id="using-用法总结"><a href="#using-用法总结" class="headerlink" title="using 用法总结"></a>using 用法总结</h2><ul>
<li>using-directives<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//单独打开某个函数</span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br></pre></td></tr></table></figure></li>
<li>using-declareations<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 制定函数类型是某个命名空间下的类型</span></span><br><span class="line"><span class="keyword">using</span> _Base::_M_allocate</span><br></pre></td></tr></table></figure></li>
<li>type alias<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//type alias and alias template</span></span><br><span class="line"><span class="keyword">using</span> func=<span class="built_in">void</span>(*)(<span class="type">int</span>,<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Container</span>&#123;</span><br><span class="line">    <span class="keyword">using</span> value_type=T;<span class="comment">//typedef T value_type</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">CharT</span>&gt; <span class="keyword">using</span> mystring=std::basic_string&lt;CharT,std::char_traits&lt;Chart&gt;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="noexcept"><a href="#noexcept" class="headerlink" title="noexcept"></a>noexcept</h1><p><strong>表示函数不抛出异常</strong><br>当异常都没有被捕获时,会调用std::terminate()中的std::abort()方法</p>
<h2 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//表示x.swap(y)不抛异常就不会抛出异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Type&amp; x,Type&amp; y)</span> <span class="title">noexcept</span><span class="params">(nonexcept(x.swap(y)))</span></span>&#123;</span><br><span class="line">    x.<span class="built_in">swap</span>(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>当使用growable container(会发生 memory reallocation)之后两种</p>
<ul>
<li>vector</li>
<li>deque<br>如果类定义了移动构造，并且希望被grow 类型的容器调用需要在移动构造时使用noexcept<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mystring</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">char</span>* _data;</span><br><span class="line">        <span class="type">size_t</span> _len;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Mystring</span>(Mystring&amp;&amp; str)<span class="keyword">noexcept</span>:</span><br><span class="line">            :_data(str._data),_len(str.len)&#123;&#125;</span><br><span class="line"></span><br><span class="line">        Mystring&amp; <span class="keyword">operator</span>=(MyString&amp;&amp; str)<span class="keyword">noexcept</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="override"><a href="#override" class="headerlink" title="override"></a>override</h1><p><strong>用于让编译器帮忙检验当前函数是否是复写父类函数</strong></p>
<h2 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfunc</span><span class="params">(<span class="type">float</span>)</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dervied1</span>:Base&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfunc</span><span class="params">(<span class="type">int</span>)</span></span>&#123;&#125;<span class="comment">//本来想override,但是写错了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//改进</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dervied1</span>:Base&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfunc</span><span class="params">(<span class="type">int</span>)</span><span class="keyword">override</span></span>&#123;&#125;<span class="comment">//没有相同的函数,写错了报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p><strong>不允许复写</strong></p>
<h2 id="code-3"><a href="#code-3" class="headerlink" title="code"></a>code</h2><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base1</span> <span class="keyword">final</span>&#123;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived1</span>:Base1&#123;&#125;; <span class="comment">//报错,不可以被继承</span></span><br></pre></td></tr></table></figure>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base2</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">final</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived2</span>:Base2&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;<span class="comment">// 报错,不可以被复写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
        <category>cpp</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>type Alias</tag>
        <tag>using</tag>
        <tag>nonexcep</tag>
        <tag>override</tag>
        <tag>final</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp 11&amp;14 可变参数模板与空指针,auto</title>
    <url>/2022/03/20/cpp-11-14-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF%E4%B8%8E%E7%A9%BA%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<!-- <blockquote class="blockquote-center">this is note</blockquote> -->
<ul>
<li><p>Variadic Templates(可变参数模板)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可变参数模板</span></span><br><span class="line"><span class="comment">// 无参数函数，用于结束调用 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printX</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 包含一个参数固定参数的可变模板函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... types&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printX</span><span class="params">(<span class="type">const</span> T&amp; firstArg,<span class="type">const</span> Types&amp;... args)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt; firstArg&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">printX</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>空指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;&#125;<span class="comment">//function1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">void</span>* a)</span></span>&#123;&#125;<span class="comment">//funtion2</span></span><br><span class="line"><span class="built_in">f</span>(<span class="literal">NULL</span>);<span class="comment">//call function1 </span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">0</span>);<span class="comment">//call function1 </span></span><br><span class="line"><span class="built_in">f</span>(<span class="literal">nullptr</span>);<span class="comment">//call function2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>模板函数书写变化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;<span class="comment">//</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="comment">//Ok since c++11</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1 id="cpp-11-amp-14-可变参数模板与空指针-auto"><a href="#cpp-11-amp-14-可变参数模板与空指针-auto" class="headerlink" title="cpp 11&amp;14 可变参数模板与空指针,auto"></a>cpp 11&amp;14 可变参数模板与空指针,auto</h1></li>
</ul>
<h2 id="Variadic-Templates-可变参数模板"><a href="#Variadic-Templates-可变参数模板" class="headerlink" title="Variadic Templates(可变参数模板)"></a>Variadic Templates(可变参数模板)</h2><h3 id="帮助我们实现递归"><a href="#帮助我们实现递归" class="headerlink" title="帮助我们实现递归"></a><strong>帮助我们实现递归</strong></h3><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可变参数模板</span></span><br><span class="line"><span class="comment">// 无参数函数，用于结束调用 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printX</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 包含一个参数固定参数的可变模板函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... types&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// type2 和 type 3 可以并存 2为特</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// type2 接收1个和各式各样的入参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printX</span><span class="params">(<span class="type">const</span> T&amp; firstArg,<span class="type">const</span> Types&amp;... args)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt; firstArg&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt; <span class="keyword">sizeof</span>...(args...)&lt;&lt;endl;<span class="comment">// 可以使用sizeof...(args) 获取args的个数</span></span><br><span class="line">    <span class="built_in">printX</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// type3 接收各式各样的入参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printX</span><span class="params">(<span class="type">const</span> Types&amp;... args)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt; firstArg&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt; <span class="keyword">sizeof</span>...(args...)&lt;&lt;endl;<span class="comment">// 可以使用sizeof...(args) 获取args的个数</span></span><br><span class="line">    <span class="built_in">printX</span>(args...);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="cpp库函数举例"><a href="#cpp库函数举例" class="headerlink" title="cpp库函数举例"></a>cpp库函数举例</h4><h5 id="calculate-Hash"><a href="#calculate-Hash" class="headerlink" title="calculate Hash"></a>calculate Hash</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// another file</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">hash_combine</span><span class="params">(<span class="type">size_t</span>&amp; seed,<span class="type">const</span> T&amp; val)</span></span>&#123;</span><br><span class="line">    seed^=std::<span class="built_in">hash</span>&lt;T&gt;()(val)+<span class="number">0x9e3779b9</span>+(seed&lt;&lt;<span class="number">6</span>)+(seed&gt;&gt;<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// call sequence 1-&gt;2-&gt;recurse-&gt;3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// function 1</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>.. Type&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">hash_val</span><span class="params">(<span class="type">size_t</span>&amp; seed, <span class="type">const</span> T&amp; val,<span class="type">const</span> Types&amp;... args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">hash_combine</span>(seed,val);</span><br><span class="line">    <span class="built_in">hash_val</span>(seed,args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// function 2</span></span><br><span class="line"><span class="comment">// auxiliary generic function</span></span><br><span class="line"><span class="keyword">template</span> &lt;typeame... Types&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">size_t</span> <span class="title">hash_val</span><span class="params">(<span class="type">const</span> Types&amp;... args)</span></span>&#123;</span><br><span class="line">    <span class="type">size_t</span> seed=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">hash_val</span>(seed,args);</span><br><span class="line">    <span class="keyword">return</span> seed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function 3</span></span><br><span class="line"><span class="comment">// auxiliary generic function</span></span><br><span class="line"><span class="keyword">template</span> &lt;typeame T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">size_t</span> <span class="title">hash_val</span><span class="params">(<span class="type">size_t</span>&amp; seed,<span class="type">const</span> T&amp; val)</span></span>&#123;</span><br><span class="line">    <span class="built_in">hash_combine</span>(seed,val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="tuple-realise"><a href="#tuple-realise" class="headerlink" title="tuple realise"></a>tuple realise</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Values&gt;<span class="keyword">class</span> <span class="title class_">tuple</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;<span class="keyword">class</span> <span class="title class_">tuple</span>&lt;&gt;&#123;&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head,<span class="keyword">typename</span>... Tail&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tuple</span>&lt;Head,Tail...&gt;:<span class="keyword">private</span> typle&lt;Tail...&gt;&#123;</span><br><span class="line">    <span class="keyword">typedef</span> typle&lt;Tail...&gt; inherited;</span><br><span class="line"> </span><br><span class="line">pubic:</span><br><span class="line">    <span class="built_in">tuple</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">tuple</span>(Head v,Tail... vtail):<span class="built_in">m_head</span>(v),<span class="built_in">inherited</span>(vtail...)&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">typename</span> Head::type <span class="title">head</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_head;&#125;</span><br><span class="line"><span class="function">inherited&amp; <span class="title">tail</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">Head m_head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="tuple-sample"><a href="#tuple-sample" class="headerlink" title="tuple sample"></a>tuple sample</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">tuple&lt;<span class="type">int</span>,<span class="type">float</span>,string&gt; <span class="title">t</span><span class="params">(<span class="number">41</span>,<span class="number">6.3</span>,<span class="string">&quot;nico&quot;</span>)</span></span>;</span><br><span class="line">t.<span class="built_in">head</span>();<span class="comment">//-&gt;4.1</span></span><br><span class="line">t.<span class="built_in">tail</span>().<span class="built_in">head</span>()<span class="comment">//-&gt;6.3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="nullptr-空指针"><a href="#nullptr-空指针" class="headerlink" title="nullptr(空指针)"></a>nullptr(空指针)</h2><h3 id="用于区分空指针与NULL"><a href="#用于区分空指针与NULL" class="headerlink" title="用于区分空指针与NULL"></a><strong>用于区分空指针与NULL</strong></h3><h3 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;&#125;<span class="comment">//function1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">void</span>* a)</span></span>&#123;&#125;<span class="comment">//funtion2</span></span><br><span class="line"><span class="built_in">f</span>(<span class="literal">NULL</span>);<span class="comment">//call function1 </span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">0</span>);<span class="comment">//call function1 </span></span><br><span class="line"><span class="built_in">f</span>(<span class="literal">nullptr</span>);<span class="comment">//call function2</span></span><br></pre></td></tr></table></figure>
<p><strong>file_name</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> <span class="keyword">define</span>(__cplusplus)&amp;&amp; __cplusplus&gt;=201103L</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _GXX_NULLPTR_T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GXX_NULLPTR_T</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(<span class="literal">nullptr</span>)</span> <span class="type">nullptr_t</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// ...</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="keyword">endif</span></span></span></span><br></pre></td></tr></table></figure>

<h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><h3 id="在类型繁琐以及无法确定返回参数类型时使用-lambda-function"><a href="#在类型繁琐以及无法确定返回参数类型时使用-lambda-function" class="headerlink" title="在类型繁琐以及无法确定返回参数类型时使用(lambda function)"></a><strong>在类型繁琐以及无法确定返回参数类型时使用(lambda function)</strong></h3><h3 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;string&gt; v;</span><br><span class="line"><span class="keyword">auto</span> pos=v.<span class="built_in">begin</span>();<span class="comment">// 类型写起来繁琐</span></span><br><span class="line"><span class="keyword">auto</span> i=[](<span class="type">int</span> x)-&gt;<span class="type">bool</span>&#123; <span class="comment">// lambda</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
        <category>cpp</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>cpp11&amp;14</tag>
        <tag>可变参数模板</tag>
        <tag>nullptr</tag>
        <tag>auto</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp 11&amp;14 统一初始化方式以及initializer_list,for</title>
    <url>/2022/04/13/cpp-11-14-%E7%BB%9F%E4%B8%80%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F%E4%BB%A5%E5%8F%8Ainitializer-list/</url>
    <content><![CDATA[<!-- <blockquote class="blockquote-center">this is note</blockquote> -->
<ul>
<li>一致初始化<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> values[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">vector&lt;string&gt; cities&#123;</span><br><span class="line">    <span class="string">&quot;Berlin&quot;</span>,<span class="string">&quot;New York&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">complex&lt;<span class="type">double</span>&gt; c&#123;<span class="number">3.0</span>,<span class="number">4.0</span>&#125;</span><br></pre></td></tr></table></figure></li>
<li>initializer_list<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//***********************//</span></span><br><span class="line"><span class="comment">//initializer_list 传递的是引用,拷贝是浅拷贝</span></span><br><span class="line"><span class="comment">//***********************//</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;<span class="comment">// 会被编译器构造成一个initializer_list</span></span><br><span class="line"><span class="comment">//如果函数只接收initializer_list 则调用者要自己准备一包initializer_list,来使用</span></span><br><span class="line"><span class="comment">//如果目标函数不接受initializer_list，会被编译器分开来传入</span></span><br><span class="line"><span class="type">int</span> i;<span class="comment">//i的值是未定义</span></span><br><span class="line"><span class="type">int</span> j&#123;&#125;;<span class="comment">//设置初值为0</span></span><br><span class="line"><span class="type">int</span>* p;<span class="comment">//未定义初值</span></span><br><span class="line"><span class="type">int</span>* q&#123;&#125;;<span class="comment">//设置初值为nullptr</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">x1</span><span class="params">(<span class="number">5.3</span>)</span></span>; <span class="comment">// x1=5</span></span><br><span class="line"><span class="type">int</span> x2 = <span class="number">5.3</span>;<span class="comment">//x2=5</span></span><br><span class="line"><span class="type">int</span> x3&#123;<span class="number">5.0</span>&#125;;<span class="comment">//Error:narrowing ||-&gt; GCC Warning</span></span><br><span class="line"><span class="type">int</span> x4 =&#123;<span class="number">5.3</span>&#125;; <span class="comment">// Error:narrowing ||-&gt; GCC Warning</span></span><br><span class="line"><span class="type">char</span> c1&#123;<span class="number">7</span>&#125;;<span class="comment">//ok</span></span><br><span class="line"><span class="type">char</span> c2&#123;<span class="number">99999</span>&#125;;<span class="comment">//Error:narrowing ||-&gt; GCC Warning</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v1&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;<span class="comment">//ok</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v1&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5.5</span>&#125;;<span class="comment">//Error:narrowing ||-&gt; GCC Warning</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">max</span>(&#123;<span class="built_in">stirng</span>(<span class="string">&quot;Ace&quot;</span>),<span class="built_in">string</span>(<span class="string">&quot;Stacy&quot;</span>),<span class="built_in">stirng</span>(<span class="string">&quot;qqq&quot;</span>),<span class="built_in">string</span>(<span class="string">&quot;ppp&quot;</span>)&#125;) <span class="comment">//函数可以接收initializer_list，作为入参</span></span><br><span class="line"><span class="built_in">min</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;)<span class="comment">//函数可以接收initializer_list，作为入参</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1 id="cpp-11-amp-14-统一初始化方式以及initializer-list"><a href="#cpp-11-amp-14-统一初始化方式以及initializer-list" class="headerlink" title="cpp 11&amp;14 统一初始化方式以及initializer_list"></a>cpp 11&amp;14 统一初始化方式以及initializer_list</h1><h2 id="一致初始化"><a href="#一致初始化" class="headerlink" title="一致初始化"></a>一致初始化</h2><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> values[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">vector&lt;string&gt; cities&#123;</span><br><span class="line">    <span class="string">&quot;Berlin&quot;</span>,<span class="string">&quot;New York&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">complex&lt;<span class="type">double</span>&gt; c&#123;<span class="number">3.0</span>,<span class="number">4.0</span>&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="initializer-list"><a href="#initializer-list" class="headerlink" title="initializer_list"></a>initializer_list</h2><h3 id="接受任意个参数，但类型要相同"><a href="#接受任意个参数，但类型要相同" class="headerlink" title="接受任意个参数，但类型要相同"></a><strong>接受任意个参数，但类型要相同</strong></h3><h3 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//***********************//</span></span><br><span class="line"><span class="comment">//initializer_list 传递的是引用,拷贝是浅拷贝</span></span><br><span class="line"><span class="comment">//***********************//</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i;<span class="comment">//i的值是未定义</span></span><br><span class="line"><span class="type">int</span> j&#123;&#125;;<span class="comment">//设置初值为0</span></span><br><span class="line"><span class="type">int</span>* p;<span class="comment">//未定义初值</span></span><br><span class="line"><span class="type">int</span>* q&#123;&#125;;<span class="comment">//设置初值为nullptr</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">x1</span><span class="params">(<span class="number">5.3</span>)</span></span>; <span class="comment">// x1=5</span></span><br><span class="line"><span class="type">int</span> x2 = <span class="number">5.3</span>;<span class="comment">//x2=5</span></span><br><span class="line"><span class="type">int</span> x3&#123;<span class="number">5.0</span>&#125;;<span class="comment">//Error:narrowing ||-&gt; GCC Warning</span></span><br><span class="line"><span class="type">int</span> x4 =&#123;<span class="number">5.3</span>&#125;; <span class="comment">// Error:narrowing ||-&gt; GCC Warning</span></span><br><span class="line"><span class="type">char</span> c1&#123;<span class="number">7</span>&#125;;<span class="comment">//ok</span></span><br><span class="line"><span class="type">char</span> c2&#123;<span class="number">99999</span>&#125;;<span class="comment">//Error:narrowing ||-&gt; GCC Warning</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v1&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;<span class="comment">//ok</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v1&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5.5</span>&#125;;<span class="comment">//Error:narrowing ||-&gt; GCC Warning</span></span><br></pre></td></tr></table></figure>
<h4 id="sample-正确"><a href="#sample-正确" class="headerlink" title="sample 正确"></a>sample 正确</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">P</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">P</span>(<span class="type">int</span> a,<span class="type">int</span> b)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;P(int,int),a=&quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; b=&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">P</span>(initializer_list&lt;<span class="type">int</span>&gt; initlist)&#123;</span><br><span class="line">         cout&lt;&lt;<span class="string">&quot;P(initializer_list&lt;int&gt;),values=&quot;</span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">auto</span> i:initializer_list)&#123;</span><br><span class="line">             cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">         cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">P <span class="title">p</span><span class="params">(<span class="number">77</span>,<span class="number">5</span>)</span></span>;<span class="comment">//P(int,int);</span></span><br><span class="line">P q&#123;<span class="number">77</span>,<span class="number">4</span>&#125;;<span class="comment">//P(initializer_list&lt;int&gt;); 形成一包,所以调用的是P(initializer_list&lt;int&gt;)</span></span><br><span class="line">P r&#123;<span class="number">77</span>,<span class="number">5</span>,<span class="number">42</span>&#125;;<span class="comment">//P(initializer_list&lt;int&gt;);</span></span><br><span class="line">P s=&#123;<span class="number">77</span>,<span class="number">5</span>&#125;;<span class="comment">//P(initializer_list&lt;int&gt;);</span></span><br></pre></td></tr></table></figure>

<h4 id="sample-错误"><a href="#sample-错误" class="headerlink" title="sample 错误"></a>sample 错误</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">P</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">P</span>(<span class="type">int</span> a,<span class="type">int</span> b)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;P(int,int),a=&quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; b=&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">P <span class="title">p</span><span class="params">(<span class="number">77</span>,<span class="number">5</span>)</span></span>;<span class="comment">//P(int,int);</span></span><br><span class="line">P q&#123;<span class="number">77</span>,<span class="number">4</span>&#125;;<span class="comment">//P(int,int);</span></span><br><span class="line">P r&#123;<span class="number">77</span>,<span class="number">5</span>,<span class="number">42</span>&#125;;<span class="comment">//Error</span></span><br><span class="line">P s=&#123;<span class="number">77</span>,<span class="number">5</span>&#125;;<span class="comment">//P(initializer_list&lt;int&gt;);</span></span><br></pre></td></tr></table></figure>
<h4 id="explicit-当构造函数含有多个入参时"><a href="#explicit-当构造函数含有多个入参时" class="headerlink" title="explicit 当构造函数含有多个入参时"></a>explicit 当构造函数含有多个入参时</h4><h5 id="explicit-应用在只有一个参数在构造函数时"><a href="#explicit-应用在只有一个参数在构造函数时" class="headerlink" title="explicit 应用在只有一个参数在构造函数时"></a>explicit 应用在只有一个参数在构造函数时</h5><h6 id="old-version"><a href="#old-version" class="headerlink" title="old version"></a>old version</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//*******************************</span></span><br><span class="line"><span class="comment">// 隐含调用含有一个参数的构造函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Complex</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> real,imag;</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">int</span> re,<span class="type">int</span> im=<span class="number">0</span>):<span class="built_in">real</span>(re),<span class="built_in">imag</span>(im)&#123;&#125;</span><br><span class="line">    Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>((real+x.real),(imag+x.imag))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Complex <span class="built_in">c1</span>(<span class="number">12</span>,<span class="number">5</span>);</span><br><span class="line">Complex c2=c1+<span class="number">5</span>;<span class="comment">// 隐含调用含有一个参数的构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//***************************</span></span><br><span class="line"><span class="comment">//禁止隐含调用构造，除非明确指出</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Complex</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> real,imag;</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">int</span> re,<span class="type">int</span> im=<span class="number">0</span>):<span class="built_in">real</span>(re),<span class="built_in">imag</span>(im)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">explicit</span></span><br><span class="line">    Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>((real+x.real),(imag+x.imag))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Complex <span class="built_in">c1</span>(<span class="number">12</span>,<span class="number">5</span>);</span><br><span class="line"><span class="comment">//禁止隐含调用构造，除非明确指出</span></span><br><span class="line">Complex c2=c1+<span class="number">5</span>;<span class="comment">// Erorr no match for &#x27;operator+&#x27;</span></span><br></pre></td></tr></table></figure>
<h6 id="c11-version"><a href="#c11-version" class="headerlink" title="c11 version"></a>c11 version</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">P</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">P</span>(<span class="type">int</span> a,<span class="type">int</span> b)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;P(int,int),a=&quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; b=&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">P</span>(initializer_list&lt;<span class="type">int</span>&gt; initlist)&#123;</span><br><span class="line">         cout&lt;&lt;<span class="string">&quot;P(initializer_list&lt;int&gt;),values=&quot;</span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">auto</span> i:initializer_list)&#123;</span><br><span class="line">             cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">         cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> </span></span><br><span class="line"><span class="function">    <span class="title">P</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;P(int,int),a=&quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; b=&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fp</span><span class="params">(<span class="type">const</span> P&amp;)</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">P <span class="title">p</span><span class="params">(<span class="number">77</span>,<span class="number">5</span>)</span></span>;<span class="comment">//P(int,int);</span></span><br><span class="line">P q&#123;<span class="number">77</span>,<span class="number">4</span>&#125;;<span class="comment">//P(initializer_list&lt;int&gt;); 形成一包,所以调用的是P(initializer_list&lt;int&gt;)</span></span><br><span class="line">P r&#123;<span class="number">77</span>,<span class="number">5</span>,<span class="number">42</span>&#125;;<span class="comment">//P(initializer_list&lt;int&gt;);</span></span><br><span class="line">P s=&#123;<span class="number">77</span>,<span class="number">5</span>&#125;;<span class="comment">//P(initializer_list&lt;int&gt;);</span></span><br><span class="line"><span class="comment">//Error ****************//</span></span><br><span class="line">P p5 = &#123;<span class="number">77</span>,<span class="number">88</span>,<span class="number">3</span>&#125;<span class="comment">//Error converting to &#x27;p&#x27; from initilizer list would use explicit constructor</span></span><br><span class="line"><span class="comment">//Error ****************//</span></span><br><span class="line">P p6 = &#123;<span class="number">77</span>,<span class="number">88</span>,<span class="number">3</span>,<span class="number">8</span>&#125;<span class="comment">//P(initializer_list&lt;int&gt;);</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">fp</span>(&#123;<span class="number">11</span>,<span class="number">22</span>&#125;)<span class="comment">//P(initializer_list&lt;int&gt;)</span></span><br><span class="line"><span class="comment">//Error ****************//</span></span><br><span class="line"><span class="built_in">fp</span>(&#123;<span class="number">47</span>,<span class="number">11</span>,<span class="number">3</span>&#125;)<span class="comment">//Error converting to &#x27;const p&#x27; from initilizer list would use explicit constructor</span></span><br><span class="line"><span class="comment">//Error ****************//</span></span><br><span class="line"><span class="built_in">fp</span>(P&#123;<span class="number">47</span>,<span class="number">11</span>&#125;)<span class="comment">//P(initializer_list&lt;int&gt;)</span></span><br><span class="line"><span class="built_in">fp</span>(P&#123;<span class="number">26</span>,<span class="number">11</span>,<span class="number">3</span>&#125;) <span class="comment">//P(initializer_list&lt;int&gt;)</span></span><br></pre></td></tr></table></figure>
<h4 id="技术实现细节"><a href="#技术实现细节" class="headerlink" title="技术实现细节"></a>技术实现细节</h4><h5 id="array-容器的TR1-版本"><a href="#array-容器的TR1-版本" class="headerlink" title="array 容器的TR1(版本)"></a>array 容器的TR1(版本)</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp,std::<span class="type">size_t</span> _Nm&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">array</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp value_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> value_type* iterator;</span><br><span class="line">    <span class="comment">//Support for zero-sized arrays mandatory;</span></span><br><span class="line">    value_type _M_instance[_Nm?_Nm:<span class="number">1</span>];</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">iterator</span>(&amp;_M_instance[<span class="number">0</span>]);&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">iterator</span>(&amp;_M_instance[_Nm]);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">array&lt;<span class="type">int</span>,10&gt; myArray;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="initializer-list的实现"><a href="#initializer-list的实现" class="headerlink" title="initializer_list的实现"></a>initializer_list的实现</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// std::initializer_list support -*- C++ -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Copyright (C) 2008-2022 Free Software Foundation, Inc.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This file is part of GCC.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// gcc/libstdc++-v3/libsupc++/initializer_list</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _INITIALIZER_LIST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _INITIALIZER_LIST</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC system_header</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __cplusplus &lt; 201103L</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;bits/c++0x_warning.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">// C++0x</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC visibility push(default)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/c++config.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/// initializer_list</span></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_E</span>&gt;</span><br><span class="line">    <span class="keyword">class</span> ##### <span class="built_in">TR1</span>(版本)</span><br><span class="line">```cpp</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp,std::<span class="type">size_t</span> _Nm&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">array</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp value_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> value_type* iterator;</span><br><span class="line">    <span class="comment">//Support for zero-sized arrays mandatory;</span></span><br><span class="line">    value_type _M_instance[_Nm?_Nm:<span class="number">1</span>];</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">iterator</span>(&amp;_M_instance[<span class="number">0</span>]);&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">iterator</span>(&amp;_M_instance[_Nm]);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">array&lt;<span class="type">int</span>,10&gt; myArray;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> _E 		value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">const</span> _E&amp; 	reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">const</span> _E&amp; 	const_reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">size_t</span> 		size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">const</span> _E* 	iterator;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">const</span> _E* 	const_iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">//**********************************************//</span></span><br><span class="line"><span class="comment">// 实现是依靠array 容器</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  iterator			_M_array;</span><br><span class="line">  size_type			_M_len;</span><br><span class="line"><span class="comment">//**********************************************//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//**********************************************//</span></span><br><span class="line"><span class="comment">// The compiler can call a private constructor.</span></span><br><span class="line"><span class="comment">// 当编译器看到&#123;&#125;时会调用下面的的构造，在调用initializer_list构造函数之前</span></span><br><span class="line"><span class="comment">// 编译器会先创建一个array容器，后会将array的容器的迭代器和长度，传入initializer_list 构造函数</span></span><br><span class="line"><span class="comment">//**********************************************//</span></span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="title">initializer_list</span><span class="params">(const_iterator __a, size_type __l)</span></span></span><br><span class="line"><span class="function">  : _M_array(__a), _M_len(__l) &#123;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="title">initializer_list</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  : _M_array(<span class="number">0</span>), _M_len(<span class="number">0</span>) &#123;</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Number of elements.</span></span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> size_type</span></span><br><span class="line"><span class="function">  <span class="title">size</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> _M_len; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// First element.</span></span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> const_iterator</span></span><br><span class="line"><span class="function">  <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> _M_array; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// One past the last element.</span></span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> const_iterator</span></span><br><span class="line"><span class="function">  <span class="title">end</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">begin</span>() + <span class="built_in">size</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="for-新的写法"><a href="#for-新的写法" class="headerlink" title="for 新的写法"></a>for 新的写法</h2><h3 id="使用引用可以使遍历更加快速-同时可以修改变量的值"><a href="#使用引用可以使遍历更加快速-同时可以修改变量的值" class="headerlink" title="使用引用可以使遍历更加快速,同时可以修改变量的值"></a><strong>使用引用可以使遍历更加快速,同时可以修改变量的值</strong></h3><h3 id="关联式容器不可以修改值"><a href="#关联式容器不可以修改值" class="headerlink" title="关联式容器不可以修改值"></a><strong>关联式容器不可以修改值</strong></h3><ul>
<li>set</li>
<li>map</li>
<li>unorder_set</li>
<li>unorder_map</li>
<li>multiset</li>
<li>multimap</li>
</ul>
<h3 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">vector&lt;<span class="type">double</span>&gt; vec;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> s:vec)&#123;</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 赋值速度更快，同时可以修改其中的值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; s:vec)&#123;</span><br><span class="line"></span><br><span class="line">    s*=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; s:vec)&#123;</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">double</span>&gt; vec;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> s:vec)&#123;</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> _pos=coll.<span class="built_in">begin</span>(),_end=<span class="built_in">end</span>(doll);_pos!=_end;++_pos)&#123;</span><br><span class="line">    decl=*_pos;</span><br><span class="line">    <span class="comment">//statement(cout&lt;&lt;s&lt;&lt;endl;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="转型实现"><a href="#转型实现" class="headerlink" title="转型实现"></a>转型实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">C</span><span class="params">(<span class="type">const</span> stirng&amp; s)</span></span>; <span class="comment">//禁止自动转换</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; vs;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> C&amp; elem:vs)&#123; <span class="comment">// Error,no conoversion from string to C defined</span></span><br><span class="line">    <span class="comment">// 类型不同时，会进行默认的类型转换</span></span><br><span class="line">    cout&lt;&lt;elem&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
        <category>cpp</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>cpp11&amp;14</tag>
        <tag>一致初始化</tag>
        <tag>initializer_list</tag>
        <tag>array容器</tag>
        <tag>explicit</tag>
        <tag>for 特殊的写法</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp tips</title>
    <url>/2022/04/20/cpp-tips/</url>
    <content><![CDATA[<!-- <blockquote class="blockquote-center">this is note</blockquote> -->
<span id="more"></span>
<h1 id="string-14-amp-17"><a href="#string-14-amp-17" class="headerlink" title="string 14&amp;17"></a>string 14&amp;17</h1><ul>
<li>cpp 使用s和sv可以使字符串包含\0而不被阶段<ul>
<li>需要使用命名空间std::string_literals;<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在cpp 11后不被允许，将一个字符串常量赋值给一个char*</span></span><br><span class="line"><span class="type">char</span>* s=<span class="string">&quot;ssss&quot;</span>;<span class="comment">//Error</span></span><br><span class="line"><span class="type">char</span> cc=<span class="string">&quot;sssss&quot;</span>[<span class="number">0</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* =<span class="string">&quot;sss&quot;</span>;</span><br><span class="line">std::string_literals;</span><br><span class="line">std::string p=<span class="string">&quot;sss&quot;</span>s;<span class="comment">//字符串常量值,是一个string的类</span></span><br><span class="line">std::string_view q=<span class="string">&quot;qqqq&quot;</span>sv;<span class="comment">//字符串可以修改 是string_view</span></span><br><span class="line">std::string tt = <span class="string">&quot;sss&quot;</span>; <span class="comment">//右侧是 常量字符串，可以赋值是因为背后是char *</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="auto-int-amp-register-int"><a href="#auto-int-amp-register-int" class="headerlink" title="auto int&amp; register int"></a>auto int&amp; register int</h1><ul>
<li>auto int 表示将变量存储到内存中</li>
<li>register int 表示将变量存储到 寄存器中<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">register</span> <span class="type">int</span> b;</span><br><span class="line"><span class="comment">//由于寄存器没有地址，所以这样使用b 会被编译器放到内存中</span></span><br><span class="line"><span class="type">int</span> c = &amp;b;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="extern-amp-static-amp-inline"><a href="#extern-amp-static-amp-inline" class="headerlink" title="extern&amp;static&amp;inline"></a>extern&amp;static&amp;inline</h1><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> x,y;<span class="comment">//模块作用域，仅在当前文件内可以访问到，初始值为0</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> y; <span class="comment">//局部静态变量，初始值为0</span></span><br><span class="line">  <span class="keyword">return</span> ::y+x+y;<span class="comment">//分别访问模块静态变量y,模块静态变量x,局部静态变量y;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h4 id="访问外部模块变量"><a href="#访问外部模块变量" class="headerlink" title="访问外部模块变量"></a>访问外部模块变量</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">extern</span> <span class="type">int</span> x;</span><br><span class="line">  <span class="type">int</span> y=x;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//A.cpp</span></span><br><span class="line"><span class="type">int</span> x=<span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="访问外部模块变量-1"><a href="#访问外部模块变量-1" class="headerlink" title="访问外部模块变量"></a>访问外部模块变量</h4><ul>
<li><p>extern</p>
<p>访问外部变量，既main()外部定义的变量，可以使全局变量也可以是模块变量</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> x=<span class="number">4</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">extern</span> <span class="type">int</span> x; <span class="comment">//就近原则 x=3 是全局的，static int x=4 访问本模块的</span></span><br><span class="line">  <span class="type">int</span> y=x;<span class="comment">//x=4</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//A.cpp</span></span><br><span class="line"><span class="type">int</span> x=<span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<hr>
<h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> x=<span class="number">4</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> x=<span class="number">5</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> x; </span><br><span class="line">    <span class="type">int</span> y=x;<span class="comment">//x=4</span></span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//A.cpp</span></span><br><span class="line"><span class="type">int</span> x=<span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<h4 id="const-amp-volatile-amp-constexptr-amp-inline"><a href="#const-amp-volatile-amp-constexptr-amp-inline" class="headerlink" title="const&amp;volatile&amp;constexptr&amp;inline"></a>const&amp;volatile&amp;constexptr&amp;inline</h4><ul>
<li><p>const </p>
<ul>
<li><p>const 修饰变量</p>
<ul>
<li>本程序不修改,需要在定义时初始化</li>
</ul>
</li>
<li><p>const 修饰函数（一定是成员函数）,是否含有const 可以区分不同的重载</p>
<table>
<thead>
<tr>
<th></th>
<th>const object</th>
<th>non-const object</th>
</tr>
</thead>
<tbody><tr>
<td>const member function (保证数据成员不变)</td>
<td>可以</td>
<td>可以</td>
</tr>
<tr>
<td>non-const member functions  (不保证数据成员不变)</td>
<td>不可以</td>
<td>可以</td>
</tr>
</tbody></table>
<ul>
<li>const 修饰的函数，会被const 对象调用，当一个函数只有const版本，只可以被const对象调用</li>
</ul>
</li>
</ul>
</li>
<li><p>volatile</p>
<ul>
<li>本程序不修改，其他程序修改</li>
<li>编译器不会优化，因为值时刻在变化。</li>
</ul>
</li>
<li><p>constexptr</p>
<ul>
<li>将计算尽量放在编译阶段</li>
<li>初始化要用常量表达式初始化</li>
<li>常量表达式的计算是在编译时，才是常量表达式</li>
<li>由于跟踪入参和函数结果，如果使用常量调用,可以提前计算</li>
</ul>
</li>
<li><p>inline</p>
<ul>
<li>inline 作用域就在当前模块，相当于默认加了static</li>
<li>用于优化，可能变量不存在,变为</li>
<li>对于函数，将调用展开</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">volatile</span> <span class="type">int</span> z=<span class="number">3</span>; <span class="comment">//可以的</span></span><br><span class="line"><span class="keyword">constexpr</span> y=z;<span class="comment">//不可以</span></span><br><span class="line"><span class="type">const</span> y=z;<span class="comment">//可以</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> y=<span class="number">5</span>;</span><br><span class="line">y++;<span class="comment">//不可以修改</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> y=<span class="number">3</span>+<span class="built_in">sizeof</span>(<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,x));</span><br><span class="line"><span class="comment">// 由于printf 函数返回时int类型，顾sizeof(int) 为固定值4；所以是常量表达式</span></span><br><span class="line"><span class="comment">//没有输出，因为constexpr 是在编译的时候做的计算</span></span><br><span class="line"><span class="comment">//sizeof不可以重载因为是在编译阶段进行计算</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;  <span class="comment">//不修饰返回值，修饰入参和内容。用于优化</span></span><br><span class="line">  <span class="keyword">return</span> x*x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> y = <span class="built_in">f</span>(<span class="number">3</span>); <span class="comment">// 优化为int y =9;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>constexpr 不表示返回值不可修改</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span>&amp; <span class="title">f</span><span class="params">(<span class="type">int</span>&amp; x)</span></span>&#123;</span><br><span class="line">    x=x*x;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">volatile</span> <span class="type">int</span> z=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">5</span>;</span><br><span class="line">    <span class="built_in">f</span>(x)=<span class="number">9</span>;</span><br><span class="line">    std::cout&lt;&lt;x&lt;&lt;std::endl; <span class="comment">//x=9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h5><h6 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> x=<span class="number">4</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> y=x; <span class="comment">// int y = 4;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//A.cpp</span></span><br><span class="line"><span class="type">int</span> x=<span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li>下列代码显示重复定义<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> x=<span class="number">4</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> y=x;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//A.cpp</span></span><br><span class="line"><span class="type">int</span> x=<span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<hr>
<h6 id="改进-1"><a href="#改进-1" class="headerlink" title="改进 1"></a>改进 1</h6><p>可以正常编译通过</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> x=<span class="number">4</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> y=x;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//A.cpp</span></span><br><span class="line"><span class="type">int</span> x=<span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<h6 id="改进-2"><a href="#改进-2" class="headerlink" title="改进 2"></a>改进 2</h6><p>可以正常编译通过</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> x=<span class="number">4</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> y=x;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//A.cpp</span></span><br><span class="line"><span class="type">int</span> x=<span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<h6 id="改进-3"><a href="#改进-3" class="headerlink" title="改进 3"></a>改进 3</h6><p>可以正常编译通过</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> x=<span class="number">4</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> y=x;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//A.cpp</span></span><br><span class="line"><span class="keyword">inline</span> x=<span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<h5 id="外部函数"><a href="#外部函数" class="headerlink" title="外部函数"></a>外部函数</h5><ul>
<li>编译失败，因为inline 相当于static 外部模块访问不到<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> x=<span class="number">4</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> y=x;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//A.cpp</span></span><br><span class="line"><span class="keyword">inline</span> x=<span class="number">3</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="built_in">f</span>();</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>修正</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> x=<span class="number">4</span>;</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> y=x;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//A.cpp</span></span><br><span class="line"><span class="keyword">inline</span> x=<span class="number">3</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="built_in">f</span>();</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
        <category>cpp</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>string(cpp 14&amp;17)</tag>
        <tag>auto int 与register int</tag>
        <tag>extern</tag>
        <tag>const</tag>
        <tag>constexpr(cpp 11)</tag>
        <tag>violite</tag>
        <tag>static</tag>
        <tag>inline</tag>
        <tag>sizeof</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp 面向对象基础--基础与头文件声明</title>
    <url>/2022/03/19/cpp-%E4%BE%AF%E6%8D%B7Note/</url>
    <content><![CDATA[<!-- HTML方式: 直接在 Markdown 文件中编写 HTML 来调用 -->
<!-- 其中 class="blockquote-center" 是必须的 -->
<!-- <blockquote class="blockquote-center">this is note</blockquote> -->

<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="c与cpp-的区别"><a href="#c与cpp-的区别" class="headerlink" title="c与cpp 的区别"></a>c与cpp 的区别</h3><table>
<thead>
<tr>
<th>语言</th>
<th>c</th>
<th>cpp</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>Object Base(基于对象)</td>
<td>Object Oriented(面向对象)</td>
</tr>
<tr>
<td></td>
<td>面对**单一的class(类)**设计</td>
<td>面对多重classes的设计，着重于<strong>class之间的关系</strong></td>
</tr>
<tr>
<td>头文件的书写区别 注（头文件的后缀名在不同平台可能不同）引用c的头文件要在前面加c</td>
<td>&lt;stdio&gt;</td>
<td>&lt;cstdio&gt; &lt;iostream&gt;</td>
</tr>
</tbody></table>
<span id="more"></span>

<h3 id="防卫式生命"><a href="#防卫式生命" class="headerlink" title="防卫式生命"></a>防卫式生命</h3><p><em>为了解决引用顺序的问题</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __FILENAME__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __FILENAME__</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="头文件布局"><a href="#头文件布局" class="headerlink" title="头文件布局"></a>头文件布局</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __FILENAME__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __FILENAME__</span></span><br><span class="line"><span class="comment">// 前项生命</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类定义</span></span><br><span class="line">complex::<span class="built_in">method</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="class声明-模板类"><a href="#class声明-模板类" class="headerlink" title="class声明(模板类)"></a>class声明(模板类)</h2><ul>
<li>complex.h</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __COMPLEX__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __COMPLEX__</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">complex</span>(T r=<span class="number">0</span>,T i=<span class="number">0</span>):<span class="built_in">re</span>(r),<span class="built_in">im</span>(i)&#123;&#125;</span><br><span class="line">	complex&amp; <span class="keyword">operator</span> +=(<span class="type">const</span> complex&amp;);</span><br><span class="line">	<span class="function">T <span class="title">real</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> re;&#125; <span class="comment">//表示函数不会修改任何东西</span></span><br><span class="line">	<span class="function">T <span class="title">imag</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> im;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T re,im;</span><br><span class="line">	<span class="keyword">friend</span> complex&amp; __doapl(complex*,<span class="type">const</span> complex&amp;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>Complex 类的使用</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">complex&lt;<span class="type">double</span>&gt; <span class="title">complexDouble</span><span class="params">(<span class="number">1.0</span>,<span class="number">2.0</span>)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
        <category>cpp</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>侯捷</tag>
        <tag>头文件</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp 构造与析构（侯捷）</title>
    <url>/2022/03/20/cpp-%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84/</url>
    <content><![CDATA[<ul>
<li><p>inline（内联函数）</p>
<p>  <em>若在函数体内定义完成，变为内联函数的候选人</em><br>  inline 函数运行更快，inline 只是建议，具体是否使用由编译器决定</p>
</li>
<li><p>拷贝构造</p>
</li>
<li><p>拷贝赋值</p>
<p>  包含指针需要单独实现，不可用默认的</p>
</li>
<li><p>虚函数</p>
</li>
<li><p>虚函数表</p>
<span id="more"></span>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2></li>
</ul>
<p>函数重载 :由编译器负责将函数命名唯一化，使用<strong>函数名</strong>和<strong>参数</strong> 有关</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __COMPLEX__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __COMPLEX__</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">complex</span>(T r=<span class="number">0</span>,T i=<span class="number">0</span>):<span class="built_in">re</span>(r),<span class="built_in">im</span>(i)&#123;&#125; <span class="comment">//inline 使用初始化构造列表,优点构造函数运行更快：因为在变量初始化时就进行了赋值</span></span><br><span class="line">    <span class="comment">// (T r=0,T i=0) 默认实参</span></span><br><span class="line">    <span class="built_in">complex</span>():<span class="built_in">re</span>(<span class="number">0</span>),<span class="built_in">im</span>(<span class="number">0</span>)&#123;&#125;<span class="comment">// 与 上面的构造函数冲突，因此这种构造不允许存在</span></span><br><span class="line">	complex&amp; <span class="keyword">operator</span> +=(<span class="type">const</span> complex&amp;);</span><br><span class="line">	<span class="function">T <span class="title">real</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> re;&#125; <span class="comment">//inline</span></span><br><span class="line">	<span class="function">T <span class="title">imag</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> im;&#125;<span class="comment">//inline</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T re,im;</span><br><span class="line">	<span class="keyword">friend</span> complex&amp; __doapl(complex*,<span class="type">const</span> complex&amp;); <span class="comment">//友元 可以直接访问类的私有成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>尽量inline由编译器决定</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">imag</span><span class="params">(<span class="type">const</span> conplex&amp; x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.<span class="built_in">imag</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> complex&amp;</span><br><span class="line">__doapl (complex* ths,<span class="type">const</span> comlex&amp; r)&#123;</span><br><span class="line">    ths-&gt;re +=r.re;</span><br><span class="line">    ths-&gt;im +=r.im;</span><br><span class="line">    <span class="keyword">return</span> *ths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p><strong>同一个class的各个objects互为友元</strong></p>
<h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><h3 id="尽量使用引用传递，入参以及返回值"><a href="#尽量使用引用传递，入参以及返回值" class="headerlink" title="尽量使用引用传递，入参以及返回值"></a>尽量使用引用传递，入参以及返回值</h3><p><em>引用实际上是由编译器使用指针实现</em></p>
<h3 id="返回值不能使用引用，若返回的值在离开函数后不存在"><a href="#返回值不能使用引用，若返回的值在离开函数后不存在" class="headerlink" title="返回值不能使用引用，若返回的值在离开函数后不存在"></a>返回值不能使用引用，若返回的值在离开函数后不存在</h3><p>使用引用的方式<strong>传递着</strong>，无需知道<strong>接受者是以引用</strong>的方式接受的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> complex&amp;</span><br><span class="line">comolex::operayor += (<span class="type">const</span> comlex&amp; r)&#123;</span><br><span class="line">   <span class="keyword">return</span> __doapl(<span class="keyword">this</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c2 +=c1;</span><br><span class="line">c2+=c2+=c1;<span class="comment">// 因为是引用的方式，所以这种写法是可以的。既传递着无需关心接受者的接收方式</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h2><h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">complex c1;</span><br><span class="line">complex c2;</span><br><span class="line">c2+=c1;<span class="comment">//操作符被作用到左侧的这个类型上</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">inline</span> complex&amp;</span><br><span class="line"><span class="comment">//由于这个函数其他地方可能会用到，因此我们需要把它独立出来</span></span><br><span class="line">__doapl (complex* ths,<span class="type">const</span> comlex&amp; r)&#123;<span class="comment">//第二个参数不会改动，因此添加const关键字</span></span><br><span class="line">    ths-&gt;re +=r.re;</span><br><span class="line">    ths-&gt;im +=r.im;</span><br><span class="line">    <span class="keyword">return</span> *ths;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> complex&amp;</span><br><span class="line">comolex::operayor += (<span class="type">const</span> comlex&amp; r)&#123;</span><br><span class="line">   <span class="keyword">return</span> __doapl(<span class="keyword">this</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="非成员函数"><a href="#非成员函数" class="headerlink" title="非成员函数"></a>非成员函数</h3><p><em>临时对象</em><br>特殊操作符要使用全局的操作符重载<br>cout&lt;&lt; conj(c1);<br>cout&lt;&lt; c1&lt;&lt; conj(c1);</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局函数</span></span><br><span class="line"><span class="keyword">inline</span> compelx</span><br><span class="line"><span class="keyword">operator</span> +(<span class="type">const</span> compelx&amp;x,<span class="type">const</span> complex&amp;y)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span>(<span class="built_in">real</span>(x)+<span class="built_in">real</span>(y),<span class="built_in">imag</span>(x)+<span class="built_in">imag</span>(y));<span class="comment">//类型（）创建临时变量。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> compelx</span><br><span class="line"><span class="keyword">operator</span> +(<span class="type">const</span> compelx&amp;x, <span class="type">double</span> y)&#123;</span><br><span class="line">    <span class="built_in">complex</span>(<span class="built_in">real</span>(x)+<span class="built_in">real</span>(y),<span class="built_in">imag</span>(x)+y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> compelx</span><br><span class="line"><span class="keyword">operator</span> +( <span class="type">double</span> x, <span class="type">const</span> complex&amp;y)&#123;</span><br><span class="line">    <span class="built_in">complex</span>(x+<span class="built_in">real</span>(y),<span class="built_in">imag</span>(x)+<span class="built_in">imag</span>(y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> complex <span class="keyword">operator</span> +(<span class="type">const</span> complex&amp;x)&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> complex <span class="keyword">operator</span> -(<span class="type">const</span> complex&amp;x)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span>(-<span class="built_in">real</span>(x),-<span class="built_in">imag</span>(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">operator</span> ==(<span class="type">const</span> comolex&amp; x,<span class="type">const</span> comolex&amp; y)&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">real</span>(x)==<span class="built_in">real</span>(y) &amp;&amp;<span class="built_in">imag</span>(x)==<span class="built_in">imag</span>(y);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">operator</span> ==(<span class="type">const</span> comolex&amp; x,<span class="type">double</span> y)&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">real</span>(x)==y &amp;&amp;<span class="built_in">imag</span>(x)==<span class="number">0</span>;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">operator</span> ==(<span class="type">double</span> x,<span class="type">const</span> comolex&amp; y)&#123;</span><br><span class="line"> <span class="keyword">return</span> x==<span class="built_in">real</span>(y) &amp;&amp;<span class="built_in">imag</span>(x)==<span class="number">0</span>;  </span><br><span class="line">&#125;</span><br><span class="line">ostream &amp;</span><br><span class="line"><span class="keyword">operator</span> &lt;&lt; (ostream&amp; os,<span class="type">const</span> compelx&amp;x)&#123;<span class="comment">//os 不能const，因为每次输出改变os的状态</span></span><br><span class="line">    <span class="keyword">return</span> os&lt;&lt;<span class="string">&quot;&quot;</span>&lt;&lt;<span class="built_in">real</span>(x)&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;<span class="built_in">imag</span>(x)&lt;&lt;<span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="拷贝构造-amp-赋值构造"><a href="#拷贝构造-amp-赋值构造" class="headerlink" title="拷贝构造&amp;赋值构造"></a>拷贝构造&amp;赋值构造</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* cstr=<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">String</span>(<span class="type">const</span> String&amp; str);</span><br><span class="line">        String&amp; <span class="keyword">operator</span>=(<span class="type">const</span> String&amp; str);</span><br><span class="line">        ~<span class="built_in">String</span>();</span><br><span class="line">        <span class="function"><span class="type">char</span>* <span class="title">get_c_str</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> m_data&#125;;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">char</span>* m_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">String::String</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* cstr=<span class="number">0</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cstr)&#123;</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(cstr)+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_data,cstr);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        m_data=<span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">        *m_data=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> </span><br><span class="line">String&amp; String::<span class="keyword">operator</span>=(<span class="type">const</span> String&amp; str)&#123;</span><br><span class="line">    <span class="comment">//自我赋值检测</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;str)&#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str.m_data)+<span class="number">1</span>]</span><br><span class="line">    <span class="built_in">strcpy</span>(m_data,str.m_data);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> String::~<span class="built_in">String</span>()&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="虚函数与虚函数表"><a href="#虚函数与虚函数表" class="headerlink" title="虚函数与虚函数表"></a>虚函数与虚函数表</h2><h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><p><img src="https://s2.loli.net/2022/04/23/eFg6MKAtakQ9BDi.jpg" alt="虚函数图示"></p>
<h4 id="静态绑定"><a href="#静态绑定" class="headerlink" title="静态绑定"></a>静态绑定</h4><ul>
<li>call 方法<h4 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h4></li>
</ul>
<p><em>满足以下条件</em></p>
<ul>
<li>指针</li>
<li>向上转型</li>
<li>调用的是虚函数</li>
</ul>
<h5 id="编译成图示形式"><a href="#编译成图示形式" class="headerlink" title="编译成图示形式"></a>编译成图示形式</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(*(p-&gt;vptr)[n])(p);</span><br></pre></td></tr></table></figure>
<h5 id="动态绑定的实现原理"><a href="#动态绑定的实现原理" class="headerlink" title="动态绑定的实现原理"></a>动态绑定的实现原理</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CMyDoc</span>:<span class="keyword">public</span> CDocument&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">Serialize</span><span class="params">()</span></span>&#123;....&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">main</span>()&#123;</span><br><span class="line">    CMyDoc myDoc;</span><br><span class="line">    ...</span><br><span class="line">    myDoc.<span class="built_in">OnFileOpen</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CDocument::<span class="built_in">OnFileOpen</span>()&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">Serialize</span>();</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们调用OnFileOpen时，会将this指针传入，调用的Serialize方法，会在虚函数表上进行查找，虚函数表会讲地址重新定位为CMyDoc 所重写的函数地址</p>
<h5 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">B b;</span><br><span class="line">A a=(A)b;</span><br><span class="line"><span class="comment">//调用的是A的vfunc1();因为不是使用指针使用。</span></span><br><span class="line"><span class="comment">//编译成汇编时后面跟着call 0x8987979 ,为一串固定的地址</span></span><br><span class="line">a.<span class="built_in">vfunc1</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用的是B的vfunc1()</span></span><br><span class="line"><span class="comment">//1. 使用指针调用</span></span><br><span class="line"><span class="comment">//2. 向上转型</span></span><br><span class="line"><span class="comment">//3. 虚函数</span></span><br><span class="line">A* pa=<span class="keyword">new</span> B;</span><br><span class="line">pa-&gt;<span class="built_in">vfunc1</span>()<span class="comment">//call dword ptr [edx]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用的是B的vfunc1()</span></span><br><span class="line">pa=&amp;b;</span><br><span class="line">pa-&gt;<span class="built_in">vfunc1</span>()<span class="comment">//call dword ptr [edx]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="new与delete的重载"><a href="#new与delete的重载" class="headerlink" title="new与delete的重载"></a>new与delete的重载</h2><h3 id="全局函数重载"><a href="#全局函数重载" class="headerlink" title="全局函数重载"></a>全局函数重载</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义malloc</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myAlloc</span><span class="params">(<span class="type">size_t</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自定义free</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFree</span><span class="params">(<span class="type">void</span>* ptr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义new</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;call my global new() \n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">myAlloc</span>(size); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义new[]</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span> size)&#123;</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;call my global new[]() \n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">myAlloc</span>(size); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义delete</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">size_t</span> size)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;call my global delete() \n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">myFree</span>(size); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义delete[]</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">size_t</span> size)&#123;</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;call my global delete[]() \n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">myFree</span>(size); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类内部函数重载"><a href="#类内部函数重载" class="headerlink" title="类内部函数重载"></a>类内部函数重载</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span>  <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>*,<span class="type">size_t</span>)</span></span>;<span class="comment">//size_t 可选的</span></span><br><span class="line">        <span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span>);</span><br><span class="line">        <span class="type">void</span>  <span class="keyword">operator</span> delet[](<span class="type">void</span>*,<span class="type">size_t</span>);<span class="comment">//size_t 可选的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo* p = <span class="keyword">new</span> Foo; </span><br><span class="line"><span class="comment">// 变为以下动作</span></span><br><span class="line"><span class="type">void</span>* mem = <span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(Foo));<span class="comment">//call Foo 内的重载new</span></span><br><span class="line">p = <span class="built_in">static_cast</span>&lt;Foo*&gt;(mem);</span><br><span class="line">p-&gt;Foo::<span class="built_in">Foo</span>();</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="comment">// 变为以下动作</span></span><br><span class="line">p-&gt;~<span class="built_in">Foo</span>();</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(p)</span><span class="comment">//call Foo 内的重载delete</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Foo* p </span>= <span class="keyword">new</span> Foo[N]; </span><br><span class="line"><span class="comment">// 变为以下动作</span></span><br><span class="line"><span class="type">void</span>* mem = <span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(Foo)*N +<span class="number">4</span>);<span class="comment">//call Foo 内的重载new</span></span><br><span class="line">p = <span class="built_in">static_cast</span>&lt;Foo*&gt;(mem);</span><br><span class="line">p-&gt;Foo::<span class="built_in">Foo</span>();<span class="comment">//N次</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br><span class="line"><span class="comment">// 变为以下动作</span></span><br><span class="line">p-&gt;~<span class="built_in">Foo</span>();<span class="comment">//N 次</span></span><br><span class="line"><span class="keyword">operator</span> <span class="keyword">delete</span>[](p)<span class="comment">//call Foo 内的重载delete</span></span><br></pre></td></tr></table></figure>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _id;</span><br><span class="line">    <span class="type">long</span> _data;</span><br><span class="line">    string _str;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>():_id(<span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;default ctor.this=&quot;</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;<span class="string">&quot; id=&quot;</span>&lt;&lt;_id&lt;&lt;<span class="string">&quot; _data&quot;</span>&lt;&lt;_data&lt;&lt;<span class="string">&quot; stirng=&quot;</span>&lt;&lt;_str&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span> i):_id(i)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot; ctor.this=&quot;</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;<span class="string">&quot; id=&quot;</span>&lt;&lt;_id&lt;&lt;<span class="string">&quot; _data&quot;</span>&lt;&lt;_data&lt;&lt;<span class="string">&quot; stirng=&quot;</span>&lt;&lt;_str&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//virtual </span></span><br><span class="line">    ~<span class="built_in">Foo</span>() &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;dtor.this=&quot;</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;<span class="string">&quot; _id=&quot;</span>&lt;&lt;_id&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* pdead,<span class="type">size_t</span> size)</span></span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span> size);</span><br><span class="line">    <span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span>* pdead,<span class="type">size_t</span> size);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* Foo::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span>&#123;</span><br><span class="line">    <span class="type">void</span>* p =  <span class="built_in">malloc</span>(size);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;call my new size=&quot;</span>&lt;&lt;size&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> Foo::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* pdead,<span class="type">size_t</span> size)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;call my delete size=&quot;</span>&lt;&lt;size&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">free</span>(pdead);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* Foo::<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span> size)&#123;</span><br><span class="line">    <span class="type">void</span>* p = (<span class="type">void</span>*) <span class="built_in">malloc</span>(size);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;call my new[] size=&quot;</span>&lt;&lt;size&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> Foo::<span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span>* pdead,<span class="type">size_t</span> size)&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;call my[] delete size=&quot;</span>&lt;&lt;size&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">free</span>(pdead);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若无成员函数就调用全局函数</span></span><br><span class="line">Foo *pf = <span class="keyword">new</span> Foo;</span><br><span class="line"><span class="keyword">delete</span> pf;</span><br><span class="line"></span><br><span class="line"><span class="comment">//强制使用globals 方法</span></span><br><span class="line"></span><br><span class="line">Foo *pf = ::<span class="keyword">new</span> Foo;</span><br><span class="line">::<span class="keyword">delete</span> pf;</span><br></pre></td></tr></table></figure>
<ul>
<li>clang mac 64 位电脑运行结果  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout&lt;&lt;<span class="string">&quot;sizeof(int)&quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(<span class="type">int</span>)&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;sizeof(long)&quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(<span class="type">long</span>)&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;sizeof(string)&quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(string)&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;sizeof(Foo)&quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(Foo)&lt;&lt;endl;</span><br><span class="line">Foo* p = <span class="keyword">new</span> <span class="built_in">Foo</span>(<span class="number">7</span>);</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">Foo* pArray= <span class="keyword">new</span> Foo[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">delete</span>[] pArray;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>析构函数为非虚函数版本</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sizeof</span>(<span class="type">int</span>)<span class="number">4</span></span><br><span class="line"><span class="built_in">sizeof</span>(<span class="type">long</span>)<span class="number">8</span></span><br><span class="line"><span class="built_in">sizeof</span>(string)<span class="number">24</span></span><br><span class="line"><span class="built_in">sizeof</span>(Foo)<span class="number">40</span></span><br><span class="line">call my <span class="keyword">new</span> size=<span class="number">40</span></span><br><span class="line">ctor.<span class="keyword">this</span>=<span class="number">0x7ff42a405990</span> id=<span class="number">7</span> _data0 stirng=</span><br><span class="line">dtor.<span class="keyword">this</span>=<span class="number">0x7ff42a405990</span> _id=<span class="number">7</span></span><br><span class="line">call my <span class="keyword">delete</span> size=<span class="number">40</span></span><br><span class="line">call my <span class="keyword">new</span>[] size=<span class="number">208</span></span><br><span class="line"><span class="keyword">default</span> ctor.<span class="keyword">this</span>=<span class="number">0x7ff42a4059c8</span> id=<span class="number">0</span> _data0 stirng=</span><br><span class="line"><span class="keyword">default</span> ctor.<span class="keyword">this</span>=<span class="number">0x7ff42a4059f0</span> id=<span class="number">0</span> _data0 stirng=</span><br><span class="line"><span class="keyword">default</span> ctor.<span class="keyword">this</span>=<span class="number">0x7ff42a405a18</span> id=<span class="number">0</span> _data0 stirng=</span><br><span class="line"><span class="keyword">default</span> ctor.<span class="keyword">this</span>=<span class="number">0x7ff42a405a40</span> id=<span class="number">0</span> _data0 stirng=</span><br><span class="line"><span class="keyword">default</span> ctor.<span class="keyword">this</span>=<span class="number">0x7ff42a405a68</span> id=<span class="number">0</span> _data0 stirng=</span><br><span class="line">dtor.<span class="keyword">this</span>=<span class="number">0x7ff42a405a68</span> _id=<span class="number">0</span></span><br><span class="line">dtor.<span class="keyword">this</span>=<span class="number">0x7ff42a405a40</span> _id=<span class="number">0</span></span><br><span class="line">dtor.<span class="keyword">this</span>=<span class="number">0x7ff42a405a18</span> _id=<span class="number">0</span></span><br><span class="line">dtor.<span class="keyword">this</span>=<span class="number">0x7ff42a4059f0</span> _id=<span class="number">0</span></span><br><span class="line">dtor.<span class="keyword">this</span>=<span class="number">0x7ff42a4059c8</span> _id=<span class="number">0</span></span><br><span class="line">call my[] <span class="keyword">delete</span> size=<span class="number">208</span></span><br></pre></td></tr></table></figure></li>
<li><p>析构函数为非虚函数版本</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sizeof</span>(<span class="type">int</span>)<span class="number">4</span></span><br><span class="line"><span class="built_in">sizeof</span>(<span class="type">long</span>)<span class="number">8</span></span><br><span class="line"><span class="built_in">sizeof</span>(string)<span class="number">24</span></span><br><span class="line"><span class="built_in">sizeof</span>(Foo)<span class="number">48</span></span><br><span class="line">call my <span class="keyword">new</span> size=<span class="number">48</span></span><br><span class="line">ctor.<span class="keyword">this</span>=<span class="number">0x7ff9f4c05990</span> id=<span class="number">7</span> _data0 stirng=</span><br><span class="line">dtor.<span class="keyword">this</span>=<span class="number">0x7ff9f4c05990</span> _id=<span class="number">7</span></span><br><span class="line">call my <span class="keyword">delete</span> size=<span class="number">48</span></span><br><span class="line">call my <span class="keyword">new</span>[] size=<span class="number">248</span></span><br><span class="line"><span class="keyword">default</span> ctor.<span class="keyword">this</span>=<span class="number">0x7ff9f4c059c8</span> id=<span class="number">0</span> _data0 stirng=</span><br><span class="line"><span class="keyword">default</span> ctor.<span class="keyword">this</span>=<span class="number">0x7ff9f4c059f8</span> id=<span class="number">0</span> _data0 stirng=</span><br><span class="line"><span class="keyword">default</span> ctor.<span class="keyword">this</span>=<span class="number">0x7ff9f4c05a28</span> id=<span class="number">0</span> _data0 stirng=</span><br><span class="line"><span class="keyword">default</span> ctor.<span class="keyword">this</span>=<span class="number">0x7ff9f4c05a58</span> id=<span class="number">0</span> _data0 stirng=</span><br><span class="line"><span class="keyword">default</span> ctor.<span class="keyword">this</span>=<span class="number">0x7ff9f4c05a88</span> id=<span class="number">0</span> _data0 stirng=</span><br><span class="line">dtor.<span class="keyword">this</span>=<span class="number">0x7ff9f4c05a88</span> _id=<span class="number">0</span></span><br><span class="line">dtor.<span class="keyword">this</span>=<span class="number">0x7ff9f4c05a58</span> _id=<span class="number">0</span></span><br><span class="line">dtor.<span class="keyword">this</span>=<span class="number">0x7ff9f4c05a28</span> _id=<span class="number">0</span></span><br><span class="line">dtor.<span class="keyword">this</span>=<span class="number">0x7ff9f4c059f8</span> _id=<span class="number">0</span></span><br><span class="line">dtor.<span class="keyword">this</span>=<span class="number">0x7ff9f4c059c8</span> _id=<span class="number">0</span></span><br><span class="line">call my[] <span class="keyword">delete</span> size=<span class="number">248</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="new-delete"><a href="#new-delete" class="headerlink" title="new(),delete()"></a>new(),delete()</h3><ul>
<li>new（）<ul>
<li>可以重载new 但要求new都有不同的参数</li>
<li>而且其中的第一个参数必须是size_t size</li>
</ul>
</li>
<li>delete()<ul>
<li>可以写出多个delete，但不会被默认调用，只有在默认版本的new 抛出异常时才会被调用</li>
</ul>
</li>
</ul>
<h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>():<span class="built_in">m_i</span>(<span class="number">0</span>)&#123;cout&lt;&lt;<span class="string">&quot;Foo::Foo()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span> i):<span class="built_in">m_i</span>(i)&#123;cout&lt;&lt;<span class="string">&quot;Foo::Foo(int)&quot;</span>&lt;&lt;endl;<span class="keyword">throw</span> <span class="built_in">Bad</span>();&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;new size_t size&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size,<span class="type">void</span>* start)</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;(size_t size,void* start)&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="type">size_t</span> size,<span class="type">long</span> extra)</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;(size_t size,long extra)&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">malloc</span>(size+extra);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size,<span class="type">long</span> extra,<span class="type">char</span> init)</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;(size_t size,long extra,char init)&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">malloc</span>(size+extra);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* ,<span class="type">size_t</span> )</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;operator delete(void* ,size_t )&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* ,<span class="type">void</span>* )</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;operator delete(void* pdead,size_t size,void* start)&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* ,<span class="type">long</span> )</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;operator delete(void* pdead,size_t size,,long start)&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* ,<span class="type">long</span> ,<span class="type">char</span> )</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;operator delete(void* pdead,size_t size,,long start,char init)&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Foo start;</span><br><span class="line">Foo* p1= <span class="keyword">new</span> Foo;</span><br><span class="line">Foo* p2 = <span class="built_in">new</span>(&amp;start)Foo;</span><br><span class="line">Foo* p3 = <span class="built_in">new</span>(<span class="number">100</span>)Foo;</span><br><span class="line">Foo* p4 = <span class="built_in">new</span>(<span class="number">100</span>,<span class="string">&#x27;a&#x27;</span>)Foo;</span><br><span class="line"><span class="comment">//Foo* p5 = new(100)Foo(1);</span></span><br><span class="line">Foo* p6 = <span class="built_in">new</span>(<span class="number">100</span>)<span class="built_in">Foo</span>(<span class="number">1</span>);</span><br><span class="line">Foo* p7 = <span class="built_in">new</span>(<span class="number">100</span>,<span class="string">&#x27;a&#x27;</span>)<span class="built_in">Foo</span>(<span class="number">1</span>);</span><br><span class="line">Foo* p8 = <span class="built_in">new</span>(&amp;start)<span class="built_in">Foo</span>(<span class="number">1</span>);</span><br><span class="line">Foo* p5 = <span class="keyword">new</span> <span class="built_in">Foo</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h4 id="例子结果"><a href="#例子结果" class="headerlink" title="例子结果"></a>例子结果</h4><p><em>并没有调用对应的析构函数</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Foo::<span class="built_in">Foo</span>()</span><br><span class="line"><span class="keyword">new</span> <span class="type">size_t</span> size</span><br><span class="line">Foo::<span class="built_in">Foo</span>()</span><br><span class="line">(<span class="type">size_t</span> size,<span class="type">void</span>* start)</span><br><span class="line">Foo::<span class="built_in">Foo</span>()</span><br><span class="line">(<span class="type">size_t</span> size,<span class="type">long</span> extra)</span><br><span class="line">Foo::<span class="built_in">Foo</span>()</span><br><span class="line">(<span class="type">size_t</span> size,<span class="type">long</span> extra,<span class="type">char</span> init)</span><br><span class="line">Foo::<span class="built_in">Foo</span>()</span><br><span class="line">(<span class="type">size_t</span> size,<span class="type">long</span> extra)</span><br><span class="line">Foo::<span class="built_in">Foo</span>(<span class="type">int</span>)</span><br><span class="line">libc++abi.dylib: terminating with uncaught exception of type Bad</span><br><span class="line">Process finished with exit code <span class="number">6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
        <category>cpp</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>虚函数</tag>
        <tag>cpp</tag>
        <tag>侯捷</tag>
        <tag>构造</tag>
        <tag>析构</tag>
        <tag>内联函数</tag>
        <tag>操作符重载</tag>
        <tag>临时对象</tag>
        <tag>赋值构造</tag>
        <tag>拷贝构造</tag>
        <tag>虚函数表</tag>
        <tag>this</tag>
        <tag>自定义new</tag>
        <tag>自定义delete</tag>
        <tag>new()</tag>
        <tag>delete()</tag>
      </tags>
  </entry>
  <entry>
    <title>variadic Template(可变参数模板)</title>
    <url>/2022/04/16/variadic-Template-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<!-- <blockquote class="blockquote-center">this is note</blockquote> -->
<p><strong>使用可变参数模板可以实现</strong></p>
<ul>
<li>递归调用</li>
<li>递归创建</li>
<li>递归继承</li>
<li>递归复合<span id="more"></span></li>
</ul>
<h1 id="variadic-template"><a href="#variadic-template" class="headerlink" title="variadic template"></a>variadic template</h1><ul>
<li>template<ul>
<li>function template</li>
<li>class tempalate</li>
</ul>
</li>
</ul>
<hr>
<p>变化的区别</p>
<ul>
<li>参数个数<ul>
<li>利用参数个数逐一递减的特性，实现递归函数调用，使用function template 完成</li>
</ul>
</li>
<li>参数类型<ul>
<li>利用参数个数逐一递减，导致参数函数类型也逐一递减实现递归集成,或递归复合，以class template 完成</li>
</ul>
</li>
</ul>
<h2 id="sample"><a href="#sample" class="headerlink" title="sample"></a>sample</h2><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><ul>
<li><p>例子1</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printX</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个是特化版本，当前版本存在时，下面的函数不会呗调用 既 void printX(const Types&amp; args) 不会被调用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... types&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printX</span><span class="params">(constT&amp; firstArg,<span class="type">const</span> Types&amp; args)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;fistArg&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">print</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... types&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printX</span><span class="params">(<span class="type">const</span> Types&amp; args)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;fistArg&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">print</span>(args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>例子2 重写printf function</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(*s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*s == <span class="string">&#x27;%&#x27;</span>&amp;&amp;*(++s) !+<span class="string">&#x27;%&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;invalid format string:missing argument&quot;</span>)</span><br><span class="line">        std::cout&lt;&lt;*s++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*s,T value,Args... args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(*s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*s == <span class="string">&#x27;%&#x27;</span> &amp;&amp; *(++s) !=<span class="string">&#x27;%&#x27;</span>)&#123;</span><br><span class="line">            std::cout&lt;&lt;value;</span><br><span class="line">            <span class="built_in">printf</span>(++s,args...);</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        &#125;</span><br><span class="line">        std::cout&lt;&lt;*s++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;extra argument provided to printf&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>例子3 max函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//stl_algo.h</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _ForwardIterator,<span class="keyword">typename</span> _Compare&gt;</span><br><span class="line">_ForwardIterator</span><br><span class="line">__max_element(_ForwardIterator __first,_ForwarIterator __last,_Compare __comp)&#123;</span><br><span class="line">    <span class="keyword">if</span>(__first==__last) <span class="keyword">return</span> __first;</span><br><span class="line">    _ForwardIterator __result=__first;</span><br><span class="line">    <span class="keyword">while</span>(++__first!=__last)</span><br><span class="line">        <span class="keyword">if</span>(__comp(result,__first))</span><br><span class="line">            __result =__first;</span><br><span class="line">    <span class="keyword">return</span> __result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _ForwardIterator&gt;</span></span><br><span class="line"><span class="function"> <span class="keyword">inline</span> _ForwardIterator</span></span><br><span class="line"><span class="function"> <span class="title">max_element</span><span class="params">(_ForwardIterator __first,_ForwarIterator __last)</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> __max_element(__first,__last,__iter_less_iter());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//stl_algo.h</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> __Tp&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Tp</span></span><br><span class="line"><span class="function"><span class="title">max</span><span class="params">(initializer_list&lt;__Tp&gt; __l)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="built_in">max_element</span>(_l.<span class="built_in">begin</span>(),_l.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//predefined_oops.h</span></span><br><span class="line"><span class="keyword">inline</span> _Iter_less_iter</span><br><span class="line">__iter_less_iter()&#123;</span><br><span class="line">    <span class="keyword">return</span> _Iter_less_iter();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//predefined_oops.h</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_Iter_less_iter</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Iterator1,</span></span><br><span class="line"><span class="function">             <span class="keyword">typename</span> _Iterator2&gt;</span></span><br><span class="line"><span class="function">    <span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(_Iterator1 __it1,_Iterator2 __it2)</span><span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *__it1&lt;*__it2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="built_in">max</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//改进</span></span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="built_in">max</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maximum</span><span class="params">(<span class="type">int</span> n,Args... args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">max</span>(n,<span class="built_in">max</span>(...args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="例子4-类模板"><a href="#例子4-类模板" class="headerlink" title="例子4 类模板"></a>例子4 类模板</h1><h2 id="用不同的方式处理first元素和last元素"><a href="#用不同的方式处理first元素和last元素" class="headerlink" title="用不同的方式处理first元素和last元素"></a>用不同的方式处理first元素和last元素</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout&lt;&lt; <span class="built_in">make_tuple</span>(<span class="number">7.5</span>,<span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>),<span class="built_in">bitset</span>&lt;<span class="number">16</span>&gt;(<span class="number">377</span>),<span class="number">42</span>);</span><br><span class="line"><span class="comment">//输出[7.5,hello,000000000101111001,42]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,<span class="type">const</span> tuple&lt;Args...&gt;&amp; t)&#123;</span><br><span class="line">    os&lt;&lt;<span class="string">&quot;[&quot;</span>;</span><br><span class="line">    PRINT_TUPLE&lt;<span class="number">0</span>,<span class="keyword">sizeof</span>...(Args),Args...&gt;<span class="built_in">print</span>(os,t);</span><br><span class="line">    os&lt;&lt;<span class="string">&quot;]&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> os&lt;&lt;<span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//boost: util/printtuple.hpp</span></span><br><span class="line"><span class="comment">//helper:print elment with index IDX of tuple</span></span><br><span class="line"><span class="comment">// with MAX element</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> IDX,<span class="type">int</span> MAX,<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PRINT_TUPLE</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">(ostream&amp; os,<span class="type">const</span> tuple&lt;Args...&gt;&amp; t)</span></span>&#123;</span><br><span class="line">        os&lt;&lt;<span class="built_in">get</span>&lt;IDX&gt;(t)&lt;&lt;(IDX+<span class="number">1</span>==MAX?<span class="string">&quot;&quot;</span>:<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        PRINT_TUPLE&lt;IDX+<span class="number">1</span>,MAX,Args...&gt;::<span class="built_in">print</span>(os,t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> MAX,<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PRINT_TUPLE</span>&lt;MAX,MAX,Args...&gt;&#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">(std::ostream&amp; os,<span class="type">const</span> tuple&lt;Args...&gt;&amp;t)</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="例子5-用于递归继承"><a href="#例子5-用于递归继承" class="headerlink" title="例子5 用于递归继承"></a>例子5 用于递归继承</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>...,Values&gt; <span class="keyword">class</span> <span class="title class_">tuple</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="keyword">class</span> <span class="title class_">tuple</span>&lt;&gt;&#123;&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head,typenmae... Tail&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tuple</span>&lt;Head,Tail...&gt;:<span class="keyword">private</span> tuple&lt;Tail...&gt;&#123;</span><br><span class="line">    <span class="keyword">typedef</span> tuple&lt;Tail...&gt; inherited;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">       <span class="built_in">tuple</span>()&#123;&#125;</span><br><span class="line">       <span class="built_in">tuple</span>(Head v,Tail... vtail):<span class="built_in">m_head</span>(v),<span class="built_in">inherited</span>(vtail...)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">typename</span> Head::type <span class="title">head</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_head;&#125;</span><br><span class="line">    <span class="function">inherited&amp; <span class="title">tail</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125; </span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">     Head m_head;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译不过，改进版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>...,Values&gt; <span class="keyword">class</span> <span class="title class_">tuple</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="keyword">class</span> <span class="title class_">tuple</span>&lt;&gt;&#123;&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head,typenmae... Tail&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tuple</span>&lt;Head,Tail...&gt;:<span class="keyword">private</span> tuple&lt;Tail...&gt;&#123;</span><br><span class="line">    <span class="keyword">typedef</span> tuple&lt;Tail...&gt; inherited;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">     Head m_head;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">       <span class="built_in">tuple</span>()&#123;&#125;</span><br><span class="line">       <span class="built_in">tuple</span>(Head v,Tail... vtail):<span class="built_in">m_head</span>(v),<span class="built_in">inherited</span>(vtail...)&#123;&#125;</span><br><span class="line">    <span class="comment">//typename Head::type head()&#123;return m_head;&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">head</span><span class="params">()</span>-&gt;<span class="title">decltype</span><span class="params">(m_head)</span></span>&#123;<span class="keyword">return</span> m_head;&#125;</span><br><span class="line">    <span class="function">inherited&amp; <span class="title">tail</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125; </span><br><span class="line">    <span class="comment">// protected:</span></span><br><span class="line">    <span class="comment">//  Head m_head;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 简化版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>...,Values&gt; <span class="keyword">class</span> <span class="title class_">tuple</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="keyword">class</span> <span class="title class_">tuple</span>&lt;&gt;&#123;&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head,typenmae... Tail&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tuple</span>&lt;Head,Tail...&gt;:<span class="keyword">private</span> tuple&lt;Tail...&gt;&#123;</span><br><span class="line">    <span class="keyword">typedef</span> tuple&lt;Tail...&gt; inherited;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">     Head m_head;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">       <span class="built_in">tuple</span>()&#123;&#125;</span><br><span class="line">       <span class="built_in">tuple</span>(Head v,Tail... vtail):<span class="built_in">m_head</span>(v),<span class="built_in">inherited</span>(vtail...)&#123;&#125;<span class="comment">//相当于调用父类的构造</span></span><br><span class="line">    <span class="comment">//typename Head::type head()&#123;return m_head;&#125;</span></span><br><span class="line">    <span class="function">Head <span class="title">head</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_head;&#125;</span><br><span class="line">    <span class="function">inherited&amp; <span class="title">tail</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125; <span class="comment">//相当于向上转型</span></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">     Head m_head;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="例子6"><a href="#例子6" class="headerlink" title="例子6"></a>例子6</h1><h2 id="用于递归复合"><a href="#用于递归复合" class="headerlink" title="用于递归复合"></a>用于递归复合</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Values&gt;<span class="keyword">class</span> <span class="title class_">tup</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="keyword">class</span> <span class="title class_">tup</span>&lt;&gt;&#123;&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head,<span class="keyword">typename</span>... Tail&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tup</span>&lt;Head,Tail...&gt;&#123;</span><br><span class="line">    <span class="keyword">typedef</span> tup&lt;Tail...&gt; composited;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        composited m_tail;</span><br><span class="line">        Head m_head;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">tup</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">tup</span>(Head v,Tail... vtail):<span class="built_in">m_tail</span>(vtail...),<span class="built_in">m_head</span>(v)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Head <span class="title">head</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_head;&#125;</span><br><span class="line">    <span class="function">composited&amp; <span class="title">tail</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_tail;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
        <category>cpp</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>variadic templates</tag>
      </tags>
  </entry>
  <entry>
    <title>仿函数&amp;share_ptr(指针类)</title>
    <url>/2022/03/22/%E4%BB%BF%E5%87%BD%E6%95%B0-share-ptr/</url>
    <content><![CDATA[<!-- <blockquote class="blockquote-center">this is note</blockquote> -->
<ul>
<li>share_ptr<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">share_ptr</span>&#123;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">share_ptr</span>(T* p):<span class="built_in">px</span>(p)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    T* px;</span><br><span class="line">    <span class="type">long</span>* pn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><h2 id="share-ptr"><a href="#share-ptr" class="headerlink" title="share_ptr"></a>share_ptr</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">share_ptr</span>&#123;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">share_ptr</span>(T* p):<span class="built_in">px</span>(p)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    T* px;</span><br><span class="line">    <span class="type">long</span>* pn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">method</span><span class="params">(<span class="type">void</span>)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">shared_ptr&lt;Foo&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> Foo())</span></span>;</span><br><span class="line"><span class="function">Foo <span class="title">f</span><span class="params">(*sp)</span></span>;</span><br><span class="line">sp-&gt;<span class="built_in">method</span>();<span class="comment">//-&gt;不会被消耗掉</span></span><br></pre></td></tr></table></figure>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__list_node</span>&#123;</span><br><span class="line">    <span class="type">void</span>* prev;</span><br><span class="line">    <span class="type">void</span>* next;</span><br><span class="line">    T data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Ref</span>,<span class="keyword">class</span> <span class="title class_">Ptr</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__list_iterator</span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> __list_iterator&lt;T,Ref,Ptr&gt; self;</span><br><span class="line">    <span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">    <span class="keyword">typedef</span> Ref reference;</span><br><span class="line">    <span class="keyword">typedef</span> __list_node&lt;T&gt;* link_type;</span><br><span class="line">    link_type node;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> self&amp; x)<span class="type">const</span>&#123;<span class="keyword">return</span> node == x.node&#125;;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> self&amp; x)<span class="type">const</span>&#123;<span class="keyword">return</span> node != x.node&#125;;</span><br><span class="line">    reference <span class="keyword">operator</span>*() <span class="type">const</span>&#123;<span class="keyword">return</span> (*node).data&#125;;</span><br><span class="line">    pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span>&#123;<span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*());&#125;<span class="comment">//operator*() 是调用上面的函数operator*()</span></span><br><span class="line">    self&amp; <span class="keyword">operator</span>++()&#123;node = (link_type)((*node).next);<span class="keyword">return</span> node;&#125;</span><br><span class="line">    self&amp; <span class="keyword">operator</span>++(<span class="type">int</span> )&#123;self tmp=* <span class="keyword">this</span>; ++*<span class="keyword">this</span>;<span class="keyword">return</span> tmp&#125;</span><br><span class="line">    self&amp; <span class="keyword">operator</span>--()&#123;node = (link_type)((*node).prev);<span class="keyword">return</span> node&#125;</span><br><span class="line">    self&amp; <span class="keyword">operator</span>--(<span class="type">int</span>)&#123;self tmp=*<span class="keyword">this</span>; --*<span class="keyword">this</span>;<span class="keyword">return</span> tmp&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">identity</span> :<span class="keyword">public</span> unary_function&lt;T,T&gt;&#123;</span><br><span class="line">    <span class="type">const</span> T&amp;;</span><br><span class="line">    <span class="built_in">operator</span>() (<span class="type">const</span> T&amp; x)<span class="type">const</span>&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Pair</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">select1st</span>:<span class="keyword">public</span> unary_function&lt;Pair,<span class="keyword">typename</span> Pair::first_type&gt;&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="keyword">typename</span> Pair::first_type&amp;</span></span><br><span class="line"><span class="function">    <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Pair&amp; x)</span><span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Pair</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">select2nd</span>:<span class="keyword">public</span> unary_function&lt;Pair,<span class="keyword">typename</span> Pair::second_type&gt;&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="keyword">typename</span> Pair::second_type&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Pair&amp; x)</span><span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tempalate &lt;<span class="keyword">class</span> <span class="title class_">Arg</span>,<span class="keyword">class</span> <span class="title class_">Result</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">unary_function</span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> Arg argument_type;</span><br><span class="line">    <span class="keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Arg1</span>,<span class="keyword">class</span> <span class="title class_">Arg2</span>,<span class="keyword">class</span> <span class="title class_">Result</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">binary_function</span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> Arg1 first_argument_type;</span><br><span class="line">    <span class="keyword">typedef</span> Arg2 second_argument_type;</span><br><span class="line">    <span class="keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pair</span>&#123;</span><br><span class="line">    T1 first;</span><br><span class="line">    T2 second;</span><br><span class="line">    <span class="built_in">pair</span>() :<span class="built_in">first</span>(<span class="built_in">T1</span>()),<span class="built_in">second</span>(<span class="built_in">T2</span>())&#123;&#125;</span><br><span class="line">    <span class="built_in">pair</span>(<span class="type">const</span> T1&amp; a,<span class="type">const</span> T2&amp; b):<span class="built_in">first</span>(a),<span class="built_in">second</span>(d)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
        <category>cpp</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>仿函数</tag>
        <tag>智能指针</tag>
        <tag>auto_pointer</tag>
        <tag>share_pointer(c11)</tag>
      </tags>
  </entry>
  <entry>
    <title>右值引用（Rvalue）</title>
    <url>/2022/04/17/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%EF%BC%88Rvalue%EF%BC%89/</url>
    <content><![CDATA[<!-- <blockquote class="blockquote-center">this is note</blockquote> -->
<h1 id="右值引用（Rvalue）"><a href="#右值引用（Rvalue）" class="headerlink" title="右值引用（Rvalue）"></a>右值引用（Rvalue）</h1><p><strong>可以大幅改善容器的性能</strong><br><strong>当对象内部含有指针时,可以使用右值来窃取对象</strong></p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>当右边的对象是一个右值时，左侧的对象可以偷取右侧对象的资源</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//c11之前不可以对右值取地址</span></span><br><span class="line"><span class="type">int</span> x=<span class="built_in">foo</span>()</span><br><span class="line"><span class="type">int</span>* p=&amp;<span class="built_in">foo</span>()<span class="comment">//Error ：对函数的返回值取地址</span></span><br><span class="line"><span class="built_in">foo</span>()=<span class="number">7</span>;<span class="comment">//Error：对函数的返回值复制</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1 id="右值引用（Rvalue）-1"><a href="#右值引用（Rvalue）-1" class="headerlink" title="右值引用（Rvalue）"></a>右值引用（Rvalue）</h1><p><strong>可以大幅改善容器的性能</strong></p>
<h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>当右边的对象是一个右值时，左侧的对象可以偷取右侧对象的资源</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//c11之前不可以对右值取地址</span></span><br><span class="line"><span class="type">int</span> x=<span class="built_in">foo</span>()</span><br><span class="line"><span class="type">int</span>* p=&amp;<span class="built_in">foo</span>()<span class="comment">//Error ：对函数的返回值取地址</span></span><br><span class="line"><span class="built_in">foo</span>()=<span class="number">7</span>;<span class="comment">//Error：对函数的返回值复制</span></span><br></pre></td></tr></table></figure>
<p><strong>cpp 11后我们认为右值的对象时可以被窃取资源的</strong><br>为此我们需要：</p>
<ol>
<li>必须有语法让我们在<em>调用端</em>诉编译器，这是个Rvalue</li>
<li>必须有语法放我们在<em>被调用段</em>写出一个专门处理Rvalue的所谓move assignment函数</li>
</ol>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">char</span>* _data;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//copy actor(构造)</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> Mystring&amp; str):initialization list&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//move actor(构造)</span></span><br><span class="line">    <span class="built_in">Mystring</span>(MyString&amp;&amp; str)<span class="keyword">noexcept</span>:initialization list&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="G2-9"><a href="#G2-9" class="headerlink" title="G2.9"></a>G2.9</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator posistion,<span class="type">const</span> T&amp;x)</span></span>&#123;</span><br><span class="line">    size_type n=posistion-<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">if</span>(finish !=end_of_storge &amp;&amp; position ==<span class="built_in">end</span>())&#123;</span><br><span class="line">        <span class="built_in">construct</span>(finish,x);</span><br><span class="line">        ++finish;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">insert_aux</span>(position,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">begin</span>()+n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="G4-9"><a href="#G4-9" class="headerlink" title="G4.9"></a>G4.9</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">iterator</span></span><br><span class="line"><span class="function"><span class="title">insert</span><span class="params">(const_iterator __position,<span class="type">const</span> value_type&amp; __x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator</span></span><br><span class="line"><span class="function"><span class="title">instert</span><span class="params">(const_iterator __position,value_type&amp;&amp; __x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">emplace</span>(__position,std::<span class="built_in">move</span>(__x))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="旧版问题"><a href="#旧版问题" class="headerlink" title="旧版问题"></a>旧版问题</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp; i)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;process(int &amp;i):&quot;</span>&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp;&amp; i)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;process(int&amp;&amp;):&quot;</span>&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forward</span><span class="params">(<span class="type">int</span>&amp;&amp; i)</span></span>&#123;</span><br><span class="line">    out&lt;&lt;<span class="string">&quot;forward(int&amp;&amp;):&quot;</span>&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">process</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">forward(<span class="number">2</span>);<span class="comment">//foward(int&amp;&amp;):2 -&gt; process(int&amp;):2 因为在传导过程中变为了左值</span></span><br><span class="line">forward(<span class="built_in">move</span>(a));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="改进版本"><a href="#改进版本" class="headerlink" title="改进版本"></a>改进版本</h3><h4 id="标准库提供的完美的传递过去"><a href="#标准库提供的完美的传递过去" class="headerlink" title="标准库提供的完美的传递过去"></a>标准库提供的完美的传递过去</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//bits/move.h 下</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">functionA</span><span class="params">(T1&amp;&amp; t1,T2&amp;&amp; t2)</span></span>&#123;</span><br><span class="line">    <span class="built_in">funtionB</span>(std::forward&lt;T1&gt;(t1),</span><br><span class="line">             std::forward&lt;T2&gt;(t2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用时要实现一下功能</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* _data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//copy actor(构造)</span></span><br><span class="line"><span class="built_in">MyString</span>(<span class="type">const</span> Mystring&amp; str):initialization list&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//move actor(构造)</span></span><br><span class="line"><span class="built_in">Mystring</span>(MyString&amp;&amp; str)<span class="keyword">noexcept</span>:initialization list&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  copy assignment(赋值)</span></span><br><span class="line">MyString&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyString&amp; str)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//move assignment(赋值)</span></span><br><span class="line">Mystring&amp; <span class="keyword">operator</span>=(MyString&amp;&amp; str)&#123;</span><br><span class="line">    noexcpt&#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a><strong>例子</strong></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//用于测试的静态变量,实际类中不需要</span></span><br><span class="line">        <span class="type">static</span> <span class="type">size_t</span> DCtor;</span><br><span class="line">        <span class="type">static</span> <span class="type">size_t</span> Ctor;</span><br><span class="line">        <span class="type">static</span> <span class="type">size_t</span> CCtor;</span><br><span class="line">        <span class="type">static</span> <span class="type">size_t</span> CAsgn;</span><br><span class="line">        <span class="type">static</span> <span class="type">size_t</span> MCtor;</span><br><span class="line">        <span class="type">static</span> <span class="type">size_t</span> MAsgn;</span><br><span class="line">        <span class="type">static</span> <span class="type">size_t</span> Dtor;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">char</span>* _data;</span><br><span class="line">        <span class="type">size_t</span> _len;</span><br><span class="line">        <span class="type">void</span> _init_data(<span class="type">const</span> <span class="type">char</span>*s)&#123;</span><br><span class="line">            _data = <span class="keyword">new</span> <span class="type">char</span>[_len+<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">memcpy</span>(_data,s,_len);</span><br><span class="line">            _data[_len]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//default constructor</span></span><br><span class="line">        <span class="built_in">MyString</span>():_data(<span class="literal">NULL</span>),_len(<span class="number">0</span>)&#123;++DCtor;&#125;</span><br><span class="line">        <span class="comment">//constructor</span></span><br><span class="line">        <span class="built_in">MyString</span>(<span class="type">const</span> <span class="type">char</span>* p):_len(<span class="built_in">strlen</span>(p))&#123;</span><br><span class="line">            ++Ctor;</span><br><span class="line">            _init_data(p);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//copy constructor</span></span><br><span class="line">        <span class="built_in">MyString</span>(<span class="type">const</span> Mystring&amp; str):_len(str._len)&#123;</span><br><span class="line">            ++CCtor;</span><br><span class="line">            _init_data(str._data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//move construct,with noexcept</span></span><br><span class="line">        <span class="built_in">MyString</span>(Mystring&amp; str)<span class="keyword">noexcept</span>:_data(str._data),_len(str._len)&#123;</span><br><span class="line">            ++MCtor;</span><br><span class="line">            str._len=<span class="number">0</span>;</span><br><span class="line">            str._data=<span class="literal">NULL</span>;<span class="comment">//解引用</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//copy assignment</span></span><br><span class="line">        MyString&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyString&amp; str)&#123;</span><br><span class="line">            ++CAsgn;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;str)&#123;</span><br><span class="line">                <span class="keyword">if</span>(_data) <span class="keyword">delete</span> _data; <span class="comment">//源代码使用的是delete _data,我认为错误，后发现。所引用的数组已被转移，只delete 即可</span></span><br><span class="line">                _len=str._len;</span><br><span class="line">                _init_data(str._data);<span class="comment">//COPY!</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//move assignment</span></span><br><span class="line">        MyString&amp; <span class="keyword">operator</span>=(MyString&amp;&amp; str) <span class="keyword">noexcept</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span> !=&amp; str)&#123;</span><br><span class="line">                <span class="keyword">if</span>(_data) <span class="keyword">delete</span> _data;</span><br><span class="line">                _len = str._len;</span><br><span class="line">                _data=str._data;<span class="comment">//MOVE</span></span><br><span class="line">                str._len=<span class="number">0</span>;</span><br><span class="line">                str._data=<span class="literal">NULL</span><span class="comment">//重要</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//析构函数，默认就是noexcept 的</span></span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">MyString</span>()&#123;</span><br><span class="line">            ++Dtor;</span><br><span class="line">            <span class="keyword">if</span>(_data)&#123;</span><br><span class="line">                <span class="keyword">delete</span> _data;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为了set 可以使用</span></span><br><span class="line">        <span class="type">bool</span></span><br><span class="line">        <span class="keyword">operator</span>&lt;(<span class="type">const</span> MyString&amp; rhs)<span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">string</span>(<span class="keyword">this</span>._data)&lt;<span class="built_in">string</span>(rhs._data);</span><br><span class="line">            <span class="comment">//借用现成实现，std::string 可以比较大小</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span></span><br><span class="line">        <span class="keyword">operator</span>=(<span class="type">const</span> MyString&amp; rhs)<span class="type">const</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">string</span>(<span class="keyword">this</span>._data)=<span class="built_in">string</span>(rhs._data);</span><br><span class="line">            <span class="comment">//借用现成实现，std::string 可以判断是否相等</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">char</span>* <span class="title">get</span><span class="params">()</span><span class="type">const</span></span>&#123;<span class="keyword">return</span> _data;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="对于性能的影响"><a href="#对于性能的影响" class="headerlink" title="对于性能的影响"></a>对于性能的影响</h2><ul>
<li>vector<ul>
<li>插入元素,影响巨大，是否实现移动构造</li>
<li>容器拷贝,影响巨大，需要使用std::move()</li>
<li>容器交换,影响巨大，需要使用std::move()</li>
</ul>
</li>
<li>deque <ul>
<li>插入元素,影响不大 (不一定,和元素的位置相关)</li>
<li>容器拷贝,影响巨大，需要使用std::move()</li>
<li>容器交换,影响巨大，需要使用std::move()</li>
</ul>
</li>
<li>list 链表<ul>
<li>插入元素,影响不大</li>
<li>容器拷贝,影响巨大，需要使用std::move()</li>
<li>容器交换,影响巨大，需要使用std::move()</li>
</ul>
</li>
<li>multiset(红黑树)<ul>
<li>插入元素,影响不大</li>
<li>容器拷贝,影响巨大，需要使用std::move()</li>
<li>容器交换,影响巨大，需要使用std::move()</li>
</ul>
</li>
<li>unordered_multiset(hash_table)<ul>
<li>插入元素, 差别不大</li>
<li>容器拷贝,影响巨大，需要使用std::move()</li>
<li>容器交换,影响巨大，需要使用std::move()</li>
</ul>
</li>
</ul>
<h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><ol>
<li>容器拷贝<ol>
<li>如果使用拷贝构造，会进行内存的分配，并且拷贝每一个内容</li>
<li>如果使用移动构造，只更改对应的容器的指针。&#x2F;&#x2F;常量的时间</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
        <category>cpp</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>右值引用</tag>
        <tag>std::move</tag>
        <tag>容器性能</tag>
      </tags>
  </entry>
  <entry>
    <title>堆与栈</title>
    <url>/2022/03/19/%E5%A0%86%E4%B8%8E%E6%A0%88/</url>
    <content><![CDATA[<!-- <blockquote class="blockquote-center">this is note</blockquote> -->
<ul>
<li><p>栈</p>
<p>  是存在于某一作用域内的数据，在函数内声明的任何变量，其所使用的内存块都取自上述stack</p>
</li>
<li><p>堆</p>
<p>  实在system heap,是由操作系统提供的一块global 内存空间，系统可动态分配其中的若干块，但是要</p>
</li>
</ul>
<span id="more"></span>
<h1 id="栈和堆"><a href="#栈和堆" class="headerlink" title="栈和堆"></a>栈和堆</h1><table>
<thead>
<tr>
<th>区别</th>
<th>堆</th>
<th>栈</th>
</tr>
</thead>
<tbody><tr>
<td>删除方式</td>
<td>需要手动删除</td>
<td>当栈返回时会自动删除</td>
</tr>
</tbody></table>
<ul>
<li><p>static 对象</p>
<p>起作用域结束之后仍然存在，直到整个程序结束</p>
</li>
<li><p>global 对象</p>
<p>在任何{} 外,直到整个程序结束之后才结束，其作用域是整个程序，视为一种static object</p>
</li>
</ul>
<h2 id="new和delete"><a href="#new和delete" class="headerlink" title="new和delete"></a>new和delete</h2><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">String s= <span class="keyword">new</span> <span class="built_in">Stirng</span>(<span class="string">&quot;sss&quot;</span>);</span><br><span class="line"><span class="keyword">delete</span> s;</span><br><span class="line"><span class="type">int</span>[] store=<span class="keyword">new</span> <span class="type">int</span>[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">delete</span>[] store;</span><br></pre></td></tr></table></figure>
<h3 id="背后实现"><a href="#背后实现" class="headerlink" title="背后实现"></a>背后实现</h3><ul>
<li>new<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Complex *pc;</span><br><span class="line"><span class="type">void</span>* mem=<span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(Complex));<span class="comment">//malloc(n)</span></span><br><span class="line">pc = <span class="built_in">static_cast</span>&lt;Complex*&gt;(mem);<span class="comment">//转型</span></span><br><span class="line">pc-&gt;Complex::<span class="built_in">Complex</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure></li>
<li>delete<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">String* ps = <span class="keyword">new</span> <span class="built_in">Sting</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="keyword">delete</span> ps;</span><br><span class="line"></span><br><span class="line">String::~<span class="built_in">String</span>(ps);</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(ps)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Complex));</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="vc-的分配举例"><a href="#vc-的分配举例" class="headerlink" title="vc 的分配举例"></a>vc 的分配举例</h5><ul>
<li><p>通用</p>
<ul>
<li><p>4Byte *2 </p>
<pre><code>cookie 头用于操作系统管理内存,上下各有一个所以*2
</code></pre>
</li>
<li><p>实际数据内容</p>
<pre><code>Complex double 4Byte*2 两个double
</code></pre>
</li>
</ul>
</li>
<li><p>debug 模式包含</p>
<ul>
<li>4Byte ，共有8个头</li>
<li>4Byte ，一个用作尾</li>
</ul>
</li>
<li><p>总和</p>
<ul>
<li><p>debug 4<em>2+4</em>8+4+3*2 &#x3D; 52</p>
<p>由于要求是16的倍数，要在调试信息结尾处补00，顾共占64个字节</p>
</li>
<li><p>normal 4<em>2+4</em>2 &#x3D;16</p>
</li>
</ul>
</li>
</ul>
<h3 id="array-new-与-array-delete"><a href="#array-new-与-array-delete" class="headerlink" title="array new 与 array delete"></a>array new 与 array delete</h3><p>vc 还会存储数组的长度.会占用4个byte</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Complex* p = <span class="keyword">new</span> Complex[<span class="number">3</span>]</span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br><span class="line"><span class="comment">//Error </span></span><br><span class="line"><span class="keyword">delete</span> p <span class="comment">//如果不适用中括号,编译器不会调用多次析构函数。数组中的内容。析构函数负责删除自己的动态申请的东西,其引用的内容会引发内存泄漏</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
        <category>cpp</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>堆</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>模板方法</title>
    <url>/2022/04/25/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<!-- <blockquote class="blockquote-center">this is note</blockquote> -->
<ul>
<li>Template Method<ul>
<li><p>特点：</p>
<ul>
<li>稳定的机构，但是子步骤有很多改变的需求。</li>
<li>或者由于固有原因导致无法和任务的整体结构同时实现</li>
</ul>
</li>
<li><p>目的：</p>
<p>在稳定结构的前提下，灵活实现变化或者晚期再来实现需求</p>
</li>
</ul>
</li>
</ul>
<span id="more"></span>
<h1 id="Template-Method"><a href="#Template-Method" class="headerlink" title="Template Method"></a>Template Method</h1><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><ul>
<li>程序库开发人员<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Libaray</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Step1</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Step3</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Step5</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>应用开发人员<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">Step2</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Step4</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Libaray <span class="title">lib</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Application <span class="title">app</span><span class="params">()</span></span>;</span><br><span class="line">    lib.<span class="built_in">Step1</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(app.<span class="built_in">Step2</span>())&#123;</span><br><span class="line">        lib.<span class="built_in">Step3</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        app.<span class="built_in">Step4</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lib.<span class="built_in">Step5</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><ul>
<li><p>程序库开发人员</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Libaray</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">Step1</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">Step2</span>())&#123;</span><br><span class="line">                <span class="built_in">Step3</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">                <span class="built_in">Step4</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">Step5</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Library</span>()&#123;&#125;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Step1</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Step3</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Step5</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">Step2</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Step4</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>应用程序开发人员</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span>:<span class="keyword">public</span> Libaray&#123;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">Step2</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Step4</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Library* pLib = <span class="keyword">new</span> <span class="built_in">Application</span>();</span><br><span class="line">    pLib-&gt;<span class="built_in">run</span>();</span><br><span class="line">    <span class="keyword">delete</span> pLib;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul>
<li>Application call Library 早绑定</li>
<li>Library call Application 晚绑定</li>
</ul>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>  定义一个操作中的算法的骨架 **$\underline{ (稳定) }$**，而将一些步骤延迟 <strong>$\underline{ （变化） }$</strong> 到子类中。Template Method 使得子类可以不改变 <strong>$\underline{ （复用） }$</strong> 一个算法的结构即可重定义 <strong>$\underline{ （override 重写） }$</strong> 该算法的某些特定步骤</p>
<h2 id="UML-表示"><a href="#UML-表示" class="headerlink" title="UML 表示"></a>UML 表示</h2><p><img src="https://s2.loli.net/2022/04/26/3gTFYZB7ERQyApK.jpg" alt="模板方法UML"></p>
<h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><ul>
<li>Template Method 模式，是一种非常基础的设计模式，他用最简洁的机制(虚函数)为很多应用程序框架提供了灵活的扩展点，是代码结构实现复用</li>
<li>除了可以灵活对应子步骤的变化外，“不要调用我”，“让我调用你”的反向控制结构是Template Method的典型</li>
<li>在具体实现方面，被Template Method 调用的虚函数可以有实现也可以没有实现（抽象方法，纯虚方法）他们设置为protected 方法。<ul>
<li>因为虚函数需要在一定的流程内使用才有意义。因此一般并不提供出去</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
        <category>设计模式</category>
        <category>组件协作模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>组件协作模式</tag>
        <tag>模板方法</tag>
      </tags>
  </entry>
  <entry>
    <title>策略模式</title>
    <url>/2022/04/25/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<!-- <blockquote class="blockquote-center">this is note</blockquote> -->
<ul>
<li><p>策略模式</p>
<ul>
<li>解决某些对象使用多种算法。将算法与对象本身节藕，从而实现透明的更改对象的算法</li>
</ul>
</li>
<li><p>模式定义</p>
<p>定义一系列算法，把他们一个个封装起来，并且使他们可互相替换 <strong>（变化）</strong>。改模式使得算法可以独立于使用他的客户程序 <strong>(稳定)</strong> 而变化 <strong>（扩展，子类话）</strong></p>
</li>
</ul>
<span id="more"></span>
<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><ul>
<li>违背开闭原则，需要重新修改<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">TaxBase</span>&#123;</span><br><span class="line">    CN_Tax,</span><br><span class="line">    US_Tax,</span><br><span class="line">    DE_Tax,</span><br><span class="line">    FR_tax<span class="comment">//更改</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SalesOrder</span>&#123;</span><br><span class="line">    TaxBase tax;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">double</span> <span class="title">CalculateTax</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (tax == CN_Tax)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tax == US_Tax)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tax == DE_Tax)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tax == FR_Tax)&#123;<span class="comment">//更改</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaxStrategy</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">Calculate</span><span class="params">(<span class="type">const</span> Context&amp; context)</span></span>=<span class="number">0</span></span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">TaxStrategy</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CNTax</span>:<span class="keyword">public</span> TaxStrategy&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">Calculate</span><span class="params">(<span class="type">const</span> Context&amp; context)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">USTax</span>:<span class="keyword">public</span> TaxStrategy&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">Calculate</span><span class="params">(<span class="type">const</span> Context&amp; context)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DETax</span>:<span class="keyword">public</span> TaxStrategy&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">Calculate</span><span class="params">(<span class="type">const</span> Context&amp; context)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FR_Tax</span>:<span class="keyword">public</span> TaxStrategy&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">Calculate</span><span class="params">(<span class="type">const</span> Context&amp; context)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SalesOrder</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        TaxStrtegy* strategy;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">SalesOrder</span>(StrategyFactory* strategyFactory)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;strategy = strategyFactory-&gt;<span class="built_in">NewStrategy</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">SalesOrder</span>()&#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;strategy;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="type">double</span> <span class="title">CalculateTax</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//....</span></span><br><span class="line">            Context context;</span><br><span class="line">            <span class="type">double</span> val = <span class="keyword">this</span>-&gt;strategy-&gt;<span class="built_in">Calculate</span>(context);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="复用性"><a href="#复用性" class="headerlink" title="复用性"></a>复用性</h3><p>主要指二进制层面的复用性</p>
<h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>  定义一系列算法，把他们一个个封装起来，并且使他们可互相替换 **$\underline{（变化）}$**。改模式使得算法可以独立于使用他的客户程序 <strong>$\underline{(稳定)}$</strong> 而变化 <strong>$\underline{（扩展，子类话）}$</strong></p>
<h2 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h2><p><img src="https://s2.loli.net/2022/04/26/QLJWyHKoeaVh6gj.jpg" alt="策略模式UML图"></p>
<h2 id="要点总结"><a href="#要点总结" class="headerlink" title="要点总结"></a>要点总结</h2><h3 id="Strategy及其子类为组件提供了一系列可重用的算法"><a href="#Strategy及其子类为组件提供了一系列可重用的算法" class="headerlink" title="Strategy及其子类为组件提供了一系列可重用的算法"></a>Strategy及其子类为组件提供了一系列可重用的算法</h3><ul>
<li>从而可以使得类型在运行时方便的根据需要在 <strong>$\underline{运行时}$</strong> 方便的根据需要切换<h3 id="Strategy-提供了用条件语句之外的另一种选择，消除条件判断语句"><a href="#Strategy-提供了用条件语句之外的另一种选择，消除条件判断语句" class="headerlink" title="Strategy 提供了用条件语句之外的另一种选择，消除条件判断语句"></a>Strategy 提供了用条件语句之外的另一种选择，消除条件判断语句</h3></li>
<li>就是在解耦合。含有许多条件判断语句的代码通常都需要Strategy模式<h3 id="如果Strategy-对象没有实例变量，那么上下文可以共享一个Strategy对象"><a href="#如果Strategy-对象没有实例变量，那么上下文可以共享一个Strategy对象" class="headerlink" title="如果Strategy 对象没有实例变量，那么上下文可以共享一个Strategy对象"></a>如果Strategy 对象没有实例变量，那么上下文可以共享一个Strategy对象</h3></li>
<li>从而节省开销</li>
<li>使用单例模式</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
        <category>设计模式</category>
        <category>组件协作模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>组件协作模式</tag>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象的设计原则</title>
    <url>/2022/04/25/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<!-- <blockquote class="blockquote-center">this is note</blockquote> -->
<ul>
<li>依赖倒置原则（DIP）<ul>
<li>高层模块(稳定) 不应该依赖底层模块(不稳定)，二者都应该依赖于抽象(稳定)</li>
<li>抽象(稳定)不应该依赖于实现细节(变化)，实现细节应该依赖于抽象(稳定)</li>
</ul>
</li>
<li>开放封闭原则（OCP）<ul>
<li>对扩展开放</li>
<li>对更改封闭</li>
</ul>
</li>
<li>单一职责原则（SRP）<ul>
<li>一个类应该仅有一个引起他变化的原因</li>
<li>变化的方向隐含着类的责任</li>
</ul>
</li>
<li>Liskov 替换原则(LSP)<ul>
<li>子类必须能够替换他的基类（is-a）</li>
<li>继承表达类型抽象</li>
</ul>
</li>
<li>接口隔离原则（ISP）<ul>
<li>接口小而完备</li>
<li>不应该强迫客户依赖他们不用的方法<span id="more"></span>
<h1 id="依赖倒置原则（DIP）"><a href="#依赖倒置原则（DIP）" class="headerlink" title="依赖倒置原则（DIP）"></a>依赖倒置原则（DIP）</h1></li>
<li>高层模块(稳定) 不应该依赖底层模块(不稳定)，二者都应该依赖于抽象(稳定)</li>
<li>抽象(稳定)不应该依赖于实现细节(变化)，实现细节应该依赖于抽象(稳定)<h1 id="开放封闭原则（OCP）"><a href="#开放封闭原则（OCP）" class="headerlink" title="开放封闭原则（OCP）"></a>开放封闭原则（OCP）</h1></li>
<li>对扩展开放</li>
<li>对更改封闭<h1 id="单一职责原则（SRP）"><a href="#单一职责原则（SRP）" class="headerlink" title="单一职责原则（SRP）"></a>单一职责原则（SRP）</h1></li>
<li>一个类应该仅有一个引起他变化的原因</li>
<li>变化的方向隐含着类的责任<h1 id="Liskov-替换原则-LSP"><a href="#Liskov-替换原则-LSP" class="headerlink" title="Liskov 替换原则(LSP)"></a>Liskov 替换原则(LSP)</h1></li>
<li>子类必须能够替换他的基类（is-a）</li>
<li>继承表达类型抽象<h1 id="接口隔离原则（ISP）"><a href="#接口隔离原则（ISP）" class="headerlink" title="接口隔离原则（ISP）"></a>接口隔离原则（ISP）</h1></li>
<li>接口小而完备</li>
<li>不应该强迫客户依赖他们不用的方法</li>
</ul>
</li>
</ul>
<h1 id="优先使用对象组合，而不是类继承"><a href="#优先使用对象组合，而不是类继承" class="headerlink" title="优先使用对象组合，而不是类继承"></a>优先使用对象组合，而不是类继承</h1><ul>
<li>类继承通常为“白箱复用”，对象组合通常为“黑箱复用”</li>
<li>继承在某种程度上破坏了封装性，子类父类耦合度较高</li>
<li>而对象组合则只要求被组合对象具有良好定义的接口，耦合度低<h1 id="封装变化点"><a href="#封装变化点" class="headerlink" title="封装变化点"></a>封装变化点</h1></li>
<li>使用封装来创建对象之间的分层界，让设计者可以在分解侧的一侧进行修改，而不会对另一侧产生不良的影响，从而实现松耦合</li>
</ul>
<h1 id="针对接口编程，而不是针对实现编程"><a href="#针对接口编程，而不是针对实现编程" class="headerlink" title="针对接口编程，而不是针对实现编程"></a>针对接口编程，而不是针对实现编程</h1><ul>
<li>不将变量类型声明为某个特定的具体类，而是生名为接口</li>
<li>客户程序无需获知对象的具体类型，只需要知道对象的接口</li>
<li>减少系统中各部分的依赖关系，从而实现“高内聚，松耦合”的类型设计方案</li>
</ul>
<h1 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h1><h2 id="从目的"><a href="#从目的" class="headerlink" title="从目的"></a>从目的</h2><ul>
<li><p>创建型模式</p>
<p>  将对象的部分创建工作</p>
</li>
<li><p>结构型</p>
<p>  通过类的继承或者组合，实现灵活的结构，从而应对需求的变化为对象的结构带来的冲击</p>
</li>
<li><p>行为型</p>
<p>  通过类继承或者对象的组合来划分类与对象间的职责，从而应对需求变化为多个交互的对象的冲击</p>
</li>
</ul>
<h2 id="从范围来看"><a href="#从范围来看" class="headerlink" title="从范围来看"></a>从范围来看</h2><ul>
<li>类模式处理类与子类的静态关系</li>
<li>对象模式处理对象间的动态关系</li>
</ul>
<h2 id="从封装变化角度对模式分类"><a href="#从封装变化角度对模式分类" class="headerlink" title="从封装变化角度对模式分类"></a>从封装变化角度对模式分类</h2><h3 id="组件协作"><a href="#组件协作" class="headerlink" title="组件协作"></a>组件协作</h3><ul>
<li>Template Method</li>
<li>Strategy</li>
<li>Observer&#x2F;Event<h3 id="单一职责"><a href="#单一职责" class="headerlink" title="单一职责"></a>单一职责</h3></li>
<li>Decorator</li>
<li>Bridge<h3 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h3></li>
<li>Factory Method</li>
<li>Abstract Method</li>
<li>Prototype</li>
<li>Builder<h3 id="对象性能"><a href="#对象性能" class="headerlink" title="对象性能"></a>对象性能</h3></li>
<li>singleton</li>
<li>Flyweight<h3 id="接口隔离"><a href="#接口隔离" class="headerlink" title="接口隔离"></a>接口隔离</h3></li>
<li>Facade</li>
<li>Proxy</li>
<li>Mediator</li>
<li>Adapter<h3 id="状态变化"><a href="#状态变化" class="headerlink" title="状态变化"></a>状态变化</h3></li>
<li>memento</li>
<li>State<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3></li>
<li>Composite</li>
<li>Iterator</li>
<li>Chain of Resposibility</li>
</ul>
<h3 id="行为模式"><a href="#行为模式" class="headerlink" title="行为模式"></a>行为模式</h3><ul>
<li>Command</li>
<li>Visitor<h3 id="领域问题"><a href="#领域问题" class="headerlink" title="领域问题"></a>领域问题</h3></li>
<li>Interpreter</li>
</ul>
<h2 id="重构获得模式"><a href="#重构获得模式" class="headerlink" title="重构获得模式"></a>重构获得模式</h2><pre><code>好的面向对象设计，可以应对变化，提高复用
</code></pre>
<h3 id="学习方式"><a href="#学习方式" class="headerlink" title="学习方式"></a>学习方式</h3><pre><code>* 寻找变化点，应用设计模式
* 不宜先入为主，没有一步到位的设计模式。重构到模式
</code></pre>
<h4 id="关键技法"><a href="#关键技法" class="headerlink" title="关键技法"></a>关键技法</h4><ul>
<li>静态 -&gt; 动态</li>
<li>早绑定 -&gt; 晚绑定</li>
<li>继承 -&gt; 组合</li>
<li>编译时依赖 -&gt; 运行时依赖</li>
<li>紧耦合 -&gt; 松耦合</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
        <tag>依赖倒置原则（DIP）</tag>
        <tag>开放封闭原则（OCP）</tag>
        <tag>单一职责原则（SRP）</tag>
        <tag>Liskov 替换原则(LSP)</tag>
        <tag>接口隔离原则（ISP）</tag>
      </tags>
  </entry>
</search>
