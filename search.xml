<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>cpp 11&amp;14 default&amp;delete 以及template</title>
    <url>/2022/04/13/cpp-11-14-default&amp;delete%20%E4%BB%A5%E5%8F%8Atemplate/</url>
    <content><![CDATA[<!-- <blockquote class="blockquote-center">this is note</blockquote> -->
<ul>
<li>default&amp;delete<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Zoo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//big five 可以运用到default，其它函数上会报错</span></span><br><span class="line">        <span class="built_in">Zoo</span>(<span class="type">int</span> i1,<span class="type">int</span> i2):<span class="built_in">d1</span>(i1),<span class="built_in">d2</span>(i2)&#123;&#125;<span class="comment">//构造函数</span></span><br><span class="line">        <span class="built_in">Zoo</span>(<span class="type">const</span> Zoo&amp;)=<span class="keyword">delete</span>;<span class="comment">//拷贝构造函数，不要这个函数,不可以使用</span></span><br><span class="line">        <span class="built_in">Zoo</span>(Zoo&amp;&amp;)=<span class="keyword">default</span>;<span class="comment">//右值引用，使用编译器默认的版本</span></span><br><span class="line">        Zoo&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Zoo&amp;)=<span class="keyword">default</span>;<span class="comment">//拷贝赋值</span></span><br><span class="line">        Zoo&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Zoo&amp;&amp;)=<span class="keyword">delete</span>;<span class="comment">//移动赋值</span></span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Zoo</span>()&#123;&#125;;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> d1,d2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>alias Template<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Vec=std::vector&lt;T,MyAlloc&lt;T&gt;&gt;;</span><br><span class="line">Vec&lt;<span class="type">int</span>&gt; coll;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Vec<span class="string">&lt;T&gt;</span> template<span class="string">&lt;typename T&gt;</span> std::vector<span class="string">&lt;T,MyAlloc&lt;T&gt;</span>&gt;;</span></span><br><span class="line">Vec&lt;<span class="type">int</span>&gt; coll;</span><br><span class="line"><span class="comment">//template&lt;typename int&gt; std::vector&lt;int,MyAlloc&lt;int&gt;&gt; 是这样的效果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用typedef,因为typedef 不接收参数,只能使用如下所示</span></span><br><span class="line"><span class="keyword">typedef</span> std::vector&lt;<span class="type">int</span>,MyAlloc&lt;<span class="type">int</span>&gt;&gt; Vec;</span><br></pre></td></tr></table></figure></li>
<li>template template parameter</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">template</span>&lt;<span class="keyword">class</span>&gt; <span class="keyword">class</span> <span class="title class_">Container</span>&gt;</span><br><span class="line"><span class="comment">//template&lt;typename T,template&lt;typename&gt; class Container&gt;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XCIs</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Container&lt;T&gt; c;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">XCIs</span>()&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">long</span> i=<span class="number">0</span>;i&lt;SIZE;i++)&#123;</span><br><span class="line">                c.<span class="built_in">insert</span>(c.<span class="built_in">end</span>(),<span class="built_in">T</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">output_static_data</span>(<span class="built_in">T</span>());</span><br><span class="line">            <span class="function">Container&lt;T&gt; <span class="title">c1</span><span class="params">(c)</span></span>;</span><br><span class="line">            <span class="function">Container&lt;T&gt; <span class="title">c2</span><span class="params">(std::move(c))</span></span>;</span><br><span class="line">            c1.<span class="built_in">swap</span>(c2);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<span id="more"></span>
<h1 id="default-amp-delete"><a href="#default-amp-delete" class="headerlink" title="default&amp;delete"></a>default&amp;delete</h1><h2 id="何时需要写出big-5-函数，类中含有指针时需要写出"><a href="#何时需要写出big-5-函数，类中含有指针时需要写出" class="headerlink" title="何时需要写出big 5 函数，类中含有指针时需要写出"></a><strong>何时需要写出big 5 函数，类中含有指针时需要写出</strong></h2><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span> i):_i(i)&#123;&#125;</span><br><span class="line">    <span class="built_in">Foo</span>()=<span class="keyword">default</span>;<span class="comment">//默认构造</span></span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">const</span> Foo&amp;x):_i(x.i)&#123;&#125;</span><br><span class="line">    <span class="comment">// Foo(const Foo&amp;)=default;//存在重名函数</span></span><br><span class="line">    <span class="comment">// Foo(const Foo&amp;)=delete;//与函数定义冲突</span></span><br><span class="line">    Foo&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Foo&amp;x)&#123;_i=x.i;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">    <span class="comment">//Foo&amp; operator=(const Foo&amp; x)=default;//赋值构造函数</span></span><br><span class="line">    <span class="comment">//Foo&amp; operator=(const Foo&amp; x)=delete;</span></span><br><span class="line">    <span class="comment">// void func1()=default;//[Error] &#x27;void Foo::func1()&#x27; 没有默认的函数实现</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>=<span class="keyword">delete</span> </span><br><span class="line">    <span class="comment">// ~Foo()=delete;//析构函数不能被delete</span></span><br><span class="line">    ~<span class="built_in">Foo</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Foo <span class="title">f1</span><span class="params">(<span class="number">5</span>)</span><span class="comment">//构造</span></span></span><br><span class="line"><span class="function">Foo f2</span>;<span class="comment">//如果没有默认无参数构造会报错</span></span><br><span class="line"><span class="function">Foo <span class="title">f3</span><span class="params">(f1)</span><span class="comment">// 如果拷贝构造呗delete会报错</span></span></span><br><span class="line"><span class="function">f3</span>=f2 <span class="comment">//如果赋值构造被delete 会被报错</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NoCopy</span>&#123;</span><br><span class="line">    <span class="built_in">NoCopy</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">NoCopy</span>(<span class="type">const</span> NoCopy&amp;)=<span class="keyword">delete</span>; <span class="comment">//禁止拷贝构造</span></span><br><span class="line">    NoCopy &amp;<span class="keyword">operator</span>=(<span class="type">const</span> NoCopy&amp;)=<span class="keyword">delete</span> <span class="comment">//禁止赋值构造</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> PrivateCopy&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">PrivateCopy</span>(<span class="type">const</span> PrivateCopy&amp;);</span><br><span class="line">    PrivateCopy &amp;<span class="keyword">operator</span>=(<span class="type">const</span> PrivateCopy&amp;);</span><br><span class="line">    <span class="comment">//私有函数可被自己以及友元使用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> boost&#123;</span><br><span class="line">    <span class="keyword">namespace</span> noncopyable_ &#123;<span class="comment">//</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">noncopyable</span>&#123;</span><br><span class="line">            <span class="keyword">protected</span>:</span><br><span class="line">            <span class="built_in">noncopyable</span>()&#123;&#125;</span><br><span class="line">            ~<span class="built_in">noncopyable</span>()&#123;&#125;</span><br><span class="line">            <span class="keyword">private</span>:</span><br><span class="line">            <span class="built_in">noncopyable</span>(<span class="type">const</span> noncopyable&amp;);</span><br><span class="line">            <span class="type">const</span> noncopyable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> noncopuable&amp;);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于集成,以实现不允许拷贝的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span>&#123;&#125;;</span><br><span class="line"><span class="comment">//当函数被调用后，编译器会生成对应的默认函数,都是内联函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Empty</span>&#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment">//=======================//</span></span><br><span class="line">        <span class="comment">//*********************//</span></span><br><span class="line">        <span class="comment">// Empty e1; 使用默认构造,用于存放背后的代码，例如子类调用父类的构造函数</span></span><br><span class="line">        <span class="built_in">Empty</span>()&#123;...&#125;</span><br><span class="line">        ~<span class="built_in">Empty</span>()&#123;&#125;</span><br><span class="line">        <span class="comment">//*********************//</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//=======================//</span></span><br><span class="line">        <span class="comment">//*********************//</span></span><br><span class="line">        <span class="comment">// Empty e2(e1); 使用拷贝构造</span></span><br><span class="line">        <span class="built_in">Empty</span>(<span class="type">const</span> Empty&amp; rhs)&#123;...&#125;</span><br><span class="line">        <span class="comment">//*********************//</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//=======================//</span></span><br><span class="line">        <span class="comment">//*********************//</span></span><br><span class="line">        <span class="comment">// Empty e2(e1); 使用拷贝构造</span></span><br><span class="line">        <span class="built_in">Empty</span>(<span class="type">const</span> Empty&amp; rhs)&#123;...&#125;</span><br><span class="line">        <span class="comment">//*********************//</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//=======================//</span></span><br><span class="line">        <span class="comment">//*********************//</span></span><br><span class="line">        <span class="comment">// e2 = e1 生成赋值构造</span></span><br><span class="line">        Empty&amp; <span class="keyword">operator</span> = (<span class="type">const</span> Empty&amp; rhs)&#123;&#125; </span><br><span class="line">        <span class="comment">//*********************//</span></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Alias-别名"><a href="#Alias-别名" class="headerlink" title="Alias(别名)"></a>Alias(别名)</h1><h2 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Vec=std::vector&lt;T,MyAlloc&lt;T&gt;&gt;;</span><br><span class="line">Vec&lt;<span class="type">int</span>&gt; coll;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Vec<span class="string">&lt;T&gt;</span> template<span class="string">&lt;typename T&gt;</span> std::vector<span class="string">&lt;T,MyAlloc&lt;T&gt;</span>&gt;;</span></span><br><span class="line">Vec&lt;<span class="type">int</span>&gt; coll;</span><br><span class="line"><span class="comment">//template&lt;typename int&gt; std::vector&lt;int,MyAlloc&lt;int&gt;&gt; 是这样的效果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用typedef,因为typedef 不接收参数,只能使用如下所示</span></span><br><span class="line"><span class="keyword">typedef</span> std::vector&lt;<span class="type">int</span>,MyAlloc&lt;<span class="type">int</span>&gt;&gt; Vec;</span><br></pre></td></tr></table></figure>

<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 函数目的，测试当前类型，是否都禁止了移动构造函数</span></span><br><span class="line"><span class="comment">// 实现这样的效果需要使用 模板模板参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_moveable</span><span class="params">(Container cntr,T elem)</span></span>&#123;</span><br><span class="line">    Container&lt;T&gt; c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> i=<span class="number">0</span>;i&lt;SIZE;++i)</span><br><span class="line">        c.<span class="built_in">insert</span>(c.<span class="built_in">end</span>(),<span class="built_in">T</span>());</span><br><span class="line">    <span class="built_in">output_static_data</span>(<span class="built_in">T</span>());</span><br><span class="line">    <span class="function">Container&lt;T&gt; <span class="title">c1</span><span class="params">(c)</span></span>;</span><br><span class="line">    <span class="function">Container&lt;T&gt; <span class="title">c2</span><span class="params">(std::move(c))</span></span>;</span><br><span class="line">    c1.<span class="built_in">swap</span>(c2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test_moveable</span>(list,MyString);</span><br><span class="line"><span class="built_in">test_moveable</span>(list,MyStrNoMove);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改进</span></span><br><span class="line"><span class="comment">//Error expected nested-name-specifier before is Container</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container,<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_moveable</span><span class="params">(Container cntr,T elem)</span></span>&#123;</span><br><span class="line">    <span class="keyword">typename</span> Container&lt;T&gt; c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> i=<span class="number">0</span>;i&lt;SIZE;++i)</span><br><span class="line">        c.<span class="built_in">insert</span>(c.<span class="built_in">end</span>(),<span class="built_in">T</span>());</span><br><span class="line">    <span class="built_in">output_static_data</span>(<span class="built_in">T</span>());</span><br><span class="line">    <span class="function">Container&lt;T&gt; <span class="title">c1</span><span class="params">(c)</span></span>;</span><br><span class="line">    <span class="function">Container&lt;T&gt; <span class="title">c2</span><span class="params">(std::move(c))</span></span>;</span><br><span class="line">    c1.<span class="built_in">swap</span>(c2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test_moveable</span>(<span class="built_in">list</span>(),<span class="built_in">MyString</span>());</span><br><span class="line"><span class="built_in">test_moveable</span>(<span class="built_in">list</span>(),<span class="built_in">MyStrNoMove</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//最终版本</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_moveable</span><span class="params">(Container cntr)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取出容器的内部的类型</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;<span class="keyword">typename</span> Container::iterator&gt;::<span class="function">value_type <span class="title">Valtype</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">typename</span> Container&lt;T&gt; c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> i=<span class="number">0</span>;i&lt;SIZE;++i)</span><br><span class="line">        c.<span class="built_in">insert</span>(c.<span class="built_in">end</span>(),<span class="built_in">Valtype</span>());</span><br><span class="line">    <span class="built_in">output_static_data</span>(*(c.<span class="built_in">begin</span>()));<span class="comment">// 查看哪些静态数据被频繁的调用</span></span><br><span class="line">    <span class="function">Container&lt;T&gt; <span class="title">c1</span><span class="params">(c)</span></span>;</span><br><span class="line">    <span class="function">Container&lt;T&gt; <span class="title">c2</span><span class="params">(std::move(c))</span></span>;</span><br><span class="line">    c1.<span class="built_in">swap</span>(c2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test_moveable</span>(<span class="built_in">list</span>&lt;MyString&gt;());</span><br><span class="line"><span class="built_in">test_moveable</span>(<span class="built_in">list</span>&lt;MyStrNoMove&gt;());</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用RB-tree 时，元素需提供operator&lt;</span></span><br><span class="line"><span class="comment">//使用hashTable 时,元素需提供 operator &lt;,hash function&gt;</span></span><br><span class="line"><span class="comment">//使用multi-容器是，元素还需提供operator ==</span></span><br></pre></td></tr></table></figure>

<h2 id="模板模板参数"><a href="#模板模板参数" class="headerlink" title="模板模板参数"></a>模板模板参数</h2><h3 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span>&gt; <span class="keyword">class</span></span><br><span class="line"><span class="comment">// template&lt;class&gt; class 表示该位置是一个模板类</span></span><br><span class="line"><span class="comment">// template&lt;typename&gt; 效果相同</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">template</span>&lt;<span class="keyword">class</span>&gt; <span class="keyword">class</span> <span class="title class_">Container</span>&gt;</span><br><span class="line"><span class="comment">//template&lt;typename T,template&lt;typename&gt; class Container&gt;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XCIs</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Container&lt;T&gt; c;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">XCIs</span>()&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">long</span> i=<span class="number">0</span>;i&lt;SIZE;i++)&#123;</span><br><span class="line">                c.<span class="built_in">insert</span>(c.<span class="built_in">end</span>(),<span class="built_in">T</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">output_static_data</span>(<span class="built_in">T</span>());</span><br><span class="line">            <span class="function">Container&lt;T&gt; <span class="title">c1</span><span class="params">(c)</span></span>;</span><br><span class="line">            <span class="function">Container&lt;T&gt; <span class="title">c2</span><span class="params">(std::move(c))</span></span>;</span><br><span class="line">            c1.<span class="built_in">swap</span>(c2);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">XCIS&lt;Mystring,vector&gt;c1; <span class="comment">// 使用的时候报错,因为模板需要两个参数，而使用时只有一个模板册数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp,<span class="keyword">typename</span> _Alloc = std::allocator&lt;_Tp&gt;&gt;<span class="comment">//模板函数的默认值，第二个参数以第一个参数为参数</span></span><br><span class="line"><span class="keyword">class</span> vector :<span class="keyword">protected</span> _Vector_vase&lt;_tp,_Alloc&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终实现</span></span><br><span class="line"><span class="comment">// 不可以在函数体内声明</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Vec=vector&lt;T,allocator&lt;T&gt;&gt;;</span><br><span class="line">XCIS&lt;Mystring,Vec&gt;c1;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
        <category>cpp</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>default</tag>
        <tag>delete</tag>
        <tag>Alias(别名)</tag>
        <tag>alias template</tag>
        <tag>模板模板参数</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp 11&amp;14 可变参数模板与空指针,auto</title>
    <url>/2022/03/20/cpp-11-14-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF%E4%B8%8E%E7%A9%BA%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<!-- <blockquote class="blockquote-center">this is note</blockquote> -->
<ul>
<li><p>Variadic Templates(可变参数模板)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可变参数模板</span></span><br><span class="line"><span class="comment">// 无参数函数，用于结束调用 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printX</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 包含一个参数固定参数的可变模板函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... types&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printX</span><span class="params">(<span class="type">const</span> T&amp; firstArg,<span class="type">const</span> Types&amp;... args)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt; firstArg&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">printX</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>空指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;&#125;<span class="comment">//function1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">void</span>* a)</span></span>&#123;&#125;<span class="comment">//funtion2</span></span><br><span class="line"><span class="built_in">f</span>(<span class="literal">NULL</span>);<span class="comment">//call function1 </span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">0</span>);<span class="comment">//call function1 </span></span><br><span class="line"><span class="built_in">f</span>(<span class="literal">nullptr</span>);<span class="comment">//call function2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>模板函数书写变化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;<span class="comment">//</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="comment">//Ok since c++11</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1 id="cpp-11-amp-14-可变参数模板与空指针-auto"><a href="#cpp-11-amp-14-可变参数模板与空指针-auto" class="headerlink" title="cpp 11&amp;14 可变参数模板与空指针,auto"></a>cpp 11&amp;14 可变参数模板与空指针,auto</h1></li>
</ul>
<h2 id="Variadic-Templates-可变参数模板"><a href="#Variadic-Templates-可变参数模板" class="headerlink" title="Variadic Templates(可变参数模板)"></a>Variadic Templates(可变参数模板)</h2><h3 id="帮助我们实现递归"><a href="#帮助我们实现递归" class="headerlink" title="帮助我们实现递归"></a><strong>帮助我们实现递归</strong></h3><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可变参数模板</span></span><br><span class="line"><span class="comment">// 无参数函数，用于结束调用 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printX</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 包含一个参数固定参数的可变模板函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... types&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// type2 和 type 3 可以并存 2为特</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// type2 接收1个和各式各样的入参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printX</span><span class="params">(<span class="type">const</span> T&amp; firstArg,<span class="type">const</span> Types&amp;... args)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt; firstArg&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt; <span class="keyword">sizeof</span>...(args...)&lt;&lt;endl;<span class="comment">// 可以使用sizeof...(args) 获取args的个数</span></span><br><span class="line">    <span class="built_in">printX</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// type3 接收各式各样的入参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printX</span><span class="params">(<span class="type">const</span> Types&amp;... args)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt; firstArg&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt; <span class="keyword">sizeof</span>...(args...)&lt;&lt;endl;<span class="comment">// 可以使用sizeof...(args) 获取args的个数</span></span><br><span class="line">    <span class="built_in">printX</span>(args...);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="cpp库函数举例"><a href="#cpp库函数举例" class="headerlink" title="cpp库函数举例"></a>cpp库函数举例</h4><h5 id="calculate-Hash"><a href="#calculate-Hash" class="headerlink" title="calculate Hash"></a>calculate Hash</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// another file</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">hash_combine</span><span class="params">(<span class="type">size_t</span>&amp; seed,<span class="type">const</span> T&amp; val)</span></span>&#123;</span><br><span class="line">    seed^=std::<span class="built_in">hash</span>&lt;T&gt;()(val)+<span class="number">0x9e3779b9</span>+(seed&lt;&lt;<span class="number">6</span>)+(seed&gt;&gt;<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// call sequence 1-&gt;2-&gt;recurse-&gt;3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// function 1</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>.. Type&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">hash_val</span><span class="params">(<span class="type">size_t</span>&amp; seed, <span class="type">const</span> T&amp; val,<span class="type">const</span> Types&amp;... args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">hash_combine</span>(seed,val);</span><br><span class="line">    <span class="built_in">hash_val</span>(seed,args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// function 2</span></span><br><span class="line"><span class="comment">// auxiliary generic function</span></span><br><span class="line"><span class="keyword">template</span> &lt;typeame... Types&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">size_t</span> <span class="title">hash_val</span><span class="params">(<span class="type">const</span> Types&amp;... args)</span></span>&#123;</span><br><span class="line">    <span class="type">size_t</span> seed=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">hash_val</span>(seed,args);</span><br><span class="line">    <span class="keyword">return</span> seed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function 3</span></span><br><span class="line"><span class="comment">// auxiliary generic function</span></span><br><span class="line"><span class="keyword">template</span> &lt;typeame T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">size_t</span> <span class="title">hash_val</span><span class="params">(<span class="type">size_t</span>&amp; seed,<span class="type">const</span> T&amp; val)</span></span>&#123;</span><br><span class="line">    <span class="built_in">hash_combine</span>(seed,val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="tuple-realise"><a href="#tuple-realise" class="headerlink" title="tuple realise"></a>tuple realise</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Values&gt;<span class="keyword">class</span> <span class="title class_">tuple</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;<span class="keyword">class</span> <span class="title class_">tuple</span>&lt;&gt;&#123;&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head,<span class="keyword">typename</span>... Tail&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tuple</span>&lt;Head,Tail...&gt;:<span class="keyword">private</span> typle&lt;Tail...&gt;&#123;</span><br><span class="line">    <span class="keyword">typedef</span> typle&lt;Tail...&gt; inherited;</span><br><span class="line"> </span><br><span class="line">pubic:</span><br><span class="line">    <span class="built_in">tuple</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">tuple</span>(Head v,Tail... vtail):<span class="built_in">m_head</span>(v),<span class="built_in">inherited</span>(vtail...)&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">typename</span> Head::type <span class="title">head</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_head;&#125;</span><br><span class="line"><span class="function">inherited&amp; <span class="title">tail</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">Head m_head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="tuple-sample"><a href="#tuple-sample" class="headerlink" title="tuple sample"></a>tuple sample</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">tuple&lt;<span class="type">int</span>,<span class="type">float</span>,string&gt; <span class="title">t</span><span class="params">(<span class="number">41</span>,<span class="number">6.3</span>,<span class="string">&quot;nico&quot;</span>)</span></span>;</span><br><span class="line">t.<span class="built_in">head</span>();<span class="comment">//-&gt;4.1</span></span><br><span class="line">t.<span class="built_in">tail</span>().<span class="built_in">head</span>()<span class="comment">//-&gt;6.3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="nullptr-空指针"><a href="#nullptr-空指针" class="headerlink" title="nullptr(空指针)"></a>nullptr(空指针)</h2><h3 id="用于区分空指针与NULL"><a href="#用于区分空指针与NULL" class="headerlink" title="用于区分空指针与NULL"></a><strong>用于区分空指针与NULL</strong></h3><h3 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;&#125;<span class="comment">//function1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">void</span>* a)</span></span>&#123;&#125;<span class="comment">//funtion2</span></span><br><span class="line"><span class="built_in">f</span>(<span class="literal">NULL</span>);<span class="comment">//call function1 </span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">0</span>);<span class="comment">//call function1 </span></span><br><span class="line"><span class="built_in">f</span>(<span class="literal">nullptr</span>);<span class="comment">//call function2</span></span><br></pre></td></tr></table></figure>
<p><strong>file_name</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> <span class="keyword">define</span>(__cplusplus)&amp;&amp; __cplusplus&gt;=201103L</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _GXX_NULLPTR_T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GXX_NULLPTR_T</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(<span class="literal">nullptr</span>)</span> <span class="type">nullptr_t</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// ...</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="keyword">endif</span></span></span></span><br></pre></td></tr></table></figure>

<h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><h3 id="在类型繁琐以及无法确定返回参数类型时使用-lambda-function"><a href="#在类型繁琐以及无法确定返回参数类型时使用-lambda-function" class="headerlink" title="在类型繁琐以及无法确定返回参数类型时使用(lambda function)"></a><strong>在类型繁琐以及无法确定返回参数类型时使用(lambda function)</strong></h3><h3 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;string&gt; v;</span><br><span class="line"><span class="keyword">auto</span> pos=v.<span class="built_in">begin</span>();<span class="comment">// 类型写起来繁琐</span></span><br><span class="line"><span class="keyword">auto</span> i=[](<span class="type">int</span> x)-&gt;<span class="type">bool</span>&#123; <span class="comment">// lambda</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
        <category>cpp</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>cpp11&amp;14</tag>
        <tag>可变参数模板</tag>
        <tag>nullptr</tag>
        <tag>auto</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp 11&amp;14 统一初始化方式以及initializer_list,for</title>
    <url>/2022/04/13/cpp-11-14-%E7%BB%9F%E4%B8%80%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F%E4%BB%A5%E5%8F%8Ainitializer-list/</url>
    <content><![CDATA[<!-- <blockquote class="blockquote-center">this is note</blockquote> -->
<ul>
<li>一致初始化<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> values[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">vector&lt;string&gt; cities&#123;</span><br><span class="line">    <span class="string">&quot;Berlin&quot;</span>,<span class="string">&quot;New York&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">complex&lt;<span class="type">double</span>&gt; c&#123;<span class="number">3.0</span>,<span class="number">4.0</span>&#125;</span><br></pre></td></tr></table></figure></li>
<li>initializer_list<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//***********************//</span></span><br><span class="line"><span class="comment">//initializer_list 传递的是引用,拷贝是浅拷贝</span></span><br><span class="line"><span class="comment">//***********************//</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;<span class="comment">// 会被编译器构造成一个initializer_list</span></span><br><span class="line"><span class="comment">//如果函数只接收initializer_list 则调用者要自己准备一包initializer_list,来使用</span></span><br><span class="line"><span class="comment">//如果目标函数不接受initializer_list，会被编译器分开来传入</span></span><br><span class="line"><span class="type">int</span> i;<span class="comment">//i的值是未定义</span></span><br><span class="line"><span class="type">int</span> j&#123;&#125;;<span class="comment">//设置初值为0</span></span><br><span class="line"><span class="type">int</span>* p;<span class="comment">//未定义初值</span></span><br><span class="line"><span class="type">int</span>* q&#123;&#125;;<span class="comment">//设置初值为nullptr</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">x1</span><span class="params">(<span class="number">5.3</span>)</span></span>; <span class="comment">// x1=5</span></span><br><span class="line"><span class="type">int</span> x2 = <span class="number">5.3</span>;<span class="comment">//x2=5</span></span><br><span class="line"><span class="type">int</span> x3&#123;<span class="number">5.0</span>&#125;;<span class="comment">//Error:narrowing ||-&gt; GCC Warning</span></span><br><span class="line"><span class="type">int</span> x4 =&#123;<span class="number">5.3</span>&#125;; <span class="comment">// Error:narrowing ||-&gt; GCC Warning</span></span><br><span class="line"><span class="type">char</span> c1&#123;<span class="number">7</span>&#125;;<span class="comment">//ok</span></span><br><span class="line"><span class="type">char</span> c2&#123;<span class="number">99999</span>&#125;;<span class="comment">//Error:narrowing ||-&gt; GCC Warning</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v1&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;<span class="comment">//ok</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v1&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5.5</span>&#125;;<span class="comment">//Error:narrowing ||-&gt; GCC Warning</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">max</span>(&#123;<span class="built_in">stirng</span>(<span class="string">&quot;Ace&quot;</span>),<span class="built_in">string</span>(<span class="string">&quot;Stacy&quot;</span>),<span class="built_in">stirng</span>(<span class="string">&quot;qqq&quot;</span>),<span class="built_in">string</span>(<span class="string">&quot;ppp&quot;</span>)&#125;) <span class="comment">//函数可以接收initializer_list，作为入参</span></span><br><span class="line"><span class="built_in">min</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;)<span class="comment">//函数可以接收initializer_list，作为入参</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1 id="cpp-11-amp-14-统一初始化方式以及initializer-list"><a href="#cpp-11-amp-14-统一初始化方式以及initializer-list" class="headerlink" title="cpp 11&amp;14 统一初始化方式以及initializer_list"></a>cpp 11&amp;14 统一初始化方式以及initializer_list</h1><h2 id="一致初始化"><a href="#一致初始化" class="headerlink" title="一致初始化"></a>一致初始化</h2><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> values[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">vector&lt;string&gt; cities&#123;</span><br><span class="line">    <span class="string">&quot;Berlin&quot;</span>,<span class="string">&quot;New York&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">complex&lt;<span class="type">double</span>&gt; c&#123;<span class="number">3.0</span>,<span class="number">4.0</span>&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="initializer-list"><a href="#initializer-list" class="headerlink" title="initializer_list"></a>initializer_list</h2><h3 id="接受任意个参数，但类型要相同"><a href="#接受任意个参数，但类型要相同" class="headerlink" title="接受任意个参数，但类型要相同"></a><strong>接受任意个参数，但类型要相同</strong></h3><h3 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//***********************//</span></span><br><span class="line"><span class="comment">//initializer_list 传递的是引用,拷贝是浅拷贝</span></span><br><span class="line"><span class="comment">//***********************//</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i;<span class="comment">//i的值是未定义</span></span><br><span class="line"><span class="type">int</span> j&#123;&#125;;<span class="comment">//设置初值为0</span></span><br><span class="line"><span class="type">int</span>* p;<span class="comment">//未定义初值</span></span><br><span class="line"><span class="type">int</span>* q&#123;&#125;;<span class="comment">//设置初值为nullptr</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">x1</span><span class="params">(<span class="number">5.3</span>)</span></span>; <span class="comment">// x1=5</span></span><br><span class="line"><span class="type">int</span> x2 = <span class="number">5.3</span>;<span class="comment">//x2=5</span></span><br><span class="line"><span class="type">int</span> x3&#123;<span class="number">5.0</span>&#125;;<span class="comment">//Error:narrowing ||-&gt; GCC Warning</span></span><br><span class="line"><span class="type">int</span> x4 =&#123;<span class="number">5.3</span>&#125;; <span class="comment">// Error:narrowing ||-&gt; GCC Warning</span></span><br><span class="line"><span class="type">char</span> c1&#123;<span class="number">7</span>&#125;;<span class="comment">//ok</span></span><br><span class="line"><span class="type">char</span> c2&#123;<span class="number">99999</span>&#125;;<span class="comment">//Error:narrowing ||-&gt; GCC Warning</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v1&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;<span class="comment">//ok</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v1&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5.5</span>&#125;;<span class="comment">//Error:narrowing ||-&gt; GCC Warning</span></span><br></pre></td></tr></table></figure>
<h4 id="sample-正确"><a href="#sample-正确" class="headerlink" title="sample 正确"></a>sample 正确</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">P</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">P</span>(<span class="type">int</span> a,<span class="type">int</span> b)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;P(int,int),a=&quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; b=&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">P</span>(initializer_list&lt;<span class="type">int</span>&gt; initlist)&#123;</span><br><span class="line">         cout&lt;&lt;<span class="string">&quot;P(initializer_list&lt;int&gt;),values=&quot;</span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">auto</span> i:initializer_list)&#123;</span><br><span class="line">             cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">         cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">P <span class="title">p</span><span class="params">(<span class="number">77</span>,<span class="number">5</span>)</span></span>;<span class="comment">//P(int,int);</span></span><br><span class="line">P q&#123;<span class="number">77</span>,<span class="number">4</span>&#125;;<span class="comment">//P(initializer_list&lt;int&gt;); 形成一包,所以调用的是P(initializer_list&lt;int&gt;)</span></span><br><span class="line">P r&#123;<span class="number">77</span>,<span class="number">5</span>,<span class="number">42</span>&#125;;<span class="comment">//P(initializer_list&lt;int&gt;);</span></span><br><span class="line">P s=&#123;<span class="number">77</span>,<span class="number">5</span>&#125;;<span class="comment">//P(initializer_list&lt;int&gt;);</span></span><br></pre></td></tr></table></figure>

<h4 id="sample-错误"><a href="#sample-错误" class="headerlink" title="sample 错误"></a>sample 错误</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">P</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">P</span>(<span class="type">int</span> a,<span class="type">int</span> b)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;P(int,int),a=&quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; b=&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">P <span class="title">p</span><span class="params">(<span class="number">77</span>,<span class="number">5</span>)</span></span>;<span class="comment">//P(int,int);</span></span><br><span class="line">P q&#123;<span class="number">77</span>,<span class="number">4</span>&#125;;<span class="comment">//P(int,int);</span></span><br><span class="line">P r&#123;<span class="number">77</span>,<span class="number">5</span>,<span class="number">42</span>&#125;;<span class="comment">//Error</span></span><br><span class="line">P s=&#123;<span class="number">77</span>,<span class="number">5</span>&#125;;<span class="comment">//P(initializer_list&lt;int&gt;);</span></span><br></pre></td></tr></table></figure>
<h4 id="explicit-当构造函数含有多个入参时"><a href="#explicit-当构造函数含有多个入参时" class="headerlink" title="explicit 当构造函数含有多个入参时"></a>explicit 当构造函数含有多个入参时</h4><h5 id="explicit-应用在只有一个参数在构造函数时"><a href="#explicit-应用在只有一个参数在构造函数时" class="headerlink" title="explicit 应用在只有一个参数在构造函数时"></a>explicit 应用在只有一个参数在构造函数时</h5><h6 id="old-version"><a href="#old-version" class="headerlink" title="old version"></a>old version</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//*******************************</span></span><br><span class="line"><span class="comment">// 隐含调用含有一个参数的构造函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Complex</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> real,imag;</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">int</span> re,<span class="type">int</span> im=<span class="number">0</span>):<span class="built_in">real</span>(re),<span class="built_in">imag</span>(im)&#123;&#125;</span><br><span class="line">    Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>((real+x.real),(imag+x.imag))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Complex <span class="built_in">c1</span>(<span class="number">12</span>,<span class="number">5</span>);</span><br><span class="line">Complex c2=c1+<span class="number">5</span>;<span class="comment">// 隐含调用含有一个参数的构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//***************************</span></span><br><span class="line"><span class="comment">//禁止隐含调用构造，除非明确指出</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Complex</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> real,imag;</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">int</span> re,<span class="type">int</span> im=<span class="number">0</span>):<span class="built_in">real</span>(re),<span class="built_in">imag</span>(im)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">explicit</span></span><br><span class="line">    Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>((real+x.real),(imag+x.imag))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Complex <span class="built_in">c1</span>(<span class="number">12</span>,<span class="number">5</span>);</span><br><span class="line"><span class="comment">//禁止隐含调用构造，除非明确指出</span></span><br><span class="line">Complex c2=c1+<span class="number">5</span>;<span class="comment">// Erorr no match for &#x27;operator+&#x27;</span></span><br></pre></td></tr></table></figure>
<h6 id="c11-version"><a href="#c11-version" class="headerlink" title="c11 version"></a>c11 version</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">P</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">P</span>(<span class="type">int</span> a,<span class="type">int</span> b)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;P(int,int),a=&quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; b=&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">P</span>(initializer_list&lt;<span class="type">int</span>&gt; initlist)&#123;</span><br><span class="line">         cout&lt;&lt;<span class="string">&quot;P(initializer_list&lt;int&gt;),values=&quot;</span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">auto</span> i:initializer_list)&#123;</span><br><span class="line">             cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">         cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> </span></span><br><span class="line"><span class="function">    <span class="title">P</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;P(int,int),a=&quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; b=&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fp</span><span class="params">(<span class="type">const</span> P&amp;)</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">P <span class="title">p</span><span class="params">(<span class="number">77</span>,<span class="number">5</span>)</span></span>;<span class="comment">//P(int,int);</span></span><br><span class="line">P q&#123;<span class="number">77</span>,<span class="number">4</span>&#125;;<span class="comment">//P(initializer_list&lt;int&gt;); 形成一包,所以调用的是P(initializer_list&lt;int&gt;)</span></span><br><span class="line">P r&#123;<span class="number">77</span>,<span class="number">5</span>,<span class="number">42</span>&#125;;<span class="comment">//P(initializer_list&lt;int&gt;);</span></span><br><span class="line">P s=&#123;<span class="number">77</span>,<span class="number">5</span>&#125;;<span class="comment">//P(initializer_list&lt;int&gt;);</span></span><br><span class="line"><span class="comment">//Error ****************//</span></span><br><span class="line">P p5 = &#123;<span class="number">77</span>,<span class="number">88</span>,<span class="number">3</span>&#125;<span class="comment">//Error converting to &#x27;p&#x27; from initilizer list would use explicit constructor</span></span><br><span class="line"><span class="comment">//Error ****************//</span></span><br><span class="line">P p6 = &#123;<span class="number">77</span>,<span class="number">88</span>,<span class="number">3</span>,<span class="number">8</span>&#125;<span class="comment">//P(initializer_list&lt;int&gt;);</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">fp</span>(&#123;<span class="number">11</span>,<span class="number">22</span>&#125;)<span class="comment">//P(initializer_list&lt;int&gt;)</span></span><br><span class="line"><span class="comment">//Error ****************//</span></span><br><span class="line"><span class="built_in">fp</span>(&#123;<span class="number">47</span>,<span class="number">11</span>,<span class="number">3</span>&#125;)<span class="comment">//Error converting to &#x27;const p&#x27; from initilizer list would use explicit constructor</span></span><br><span class="line"><span class="comment">//Error ****************//</span></span><br><span class="line"><span class="built_in">fp</span>(P&#123;<span class="number">47</span>,<span class="number">11</span>&#125;)<span class="comment">//P(initializer_list&lt;int&gt;)</span></span><br><span class="line"><span class="built_in">fp</span>(P&#123;<span class="number">26</span>,<span class="number">11</span>,<span class="number">3</span>&#125;) <span class="comment">//P(initializer_list&lt;int&gt;)</span></span><br></pre></td></tr></table></figure>
<h4 id="技术实现细节"><a href="#技术实现细节" class="headerlink" title="技术实现细节"></a>技术实现细节</h4><h5 id="array-容器的TR1-版本"><a href="#array-容器的TR1-版本" class="headerlink" title="array 容器的TR1(版本)"></a>array 容器的TR1(版本)</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp,std::<span class="type">size_t</span> _Nm&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">array</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp value_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> value_type* iterator;</span><br><span class="line">    <span class="comment">//Support for zero-sized arrays mandatory;</span></span><br><span class="line">    value_type _M_instance[_Nm?_Nm:<span class="number">1</span>];</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">iterator</span>(&amp;_M_instance[<span class="number">0</span>]);&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">iterator</span>(&amp;_M_instance[_Nm]);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">array&lt;<span class="type">int</span>,10&gt; myArray;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="initializer-list的实现"><a href="#initializer-list的实现" class="headerlink" title="initializer_list的实现"></a>initializer_list的实现</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// std::initializer_list support -*- C++ -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Copyright (C) 2008-2022 Free Software Foundation, Inc.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This file is part of GCC.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// gcc/libstdc++-v3/libsupc++/initializer_list</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _INITIALIZER_LIST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _INITIALIZER_LIST</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC system_header</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __cplusplus &lt; 201103L</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;bits/c++0x_warning.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">// C++0x</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC visibility push(default)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/c++config.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/// initializer_list</span></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_E</span>&gt;</span><br><span class="line">    <span class="keyword">class</span> ##### <span class="built_in">TR1</span>(版本)</span><br><span class="line">```cpp</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp,std::<span class="type">size_t</span> _Nm&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">array</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp value_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> value_type* iterator;</span><br><span class="line">    <span class="comment">//Support for zero-sized arrays mandatory;</span></span><br><span class="line">    value_type _M_instance[_Nm?_Nm:<span class="number">1</span>];</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">iterator</span>(&amp;_M_instance[<span class="number">0</span>]);&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">iterator</span>(&amp;_M_instance[_Nm]);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">array&lt;<span class="type">int</span>,10&gt; myArray;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> _E 		value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">const</span> _E&amp; 	reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">const</span> _E&amp; 	const_reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">size_t</span> 		size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">const</span> _E* 	iterator;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">const</span> _E* 	const_iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">//**********************************************//</span></span><br><span class="line"><span class="comment">// 实现是依靠array 容器</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  iterator			_M_array;</span><br><span class="line">  size_type			_M_len;</span><br><span class="line"><span class="comment">//**********************************************//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//**********************************************//</span></span><br><span class="line"><span class="comment">// The compiler can call a private constructor.</span></span><br><span class="line"><span class="comment">// 当编译器看到&#123;&#125;时会调用下面的的构造，在调用initializer_list构造函数之前</span></span><br><span class="line"><span class="comment">// 编译器会先创建一个array容器，后会将array的容器的迭代器和长度，传入initializer_list 构造函数</span></span><br><span class="line"><span class="comment">//**********************************************//</span></span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="title">initializer_list</span><span class="params">(const_iterator __a, size_type __l)</span></span></span><br><span class="line"><span class="function">  : _M_array(__a), _M_len(__l) &#123;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="title">initializer_list</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  : _M_array(<span class="number">0</span>), _M_len(<span class="number">0</span>) &#123;</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Number of elements.</span></span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> size_type</span></span><br><span class="line"><span class="function">  <span class="title">size</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> _M_len; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// First element.</span></span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> const_iterator</span></span><br><span class="line"><span class="function">  <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> _M_array; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// One past the last element.</span></span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> const_iterator</span></span><br><span class="line"><span class="function">  <span class="title">end</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">begin</span>() + <span class="built_in">size</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="for-新的写法"><a href="#for-新的写法" class="headerlink" title="for 新的写法"></a>for 新的写法</h2><h3 id="使用引用可以使遍历更加快速-同时可以修改变量的值"><a href="#使用引用可以使遍历更加快速-同时可以修改变量的值" class="headerlink" title="使用引用可以使遍历更加快速,同时可以修改变量的值"></a><strong>使用引用可以使遍历更加快速,同时可以修改变量的值</strong></h3><h3 id="关联式容器不可以修改值"><a href="#关联式容器不可以修改值" class="headerlink" title="关联式容器不可以修改值"></a><strong>关联式容器不可以修改值</strong></h3><ul>
<li>set</li>
<li>map</li>
<li>unorder_set</li>
<li>unorder_map</li>
<li>multiset</li>
<li>multimap</li>
</ul>
<h3 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">vector&lt;<span class="type">double</span>&gt; vec;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> s:vec)&#123;</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 赋值速度更快，同时可以修改其中的值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; s:vec)&#123;</span><br><span class="line"></span><br><span class="line">    s*=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; s:vec)&#123;</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">double</span>&gt; vec;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> s:vec)&#123;</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> _pos=coll.<span class="built_in">begin</span>(),_end=<span class="built_in">end</span>(doll);_pos!=_end;++_pos)&#123;</span><br><span class="line">    decl=*_pos;</span><br><span class="line">    <span class="comment">//statement(cout&lt;&lt;s&lt;&lt;endl;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="转型实现"><a href="#转型实现" class="headerlink" title="转型实现"></a>转型实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">C</span><span class="params">(<span class="type">const</span> stirng&amp; s)</span></span>; <span class="comment">//禁止自动转换</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; vs;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> C&amp; elem:vs)&#123; <span class="comment">// Error,no conoversion from string to C defined</span></span><br><span class="line">    <span class="comment">// 类型不同时，会进行默认的类型转换</span></span><br><span class="line">    cout&lt;&lt;elem&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
        <category>cpp</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>cpp11&amp;14</tag>
        <tag>一致初始化</tag>
        <tag>initializer_list</tag>
        <tag>array容器</tag>
        <tag>explicit</tag>
        <tag>for 特殊的写法</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp 面向对象基础--基础与头文件声明</title>
    <url>/2022/03/19/cpp-%E4%BE%AF%E6%8D%B7Note/</url>
    <content><![CDATA[<!-- HTML方式: 直接在 Markdown 文件中编写 HTML 来调用 -->
<!-- 其中 class="blockquote-center" 是必须的 -->
<!-- <blockquote class="blockquote-center">this is note</blockquote> -->

<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="c与cpp-的区别"><a href="#c与cpp-的区别" class="headerlink" title="c与cpp 的区别"></a>c与cpp 的区别</h3><table>
<thead>
<tr>
<th>语言</th>
<th>c</th>
<th>cpp</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>Object Base(基于对象)</td>
<td>Object Oriented(面向对象)</td>
</tr>
<tr>
<td></td>
<td>面对**单一的class(类)**设计</td>
<td>面对多重classes的设计，着重于<strong>class之间的关系</strong></td>
</tr>
<tr>
<td>头文件的书写区别 注（头文件的后缀名在不同平台可能不同）引用c的头文件要在前面加c</td>
<td>&lt;stdio&gt;</td>
<td>&lt;cstdio&gt; &lt;iostream&gt;</td>
</tr>
</tbody></table>
<span id="more"></span>

<h3 id="防卫式生命"><a href="#防卫式生命" class="headerlink" title="防卫式生命"></a>防卫式生命</h3><p><em>为了解决引用顺序的问题</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __FILENAME__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __FILENAME__</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="头文件布局"><a href="#头文件布局" class="headerlink" title="头文件布局"></a>头文件布局</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __FILENAME__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __FILENAME__</span></span><br><span class="line"><span class="comment">// 前项生命</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类定义</span></span><br><span class="line">complex::<span class="built_in">method</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="class声明-模板类"><a href="#class声明-模板类" class="headerlink" title="class声明(模板类)"></a>class声明(模板类)</h2><ul>
<li>complex.h</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __COMPLEX__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __COMPLEX__</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">complex</span>(T r=<span class="number">0</span>,T i=<span class="number">0</span>):<span class="built_in">re</span>(r),<span class="built_in">im</span>(i)&#123;&#125;</span><br><span class="line">	complex&amp; <span class="keyword">operator</span> +=(<span class="type">const</span> complex&amp;);</span><br><span class="line">	<span class="function">T <span class="title">real</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> re;&#125; <span class="comment">//表示函数不会修改任何东西</span></span><br><span class="line">	<span class="function">T <span class="title">imag</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> im;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T re,im;</span><br><span class="line">	<span class="keyword">friend</span> complex&amp; __doapl(complex*,<span class="type">const</span> complex&amp;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>Complex 类的使用</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">complex&lt;<span class="type">double</span>&gt; <span class="title">complexDouble</span><span class="params">(<span class="number">1.0</span>,<span class="number">2.0</span>)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
        <category>cpp</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>侯捷</tag>
        <tag>头文件</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp 构造与析构（侯捷）</title>
    <url>/2022/03/20/cpp-%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84/</url>
    <content><![CDATA[<h2 id="inline（内联函数）"><a href="#inline（内联函数）" class="headerlink" title="inline（内联函数）"></a>inline（内联函数）</h2><p><em>若在函数体内定义完成，变为内联函数的候选人</em><br>inline 函数运行更快，inline 只是建议，具体是否使用由编译器决定</p>
<span id="more"></span>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>函数重载 :由编译器负责将函数命名唯一化，使用<strong>函数名</strong>和<strong>参数</strong> 有关</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __COMPLEX__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __COMPLEX__</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">complex</span>(T r=<span class="number">0</span>,T i=<span class="number">0</span>):<span class="built_in">re</span>(r),<span class="built_in">im</span>(i)&#123;&#125; <span class="comment">//inline 使用初始化构造列表,优点构造函数运行更快：因为在变量初始化时就进行了赋值</span></span><br><span class="line">    <span class="comment">// (T r=0,T i=0) 默认实参</span></span><br><span class="line">    <span class="built_in">complex</span>():<span class="built_in">re</span>(<span class="number">0</span>),<span class="built_in">im</span>(<span class="number">0</span>)&#123;&#125;<span class="comment">// 与 上面的构造函数冲突，因此这种构造不允许存在</span></span><br><span class="line">	complex&amp; <span class="keyword">operator</span> +=(<span class="type">const</span> complex&amp;);</span><br><span class="line">	<span class="function">T <span class="title">real</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> re;&#125; <span class="comment">//inline</span></span><br><span class="line">	<span class="function">T <span class="title">imag</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> im;&#125;<span class="comment">//inline</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T re,im;</span><br><span class="line">	<span class="keyword">friend</span> complex&amp; __doapl(complex*,<span class="type">const</span> complex&amp;); <span class="comment">//友元 可以直接访问类的私有成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>尽量inline由编译器决定</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">imag</span><span class="params">(<span class="type">const</span> conplex&amp; x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.<span class="built_in">imag</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> complex&amp;</span><br><span class="line">__doapl (complex* ths,<span class="type">const</span> comlex&amp; r)&#123;</span><br><span class="line">    ths-&gt;re +=r.re;</span><br><span class="line">    ths-&gt;im +=r.im;</span><br><span class="line">    <span class="keyword">return</span> *ths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p><strong>同一个class的各个objects互为友元</strong></p>
<h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><h3 id="尽量使用引用传递，入参以及返回值"><a href="#尽量使用引用传递，入参以及返回值" class="headerlink" title="尽量使用引用传递，入参以及返回值"></a>尽量使用引用传递，入参以及返回值</h3><p><em>引用实际上是由编译器使用指针实现</em></p>
<h3 id="返回值不能使用引用，若返回的值在离开函数后不存在"><a href="#返回值不能使用引用，若返回的值在离开函数后不存在" class="headerlink" title="返回值不能使用引用，若返回的值在离开函数后不存在"></a>返回值不能使用引用，若返回的值在离开函数后不存在</h3><p>使用引用的方式<strong>传递着</strong>，无需知道<strong>接受者是以引用</strong>的方式接受的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> complex&amp;</span><br><span class="line">comolex::operayor += (<span class="type">const</span> comlex&amp; r)&#123;</span><br><span class="line">   <span class="keyword">return</span> __doapl(<span class="keyword">this</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c2 +=c1;</span><br><span class="line">c2+=c2+=c1;<span class="comment">// 因为是引用的方式，所以这种写法是可以的。既传递着无需关心接受者的接收方式</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h2><h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">complex c1;</span><br><span class="line">complex c2;</span><br><span class="line">c2+=c1;<span class="comment">//操作符被作用到左侧的这个类型上</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">inline</span> complex&amp;</span><br><span class="line"><span class="comment">//由于这个函数其他地方可能会用到，因此我们需要把它独立出来</span></span><br><span class="line">__doapl (complex* ths,<span class="type">const</span> comlex&amp; r)&#123;<span class="comment">//第二个参数不会改动，因此添加const关键字</span></span><br><span class="line">    ths-&gt;re +=r.re;</span><br><span class="line">    ths-&gt;im +=r.im;</span><br><span class="line">    <span class="keyword">return</span> *ths;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> complex&amp;</span><br><span class="line">comolex::operayor += (<span class="type">const</span> comlex&amp; r)&#123;</span><br><span class="line">   <span class="keyword">return</span> __doapl(<span class="keyword">this</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="非成员函数"><a href="#非成员函数" class="headerlink" title="非成员函数"></a>非成员函数</h3><p><em>临时对象</em><br>特殊操作符要使用全局的操作符重载<br>cout&lt;&lt; conj(c1);<br>cout&lt;&lt; c1&lt;&lt; conj(c1);</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局函数</span></span><br><span class="line"><span class="keyword">inline</span> compelx</span><br><span class="line"><span class="keyword">operator</span> +(<span class="type">const</span> compelx&amp;x,<span class="type">const</span> complex&amp;y)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span>(<span class="built_in">real</span>(x)+<span class="built_in">real</span>(y),<span class="built_in">imag</span>(x)+<span class="built_in">imag</span>(y));<span class="comment">//类型（）创建临时变量。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> compelx</span><br><span class="line"><span class="keyword">operator</span> +(<span class="type">const</span> compelx&amp;x, <span class="type">double</span> y)&#123;</span><br><span class="line">    <span class="built_in">complex</span>(<span class="built_in">real</span>(x)+<span class="built_in">real</span>(y),<span class="built_in">imag</span>(x)+y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> compelx</span><br><span class="line"><span class="keyword">operator</span> +( <span class="type">double</span> x, <span class="type">const</span> complex&amp;y)&#123;</span><br><span class="line">    <span class="built_in">complex</span>(x+<span class="built_in">real</span>(y),<span class="built_in">imag</span>(x)+<span class="built_in">imag</span>(y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> complex <span class="keyword">operator</span> +(<span class="type">const</span> complex&amp;x)&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> complex <span class="keyword">operator</span> -(<span class="type">const</span> complex&amp;x)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span>(-<span class="built_in">real</span>(x),-<span class="built_in">imag</span>(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">operator</span> ==(<span class="type">const</span> comolex&amp; x,<span class="type">const</span> comolex&amp; y)&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">real</span>(x)==<span class="built_in">real</span>(y) &amp;&amp;<span class="built_in">imag</span>(x)==<span class="built_in">imag</span>(y);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">operator</span> ==(<span class="type">const</span> comolex&amp; x,<span class="type">double</span> y)&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">real</span>(x)==y &amp;&amp;<span class="built_in">imag</span>(x)==<span class="number">0</span>;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">operator</span> ==(<span class="type">double</span> x,<span class="type">const</span> comolex&amp; y)&#123;</span><br><span class="line"> <span class="keyword">return</span> x==<span class="built_in">real</span>(y) &amp;&amp;<span class="built_in">imag</span>(x)==<span class="number">0</span>;  </span><br><span class="line">&#125;</span><br><span class="line">ostream &amp;</span><br><span class="line"><span class="keyword">operator</span> &lt;&lt; (ostream&amp; os,<span class="type">const</span> compelx&amp;x)&#123;<span class="comment">//os 不能const，因为每次输出改变os的状态</span></span><br><span class="line">    <span class="keyword">return</span> os&lt;&lt;<span class="string">&quot;&quot;</span>&lt;&lt;<span class="built_in">real</span>(x)&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;<span class="built_in">imag</span>(x)&lt;&lt;<span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
        <category>后端</category>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>侯捷</tag>
        <tag>构造</tag>
        <tag>析构</tag>
        <tag>内联函数</tag>
        <tag>操作符重载</tag>
        <tag>临时对象</tag>
      </tags>
  </entry>
</search>
