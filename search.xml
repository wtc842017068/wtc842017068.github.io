<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>cpp 11&amp;14 decltype&amp;lambdas</title>
    <url>/2022/04/16/cpp-11-14-decltype&amp;lambdas/</url>
    <content><![CDATA[<!-- <blockquote class="blockquote-center">this is note</blockquote> -->
<ul>
<li>decltype<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;string,<span class="type">float</span>&gt; coll;</span><br><span class="line"><span class="keyword">decltype</span>(coll)::value_type elem; <span class="comment">// map&lt;string,float&gt;::value ele;</span></span><br></pre></td></tr></table></figure></li>
<li>lambdas<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mutable 关键字，表示是否可以改写</span></span><br><span class="line"><span class="comment">//thorwSpec 表示可以抛出的异常</span></span><br><span class="line"><span class="comment">//retType 表示返回值</span></span><br><span class="line"><span class="comment">//三个都没有(parameters)可以不写</span></span><br><span class="line"><span class="comment">//             ^</span></span><br><span class="line"><span class="comment">//[] 这个里面可以放外部的变量，不放入就看不见。可以传值和引用</span></span><br><span class="line">[...](parameters)<span class="built_in">mutable</span>(opt),<span class="built_in">thorwSpec</span>(opt)-&gt;<span class="built_in">retType</span>(opt)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> i=[...](parameters)<span class="built_in">mutable</span>(opt),<span class="built_in">thorwSpec</span>(opt)-&gt;<span class="built_in">retType</span>(opt)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;()<span class="comment">//表示直接调用</span></span><br></pre></td></tr></table></figure>
<span id="more"></span></li>
</ul>
<h1 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h1><p><strong>获取一个表达式的类型</strong></p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;string,<span class="type">float</span>&gt; coll;</span><br><span class="line"><span class="keyword">decltype</span>(coll)::value_type elem; <span class="comment">// map&lt;string,float&gt;::value ele;</span></span><br></pre></td></tr></table></figure>
<h2 id="sample"><a href="#sample" class="headerlink" title="sample"></a>sample</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//**************************************//</span></span><br><span class="line">map&lt;string,<span class="type">float</span>&gt; coll;</span><br><span class="line"><span class="keyword">decltype</span>(coll)::value_type elem; <span class="comment">// map&lt;string,float&gt;::value ele;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//**************************************//</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="title">decltype</span><span class="params">(x+y)</span> <span class="title">add</span><span class="params">(T1 x,T2 y)</span></span>; <span class="comment">//表示表达式返回值的结果是x+y之后的类型，编译不过，</span></span><br><span class="line"><span class="comment">//改进方法</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T1 x,T2 y)</span>-&gt;<span class="title">decltype</span><span class="params">(x+y)</span></span>; <span class="comment">//函数返回类型的制定方式，与lambda 表达式类似</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//**************************************//</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test18_decltype</span><span class="params">(T obj)</span></span>&#123;</span><br><span class="line">    map&lt;string,<span class="type">float</span>&gt;::value_type elem1;</span><br><span class="line"></span><br><span class="line">    map&lt;string,<span class="type">float</span>&gt;coll;</span><br><span class="line">    <span class="keyword">decltype</span>(coll)::value_type elem2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="title">decltype</span><span class="params">(obj)</span>::iterator iType</span>;<span class="comment">//等价于 typedef typename T::iterator iType</span></span><br><span class="line"><span class="comment">// 我知道obj 是一个容器，因此一定有iterator, 一旦使用:: 前要跟上 typename 告诉编译器后面的是一个类型的名字</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//**************************************//</span></span><br><span class="line"><span class="keyword">auto</span> cmp=[](<span class="type">const</span> Person&amp; p1,<span class="type">const</span> Person&amp; p2)&#123;</span><br><span class="line">    <span class="keyword">return</span> p1.<span class="built_in">lastname</span>()&lt;p2.<span class="built_in">lastname</span>()||(p1.<span class="built_in">lastname</span>()==p2.<span class="built_in">lastname</span>()&amp;&amp;p1.firstname&lt;p2.<span class="built_in">firstname</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::set&lt;Person,<span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">coll</span>(cmp);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="lambdas"><a href="#lambdas" class="headerlink" title="lambdas"></a>lambdas</h1><p><strong>是一个对象，但是用起来像一个function</strong><br><strong>类型是一个匿名的函数对象</strong></p>
<h2 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mutable 关键字，表示是否可以改写</span></span><br><span class="line"><span class="comment">//thorwSpec 表示可以抛出的异常</span></span><br><span class="line"><span class="comment">//retType 表示返回值</span></span><br><span class="line"><span class="comment">//三个都没有(parameters)可以不写</span></span><br><span class="line"><span class="comment">//             ^</span></span><br><span class="line"><span class="comment">//[] 这个里面可以放外部的变量，不放入就看不见。可以传值和引用</span></span><br><span class="line">[...](parameters)<span class="built_in">mutable</span>(opt),<span class="built_in">thorwSpec</span>(opt)-&gt;<span class="built_in">retType</span>(opt)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> i=[...](parameters)<span class="built_in">mutable</span>(opt),<span class="built_in">thorwSpec</span>(opt)-&gt;<span class="built_in">retType</span>(opt)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;()<span class="comment">//表示直接调用</span></span><br></pre></td></tr></table></figure>
<h2 id="sample-1"><a href="#sample-1" class="headerlink" title="sample"></a>sample</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//******************************</span></span><br><span class="line"><span class="type">int</span> id=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f=[id]()<span class="keyword">mutable</span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;id:&quot;</span>&lt;&lt;id&lt;&lt;std&lt;&lt;endl;</span><br><span class="line">    ++id;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x=<span class="number">5</span>; <span class="comment">//声明静态变量</span></span><br><span class="line">    <span class="type">int</span> y=<span class="number">6</span>;</span><br><span class="line">    <span class="keyword">return</span> id; <span class="comment">//返回数值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上述表达式相当于如下代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Functor</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span></span>&#123;</span><br><span class="line">            std::cout&lt;&lt;<span class="string">&quot;id&quot;</span>&lt;&lt;id&lt;&lt;endl;</span><br><span class="line">            id++;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Functor f;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">id=<span class="number">42</span>;</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line">std::cout&lt;&lt;id&lt;&lt;std::endl;</span><br><span class="line"><span class="comment">// id:0</span></span><br><span class="line"><span class="comment">// id:1</span></span><br><span class="line"><span class="comment">// id:2</span></span><br><span class="line"><span class="comment">// 42</span></span><br><span class="line"><span class="comment">// 因为编译的时候id 已经变为0,因为[id]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//********************************</span></span><br><span class="line"><span class="type">int</span> tobefound=<span class="number">5l</span></span><br><span class="line"><span class="keyword">auto</span> lambda=[tobefound](<span class="type">int</span> val)&#123;<span class="keyword">return</span> val == tobefound;&#125;;</span><br><span class="line"><span class="comment">//上式等价于</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnNameLocalFunction</span>&#123;</span><br><span class="line">    <span class="type">int</span> localVar;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UnNamedLocalFunction</span>(<span class="type">int</span> var):<span class="built_in">localVar</span>(var)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val==localVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="type">bool</span> b1=<span class="built_in">lambda1</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">UnNameLocalFunction <span class="title">lambda2</span><span class="params">(tobefound)</span></span>;</span><br><span class="line"><span class="type">bool</span> b2=<span class="built_in">lambda2</span>(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//**********************</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vi&#123;<span class="number">5</span>,<span class="number">32</span>,<span class="number">56</span>,<span class="number">214</span>,<span class="number">777</span>,<span class="number">5543</span>,<span class="number">22</span>&#125;</span><br><span class="line"><span class="type">int</span> x=<span class="number">30</span>;</span><br><span class="line"><span class="type">int</span> y=<span class="number">100</span>;</span><br><span class="line">vi.<span class="built_in">erase</span>(<span class="built_in">remove_if</span>(vi.<span class="built_in">begin</span>(),vi.<span class="built_in">end</span>(),[x,y](<span class="type">int</span> n)&#123;<span class="keyword">return</span> x&lt;n &amp;&amp; n&lt;y&#125;))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i:vi)</span><br><span class="line">    cout&lt;&lt; i&lt;&lt;<span class="string">&quot;&quot;</span>; <span class="comment">//5,214,777,5543</span></span><br><span class="line">cout&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<h3 id="lambdas的对比"><a href="#lambdas的对比" class="headerlink" title="lambdas的对比"></a>lambdas的对比</h3><ul>
<li><p>类型1(值传递,mutable)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> id=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f=[id]()<span class="keyword">mutable</span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;id:&quot;</span>&lt;&lt;id&lt;&lt;std&lt;&lt;endl;</span><br><span class="line">    ++id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id=<span class="number">42</span>;</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line">std::cout&lt;&lt;id&lt;&lt;std::endl;</span><br><span class="line"><span class="comment">// id:0</span></span><br><span class="line"><span class="comment">// id:1</span></span><br><span class="line"><span class="comment">// id:2</span></span><br><span class="line"><span class="comment">// 42</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>类型2(引用传递)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> id=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f=[&amp;id]()<span class="keyword">mutable</span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;id:&quot;</span>&lt;&lt;id&lt;&lt;std&lt;&lt;endl;</span><br><span class="line">    ++id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id=<span class="number">42</span>;</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line">std::cout&lt;&lt;id&lt;&lt;std::endl;</span><br><span class="line"><span class="comment">// id:42</span></span><br><span class="line"><span class="comment">// id:43</span></span><br><span class="line"><span class="comment">// id:44</span></span><br><span class="line"><span class="comment">// 45</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>类型3(默认全部传递,值传递)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> id=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f=[=]()<span class="keyword">mutable</span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;id:&quot;</span>&lt;&lt;id&lt;&lt;std&lt;&lt;endl;</span><br><span class="line">    ++id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id=<span class="number">42</span>;</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line">std::cout&lt;&lt;id&lt;&lt;std::endl;</span><br><span class="line"><span class="comment">// id:42</span></span><br><span class="line"><span class="comment">// id:43</span></span><br><span class="line"><span class="comment">// id:44</span></span><br><span class="line"><span class="comment">// 45</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>类型4(值传递) Error</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> id=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//编译报错，因为id为只读不可修改</span></span><br><span class="line"><span class="keyword">auto</span> f=[id]()&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;id:&quot;</span>&lt;&lt;id&lt;&lt;std&lt;&lt;endl;</span><br><span class="line">    ++id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id=<span class="number">42</span>;</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line">std::cout&lt;&lt;id&lt;&lt;std::endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p><strong>当我们需要知道lambadas表达式的类型时，这种情况主要被应用在传递一个函数作为<em>hash函数</em>或者<em>排序函数</em>或者<em>排序的准则对于一个无序的容器</em></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> cmp=[](<span class="type">const</span> Person&amp; p1,<span class="type">const</span> Person&amp; p2)&#123;</span><br><span class="line">    <span class="keyword">return</span> p1.<span class="built_in">lastname</span>()&lt;p2.<span class="built_in">lastname</span>()||(p1.<span class="built_in">lastname</span>()==p2.<span class="built_in">lastname</span>()&amp;&amp;p1.firstname&lt;p2.<span class="built_in">firstname</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::set&lt;Person,<span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">coll</span>(cmp);</span><br><span class="line"><span class="comment">//对于这个实现，我们需要将cmp对象传入,要不然会默认调用Compare 的默认构造函数，但是由于传入的是匿名函数，所以没有默认构造。编译会报错</span></span><br></pre></td></tr></table></figure>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Compare</span>=less&lt;Key&gt;,</span><br><span class="line">                   <span class="keyword">class</span> Alloc=alloc&gt;</span><br><span class="line"><span class="keyword">class</span> set&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//typedefs:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">typedef</span> Compare key_compare;</span><br><span class="line">    <span class="keyword">typedef</span> Compare value_compare;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="keyword">typedef</span> rb_tree&lt;key_type,value_type,</span><br><span class="line">                identity&lt;value_type&gt;,</span><br><span class="line">                key_compare,Alloc&gt; rep_type;</span><br><span class="line"> rep_type t;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"> ...</span><br><span class="line"> <span class="built_in">set</span>():<span class="built_in">t</span>(<span class="built_in">Compare</span>())&#123;&#125;</span><br><span class="line"> <span class="function"><span class="keyword">explicit</span> <span class="title">set</span><span class="params">(<span class="type">const</span> Compare&amp; comp)</span>:t(comp)</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
        <category>cpp</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>decltype</tag>
        <tag>lambdas</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp 11&amp;14 default&amp;delete 以及template</title>
    <url>/2022/04/13/cpp-11-14-default&amp;delete%20%E4%BB%A5%E5%8F%8Atemplate/</url>
    <content><![CDATA[<!-- <blockquote class="blockquote-center">this is note</blockquote> -->
<ul>
<li>default&amp;delete<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Zoo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//big five 可以运用到default，其它函数上会报错</span></span><br><span class="line">        <span class="built_in">Zoo</span>(<span class="type">int</span> i1,<span class="type">int</span> i2):<span class="built_in">d1</span>(i1),<span class="built_in">d2</span>(i2)&#123;&#125;<span class="comment">//构造函数</span></span><br><span class="line">        <span class="built_in">Zoo</span>(<span class="type">const</span> Zoo&amp;)=<span class="keyword">delete</span>;<span class="comment">//拷贝构造函数，不要这个函数,不可以使用</span></span><br><span class="line">        <span class="built_in">Zoo</span>(Zoo&amp;&amp;)=<span class="keyword">default</span>;<span class="comment">//右值引用，使用编译器默认的版本</span></span><br><span class="line">        Zoo&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Zoo&amp;)=<span class="keyword">default</span>;<span class="comment">//拷贝赋值</span></span><br><span class="line">        Zoo&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Zoo&amp;&amp;)=<span class="keyword">delete</span>;<span class="comment">//移动赋值</span></span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Zoo</span>()&#123;&#125;;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> d1,d2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>alias Template<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Vec=std::vector&lt;T,MyAlloc&lt;T&gt;&gt;;</span><br><span class="line">Vec&lt;<span class="type">int</span>&gt; coll;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Vec<span class="string">&lt;T&gt;</span> template<span class="string">&lt;typename T&gt;</span> std::vector<span class="string">&lt;T,MyAlloc&lt;T&gt;</span>&gt;;</span></span><br><span class="line">Vec&lt;<span class="type">int</span>&gt; coll;</span><br><span class="line"><span class="comment">//template&lt;typename int&gt; std::vector&lt;int,MyAlloc&lt;int&gt;&gt; 是这样的效果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用typedef,因为typedef 不接收参数,只能使用如下所示</span></span><br><span class="line"><span class="keyword">typedef</span> std::vector&lt;<span class="type">int</span>,MyAlloc&lt;<span class="type">int</span>&gt;&gt; Vec;</span><br></pre></td></tr></table></figure></li>
<li>template template parameter</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">template</span>&lt;<span class="keyword">class</span>&gt; <span class="keyword">class</span> <span class="title class_">Container</span>&gt;</span><br><span class="line"><span class="comment">//template&lt;typename T,template&lt;typename&gt; class Container&gt;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XCIs</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Container&lt;T&gt; c;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">XCIs</span>()&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">long</span> i=<span class="number">0</span>;i&lt;SIZE;i++)&#123;</span><br><span class="line">                c.<span class="built_in">insert</span>(c.<span class="built_in">end</span>(),<span class="built_in">T</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">output_static_data</span>(<span class="built_in">T</span>());</span><br><span class="line">            <span class="function">Container&lt;T&gt; <span class="title">c1</span><span class="params">(c)</span></span>;</span><br><span class="line">            <span class="function">Container&lt;T&gt; <span class="title">c2</span><span class="params">(std::move(c))</span></span>;</span><br><span class="line">            c1.<span class="built_in">swap</span>(c2);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<span id="more"></span>
<h1 id="default-amp-delete"><a href="#default-amp-delete" class="headerlink" title="default&amp;delete"></a>default&amp;delete</h1><h2 id="何时需要写出big-5-函数，类中含有指针时需要写出"><a href="#何时需要写出big-5-函数，类中含有指针时需要写出" class="headerlink" title="何时需要写出big 5 函数，类中含有指针时需要写出"></a><strong>何时需要写出big 5 函数，类中含有指针时需要写出</strong></h2><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span> i):_i(i)&#123;&#125;</span><br><span class="line">    <span class="built_in">Foo</span>()=<span class="keyword">default</span>;<span class="comment">//默认构造</span></span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">const</span> Foo&amp;x):_i(x.i)&#123;&#125;</span><br><span class="line">    <span class="comment">// Foo(const Foo&amp;)=default;//存在重名函数</span></span><br><span class="line">    <span class="comment">// Foo(const Foo&amp;)=delete;//与函数定义冲突</span></span><br><span class="line">    Foo&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Foo&amp;x)&#123;_i=x.i;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">    <span class="comment">//Foo&amp; operator=(const Foo&amp; x)=default;//赋值构造函数</span></span><br><span class="line">    <span class="comment">//Foo&amp; operator=(const Foo&amp; x)=delete;</span></span><br><span class="line">    <span class="comment">// void func1()=default;//[Error] &#x27;void Foo::func1()&#x27; 没有默认的函数实现</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>=<span class="keyword">delete</span> </span><br><span class="line">    <span class="comment">// ~Foo()=delete;//析构函数不能被delete</span></span><br><span class="line">    ~<span class="built_in">Foo</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Foo <span class="title">f1</span><span class="params">(<span class="number">5</span>)</span><span class="comment">//构造</span></span></span><br><span class="line"><span class="function">Foo f2</span>;<span class="comment">//如果没有默认无参数构造会报错</span></span><br><span class="line"><span class="function">Foo <span class="title">f3</span><span class="params">(f1)</span><span class="comment">// 如果拷贝构造呗delete会报错</span></span></span><br><span class="line"><span class="function">f3</span>=f2 <span class="comment">//如果赋值构造被delete 会被报错</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NoCopy</span>&#123;</span><br><span class="line">    <span class="built_in">NoCopy</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">NoCopy</span>(<span class="type">const</span> NoCopy&amp;)=<span class="keyword">delete</span>; <span class="comment">//禁止拷贝构造</span></span><br><span class="line">    NoCopy &amp;<span class="keyword">operator</span>=(<span class="type">const</span> NoCopy&amp;)=<span class="keyword">delete</span> <span class="comment">//禁止赋值构造</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> PrivateCopy&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">PrivateCopy</span>(<span class="type">const</span> PrivateCopy&amp;);</span><br><span class="line">    PrivateCopy &amp;<span class="keyword">operator</span>=(<span class="type">const</span> PrivateCopy&amp;);</span><br><span class="line">    <span class="comment">//私有函数可被自己以及友元使用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> boost&#123;</span><br><span class="line">    <span class="keyword">namespace</span> noncopyable_ &#123;<span class="comment">//</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">noncopyable</span>&#123;</span><br><span class="line">            <span class="keyword">protected</span>:</span><br><span class="line">            <span class="built_in">noncopyable</span>()&#123;&#125;</span><br><span class="line">            ~<span class="built_in">noncopyable</span>()&#123;&#125;</span><br><span class="line">            <span class="keyword">private</span>:</span><br><span class="line">            <span class="built_in">noncopyable</span>(<span class="type">const</span> noncopyable&amp;);</span><br><span class="line">            <span class="type">const</span> noncopyable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> noncopuable&amp;);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于集成,以实现不允许拷贝的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span>&#123;&#125;;</span><br><span class="line"><span class="comment">//当函数被调用后，编译器会生成对应的默认函数,都是内联函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Empty</span>&#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment">//=======================//</span></span><br><span class="line">        <span class="comment">//*********************//</span></span><br><span class="line">        <span class="comment">// Empty e1; 使用默认构造,用于存放背后的代码，例如子类调用父类的构造函数</span></span><br><span class="line">        <span class="built_in">Empty</span>()&#123;...&#125;</span><br><span class="line">        ~<span class="built_in">Empty</span>()&#123;&#125;</span><br><span class="line">        <span class="comment">//*********************//</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//=======================//</span></span><br><span class="line">        <span class="comment">//*********************//</span></span><br><span class="line">        <span class="comment">// Empty e2(e1); 使用拷贝构造</span></span><br><span class="line">        <span class="built_in">Empty</span>(<span class="type">const</span> Empty&amp; rhs)&#123;...&#125;</span><br><span class="line">        <span class="comment">//*********************//</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//=======================//</span></span><br><span class="line">        <span class="comment">//*********************//</span></span><br><span class="line">        <span class="comment">// Empty e2(e1); 使用拷贝构造</span></span><br><span class="line">        <span class="built_in">Empty</span>(<span class="type">const</span> Empty&amp; rhs)&#123;...&#125;</span><br><span class="line">        <span class="comment">//*********************//</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//=======================//</span></span><br><span class="line">        <span class="comment">//*********************//</span></span><br><span class="line">        <span class="comment">// e2 = e1 生成赋值构造</span></span><br><span class="line">        Empty&amp; <span class="keyword">operator</span> = (<span class="type">const</span> Empty&amp; rhs)&#123;&#125; </span><br><span class="line">        <span class="comment">//*********************//</span></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Alias-别名"><a href="#Alias-别名" class="headerlink" title="Alias(别名)"></a>Alias(别名)</h1><h2 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Vec=std::vector&lt;T,MyAlloc&lt;T&gt;&gt;;</span><br><span class="line">Vec&lt;<span class="type">int</span>&gt; coll;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Vec<span class="string">&lt;T&gt;</span> template<span class="string">&lt;typename T&gt;</span> std::vector<span class="string">&lt;T,MyAlloc&lt;T&gt;</span>&gt;;</span></span><br><span class="line">Vec&lt;<span class="type">int</span>&gt; coll;</span><br><span class="line"><span class="comment">//template&lt;typename int&gt; std::vector&lt;int,MyAlloc&lt;int&gt;&gt; 是这样的效果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用typedef,因为typedef 不接收参数,只能使用如下所示</span></span><br><span class="line"><span class="keyword">typedef</span> std::vector&lt;<span class="type">int</span>,MyAlloc&lt;<span class="type">int</span>&gt;&gt; Vec;</span><br></pre></td></tr></table></figure>

<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 函数目的，测试当前类型，是否都禁止了移动构造函数</span></span><br><span class="line"><span class="comment">// 实现这样的效果需要使用 模板模板参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_moveable</span><span class="params">(Container cntr,T elem)</span></span>&#123;</span><br><span class="line">    Container&lt;T&gt; c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> i=<span class="number">0</span>;i&lt;SIZE;++i)</span><br><span class="line">        c.<span class="built_in">insert</span>(c.<span class="built_in">end</span>(),<span class="built_in">T</span>());</span><br><span class="line">    <span class="built_in">output_static_data</span>(<span class="built_in">T</span>());</span><br><span class="line">    <span class="function">Container&lt;T&gt; <span class="title">c1</span><span class="params">(c)</span></span>;</span><br><span class="line">    <span class="function">Container&lt;T&gt; <span class="title">c2</span><span class="params">(std::move(c))</span></span>;</span><br><span class="line">    c1.<span class="built_in">swap</span>(c2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test_moveable</span>(list,MyString);</span><br><span class="line"><span class="built_in">test_moveable</span>(list,MyStrNoMove);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改进</span></span><br><span class="line"><span class="comment">//Error expected nested-name-specifier before is Container</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container,<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_moveable</span><span class="params">(Container cntr,T elem)</span></span>&#123;</span><br><span class="line">    <span class="keyword">typename</span> Container&lt;T&gt; c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> i=<span class="number">0</span>;i&lt;SIZE;++i)</span><br><span class="line">        c.<span class="built_in">insert</span>(c.<span class="built_in">end</span>(),<span class="built_in">T</span>());</span><br><span class="line">    <span class="built_in">output_static_data</span>(<span class="built_in">T</span>());</span><br><span class="line">    <span class="function">Container&lt;T&gt; <span class="title">c1</span><span class="params">(c)</span></span>;</span><br><span class="line">    <span class="function">Container&lt;T&gt; <span class="title">c2</span><span class="params">(std::move(c))</span></span>;</span><br><span class="line">    c1.<span class="built_in">swap</span>(c2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test_moveable</span>(<span class="built_in">list</span>(),<span class="built_in">MyString</span>());</span><br><span class="line"><span class="built_in">test_moveable</span>(<span class="built_in">list</span>(),<span class="built_in">MyStrNoMove</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//最终版本</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_moveable</span><span class="params">(Container cntr)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取出容器的内部的类型</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;<span class="keyword">typename</span> Container::iterator&gt;::<span class="function">value_type <span class="title">Valtype</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">typename</span> Container&lt;T&gt; c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> i=<span class="number">0</span>;i&lt;SIZE;++i)</span><br><span class="line">        c.<span class="built_in">insert</span>(c.<span class="built_in">end</span>(),<span class="built_in">Valtype</span>());</span><br><span class="line">    <span class="built_in">output_static_data</span>(*(c.<span class="built_in">begin</span>()));<span class="comment">// 查看哪些静态数据被频繁的调用</span></span><br><span class="line">    <span class="function">Container&lt;T&gt; <span class="title">c1</span><span class="params">(c)</span></span>;</span><br><span class="line">    <span class="function">Container&lt;T&gt; <span class="title">c2</span><span class="params">(std::move(c))</span></span>;</span><br><span class="line">    c1.<span class="built_in">swap</span>(c2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test_moveable</span>(<span class="built_in">list</span>&lt;MyString&gt;());</span><br><span class="line"><span class="built_in">test_moveable</span>(<span class="built_in">list</span>&lt;MyStrNoMove&gt;());</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用RB-tree 时，元素需提供operator&lt;</span></span><br><span class="line"><span class="comment">//使用hashTable 时,元素需提供 operator &lt;,hash function&gt;</span></span><br><span class="line"><span class="comment">//使用multi-容器是，元素还需提供operator ==</span></span><br></pre></td></tr></table></figure>

<h2 id="模板模板参数"><a href="#模板模板参数" class="headerlink" title="模板模板参数"></a>模板模板参数</h2><h3 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span>&gt; <span class="keyword">class</span></span><br><span class="line"><span class="comment">// template&lt;class&gt; class 表示该位置是一个模板类</span></span><br><span class="line"><span class="comment">// template&lt;typename&gt; 效果相同</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">template</span>&lt;<span class="keyword">class</span>&gt; <span class="keyword">class</span> <span class="title class_">Container</span>&gt;</span><br><span class="line"><span class="comment">//template&lt;typename T,template&lt;typename&gt; class Container&gt;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XCIs</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Container&lt;T&gt; c;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">XCIs</span>()&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">long</span> i=<span class="number">0</span>;i&lt;SIZE;i++)&#123;</span><br><span class="line">                c.<span class="built_in">insert</span>(c.<span class="built_in">end</span>(),<span class="built_in">T</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">output_static_data</span>(<span class="built_in">T</span>());</span><br><span class="line">            <span class="function">Container&lt;T&gt; <span class="title">c1</span><span class="params">(c)</span></span>;</span><br><span class="line">            <span class="function">Container&lt;T&gt; <span class="title">c2</span><span class="params">(std::move(c))</span></span>;</span><br><span class="line">            c1.<span class="built_in">swap</span>(c2);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">XCIS&lt;Mystring,vector&gt;c1; <span class="comment">// 使用的时候报错,因为模板需要两个参数，而使用时只有一个模板册数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp,<span class="keyword">typename</span> _Alloc = std::allocator&lt;_Tp&gt;&gt;<span class="comment">//模板函数的默认值，第二个参数以第一个参数为参数</span></span><br><span class="line"><span class="keyword">class</span> vector :<span class="keyword">protected</span> _Vector_vase&lt;_tp,_Alloc&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终实现</span></span><br><span class="line"><span class="comment">// 不可以在函数体内声明</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Vec=vector&lt;T,allocator&lt;T&gt;&gt;;</span><br><span class="line">XCIS&lt;Mystring,Vec&gt;c1;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
        <category>cpp</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>default</tag>
        <tag>delete</tag>
        <tag>Alias(别名)</tag>
        <tag>alias template</tag>
        <tag>模板模板参数</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp 11&amp;14 type Alias,nonexcep和override</title>
    <url>/2022/04/15/cpp-11-14-type-Alias-nonexcep/</url>
    <content><![CDATA[<!-- <blockquote class="blockquote-center">this is note</blockquote> -->
<ul>
<li>Type ALias <strong>(与typedef 相似)</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//**************************//</span></span><br><span class="line"><span class="comment">//type alias,identical to</span></span><br><span class="line"><span class="comment">//typedef void(*func)(int,int);</span></span><br><span class="line"><span class="keyword">using</span> func=<span class="built_in">void</span>(*)(<span class="type">int</span>,<span class="type">int</span>);</span><br><span class="line"><span class="comment">//func 表示一个入参为(int,int)类型的函数指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">example</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span>&#123;&#125;</span><br><span class="line">func fn=example;</span><br><span class="line">typdef basic_string&lt;<span class="type">char</span>&gt; string;</span><br><span class="line"></span><br><span class="line"><span class="comment">//**************************//</span></span><br><span class="line"><span class="comment">//局部的typedef</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Container</span>&#123;</span><br><span class="line">    <span class="keyword">using</span> value_type=T;<span class="comment">//typedef T value_type</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//并且可以应用到原编程,如果上述定义了value_type</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Cntr&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn2</span><span class="params">(<span class="type">const</span> Cntr&amp; c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">typename</span> Cntr::value_type n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//**************************//</span></span><br><span class="line"><span class="comment">//用于隐藏模板参数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">CharT</span>&gt; <span class="keyword">using</span> mystring=std::basic_string&lt;CharT,std::char_traits&lt;Chart&gt;&gt;</span><br><span class="line">mystring&lt;<span class="type">char</span>&gt; str;</span><br></pre></td></tr></table></figure></li>
<li>nonexcep<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span>noexcep</span>;</span><br><span class="line"><span class="comment">//void foo()noexcept(true); 表示不会抛出异常</span></span><br></pre></td></tr></table></figure></li>
</ul>
<span id="more"></span>

<h1 id="Type-ALias"><a href="#Type-ALias" class="headerlink" title="Type ALias"></a>Type ALias</h1><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//**************************//</span></span><br><span class="line"><span class="comment">//type alias,identical to</span></span><br><span class="line"><span class="comment">//typedef void(*func)(int,int);</span></span><br><span class="line"><span class="keyword">using</span> func=<span class="built_in">void</span>(*)(<span class="type">int</span>,<span class="type">int</span>);</span><br><span class="line"><span class="comment">//func 表示一个入参为(int,int)类型的函数指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">example</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span>&#123;&#125;</span><br><span class="line">func fn=example;</span><br><span class="line">typdef basic_string&lt;<span class="type">char</span>&gt; string;</span><br><span class="line"></span><br><span class="line"><span class="comment">//**************************//</span></span><br><span class="line"><span class="comment">//局部的typedef</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Container</span>&#123;</span><br><span class="line">    <span class="keyword">using</span> value_type=T;<span class="comment">//typedef T value_type</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//并且可以应用到原编程,如果上述定义了value_type</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Cntr&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn2</span><span class="params">(<span class="type">const</span> Cntr&amp; c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">typename</span> Cntr::value_type n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//**************************//</span></span><br><span class="line"><span class="comment">//用于隐藏模板参数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">CharT</span>&gt; <span class="keyword">using</span> mystring=std::basic_string&lt;CharT,std::char_traits&lt;Chart&gt;&gt;</span><br><span class="line">mystring&lt;<span class="type">char</span>&gt; str;</span><br></pre></td></tr></table></figure>
<h2 id="using-用法总结"><a href="#using-用法总结" class="headerlink" title="using 用法总结"></a>using 用法总结</h2><ul>
<li>using-directives<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//单独打开某个函数</span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br></pre></td></tr></table></figure></li>
<li>using-declareations<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 制定函数类型是某个命名空间下的类型</span></span><br><span class="line"><span class="keyword">using</span> _Base::_M_allocate</span><br></pre></td></tr></table></figure></li>
<li>type alias<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//type alias and alias template</span></span><br><span class="line"><span class="keyword">using</span> func=<span class="built_in">void</span>(*)(<span class="type">int</span>,<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Container</span>&#123;</span><br><span class="line">    <span class="keyword">using</span> value_type=T;<span class="comment">//typedef T value_type</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">CharT</span>&gt; <span class="keyword">using</span> mystring=std::basic_string&lt;CharT,std::char_traits&lt;Chart&gt;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="noexcept"><a href="#noexcept" class="headerlink" title="noexcept"></a>noexcept</h1><p><strong>表示函数不抛出异常</strong><br>当异常都没有被捕获时,会调用std::terminate()中的std::abort()方法</p>
<h2 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//表示x.swap(y)不抛异常就不会抛出异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Type&amp; x,Type&amp; y)</span> <span class="title">noexcept</span><span class="params">(nonexcept(x.swap(y)))</span></span>&#123;</span><br><span class="line">    x.<span class="built_in">swap</span>(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>当使用growable container(会发生 memory reallocation)之后两种</p>
<ul>
<li>vector</li>
<li>deque<br>如果类定义了移动构造，并且希望被grow 类型的容器调用需要在移动构造时使用noexcept<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mystring</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">char</span>* _data;</span><br><span class="line">        <span class="type">size_t</span> _len;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Mystring</span>(Mystring&amp;&amp; str)<span class="keyword">noexcept</span>:</span><br><span class="line">            :_data(str._data),_len(str.len)&#123;&#125;</span><br><span class="line"></span><br><span class="line">        Mystring&amp; <span class="keyword">operator</span>=(MyString&amp;&amp; str)<span class="keyword">noexcept</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="override"><a href="#override" class="headerlink" title="override"></a>override</h1><p><strong>用于让编译器帮忙检验当前函数是否是复写父类函数</strong></p>
<h2 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfunc</span><span class="params">(<span class="type">float</span>)</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dervied1</span>:Base&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfunc</span><span class="params">(<span class="type">int</span>)</span></span>&#123;&#125;<span class="comment">//本来想override,但是写错了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//改进</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dervied1</span>:Base&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfunc</span><span class="params">(<span class="type">int</span>)</span><span class="keyword">override</span></span>&#123;&#125;<span class="comment">//没有相同的函数,写错了报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p><strong>不允许复写</strong></p>
<h2 id="code-3"><a href="#code-3" class="headerlink" title="code"></a>code</h2><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base1</span> <span class="keyword">final</span>&#123;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived1</span>:Base1&#123;&#125;; <span class="comment">//报错,不可以被继承</span></span><br></pre></td></tr></table></figure>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base2</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">final</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived2</span>:Base2&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;<span class="comment">// 报错,不可以被复写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
        <category>cpp</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>type Alias</tag>
        <tag>using</tag>
        <tag>nonexcep</tag>
        <tag>override</tag>
        <tag>final</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp 11&amp;14 可变参数模板与空指针,auto</title>
    <url>/2022/03/20/cpp-11-14-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF%E4%B8%8E%E7%A9%BA%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<!-- <blockquote class="blockquote-center">this is note</blockquote> -->
<ul>
<li><p>Variadic Templates(可变参数模板)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可变参数模板</span></span><br><span class="line"><span class="comment">// 无参数函数，用于结束调用 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printX</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 包含一个参数固定参数的可变模板函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... types&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printX</span><span class="params">(<span class="type">const</span> T&amp; firstArg,<span class="type">const</span> Types&amp;... args)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt; firstArg&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">printX</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>空指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;&#125;<span class="comment">//function1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">void</span>* a)</span></span>&#123;&#125;<span class="comment">//funtion2</span></span><br><span class="line"><span class="built_in">f</span>(<span class="literal">NULL</span>);<span class="comment">//call function1 </span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">0</span>);<span class="comment">//call function1 </span></span><br><span class="line"><span class="built_in">f</span>(<span class="literal">nullptr</span>);<span class="comment">//call function2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>模板函数书写变化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;<span class="comment">//</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="comment">//Ok since c++11</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1 id="cpp-11-amp-14-可变参数模板与空指针-auto"><a href="#cpp-11-amp-14-可变参数模板与空指针-auto" class="headerlink" title="cpp 11&amp;14 可变参数模板与空指针,auto"></a>cpp 11&amp;14 可变参数模板与空指针,auto</h1></li>
</ul>
<h2 id="Variadic-Templates-可变参数模板"><a href="#Variadic-Templates-可变参数模板" class="headerlink" title="Variadic Templates(可变参数模板)"></a>Variadic Templates(可变参数模板)</h2><h3 id="帮助我们实现递归"><a href="#帮助我们实现递归" class="headerlink" title="帮助我们实现递归"></a><strong>帮助我们实现递归</strong></h3><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可变参数模板</span></span><br><span class="line"><span class="comment">// 无参数函数，用于结束调用 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printX</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 包含一个参数固定参数的可变模板函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... types&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// type2 和 type 3 可以并存 2为特</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// type2 接收1个和各式各样的入参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printX</span><span class="params">(<span class="type">const</span> T&amp; firstArg,<span class="type">const</span> Types&amp;... args)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt; firstArg&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt; <span class="keyword">sizeof</span>...(args...)&lt;&lt;endl;<span class="comment">// 可以使用sizeof...(args) 获取args的个数</span></span><br><span class="line">    <span class="built_in">printX</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// type3 接收各式各样的入参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printX</span><span class="params">(<span class="type">const</span> Types&amp;... args)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt; firstArg&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt; <span class="keyword">sizeof</span>...(args...)&lt;&lt;endl;<span class="comment">// 可以使用sizeof...(args) 获取args的个数</span></span><br><span class="line">    <span class="built_in">printX</span>(args...);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="cpp库函数举例"><a href="#cpp库函数举例" class="headerlink" title="cpp库函数举例"></a>cpp库函数举例</h4><h5 id="calculate-Hash"><a href="#calculate-Hash" class="headerlink" title="calculate Hash"></a>calculate Hash</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// another file</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">hash_combine</span><span class="params">(<span class="type">size_t</span>&amp; seed,<span class="type">const</span> T&amp; val)</span></span>&#123;</span><br><span class="line">    seed^=std::<span class="built_in">hash</span>&lt;T&gt;()(val)+<span class="number">0x9e3779b9</span>+(seed&lt;&lt;<span class="number">6</span>)+(seed&gt;&gt;<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// call sequence 1-&gt;2-&gt;recurse-&gt;3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// function 1</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>.. Type&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">hash_val</span><span class="params">(<span class="type">size_t</span>&amp; seed, <span class="type">const</span> T&amp; val,<span class="type">const</span> Types&amp;... args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">hash_combine</span>(seed,val);</span><br><span class="line">    <span class="built_in">hash_val</span>(seed,args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// function 2</span></span><br><span class="line"><span class="comment">// auxiliary generic function</span></span><br><span class="line"><span class="keyword">template</span> &lt;typeame... Types&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">size_t</span> <span class="title">hash_val</span><span class="params">(<span class="type">const</span> Types&amp;... args)</span></span>&#123;</span><br><span class="line">    <span class="type">size_t</span> seed=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">hash_val</span>(seed,args);</span><br><span class="line">    <span class="keyword">return</span> seed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function 3</span></span><br><span class="line"><span class="comment">// auxiliary generic function</span></span><br><span class="line"><span class="keyword">template</span> &lt;typeame T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">size_t</span> <span class="title">hash_val</span><span class="params">(<span class="type">size_t</span>&amp; seed,<span class="type">const</span> T&amp; val)</span></span>&#123;</span><br><span class="line">    <span class="built_in">hash_combine</span>(seed,val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="tuple-realise"><a href="#tuple-realise" class="headerlink" title="tuple realise"></a>tuple realise</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Values&gt;<span class="keyword">class</span> <span class="title class_">tuple</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;<span class="keyword">class</span> <span class="title class_">tuple</span>&lt;&gt;&#123;&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head,<span class="keyword">typename</span>... Tail&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tuple</span>&lt;Head,Tail...&gt;:<span class="keyword">private</span> typle&lt;Tail...&gt;&#123;</span><br><span class="line">    <span class="keyword">typedef</span> typle&lt;Tail...&gt; inherited;</span><br><span class="line"> </span><br><span class="line">pubic:</span><br><span class="line">    <span class="built_in">tuple</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">tuple</span>(Head v,Tail... vtail):<span class="built_in">m_head</span>(v),<span class="built_in">inherited</span>(vtail...)&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">typename</span> Head::type <span class="title">head</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_head;&#125;</span><br><span class="line"><span class="function">inherited&amp; <span class="title">tail</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">Head m_head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="tuple-sample"><a href="#tuple-sample" class="headerlink" title="tuple sample"></a>tuple sample</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">tuple&lt;<span class="type">int</span>,<span class="type">float</span>,string&gt; <span class="title">t</span><span class="params">(<span class="number">41</span>,<span class="number">6.3</span>,<span class="string">&quot;nico&quot;</span>)</span></span>;</span><br><span class="line">t.<span class="built_in">head</span>();<span class="comment">//-&gt;4.1</span></span><br><span class="line">t.<span class="built_in">tail</span>().<span class="built_in">head</span>()<span class="comment">//-&gt;6.3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="nullptr-空指针"><a href="#nullptr-空指针" class="headerlink" title="nullptr(空指针)"></a>nullptr(空指针)</h2><h3 id="用于区分空指针与NULL"><a href="#用于区分空指针与NULL" class="headerlink" title="用于区分空指针与NULL"></a><strong>用于区分空指针与NULL</strong></h3><h3 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;&#125;<span class="comment">//function1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">void</span>* a)</span></span>&#123;&#125;<span class="comment">//funtion2</span></span><br><span class="line"><span class="built_in">f</span>(<span class="literal">NULL</span>);<span class="comment">//call function1 </span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">0</span>);<span class="comment">//call function1 </span></span><br><span class="line"><span class="built_in">f</span>(<span class="literal">nullptr</span>);<span class="comment">//call function2</span></span><br></pre></td></tr></table></figure>
<p><strong>file_name</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> <span class="keyword">define</span>(__cplusplus)&amp;&amp; __cplusplus&gt;=201103L</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _GXX_NULLPTR_T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GXX_NULLPTR_T</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(<span class="literal">nullptr</span>)</span> <span class="type">nullptr_t</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// ...</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="keyword">endif</span></span></span></span><br></pre></td></tr></table></figure>

<h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><h3 id="在类型繁琐以及无法确定返回参数类型时使用-lambda-function"><a href="#在类型繁琐以及无法确定返回参数类型时使用-lambda-function" class="headerlink" title="在类型繁琐以及无法确定返回参数类型时使用(lambda function)"></a><strong>在类型繁琐以及无法确定返回参数类型时使用(lambda function)</strong></h3><h3 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;string&gt; v;</span><br><span class="line"><span class="keyword">auto</span> pos=v.<span class="built_in">begin</span>();<span class="comment">// 类型写起来繁琐</span></span><br><span class="line"><span class="keyword">auto</span> i=[](<span class="type">int</span> x)-&gt;<span class="type">bool</span>&#123; <span class="comment">// lambda</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
        <category>cpp</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>cpp11&amp;14</tag>
        <tag>可变参数模板</tag>
        <tag>nullptr</tag>
        <tag>auto</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp 11&amp;14 统一初始化方式以及initializer_list,for</title>
    <url>/2022/04/13/cpp-11-14-%E7%BB%9F%E4%B8%80%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F%E4%BB%A5%E5%8F%8Ainitializer-list/</url>
    <content><![CDATA[<!-- <blockquote class="blockquote-center">this is note</blockquote> -->
<ul>
<li>一致初始化<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> values[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">vector&lt;string&gt; cities&#123;</span><br><span class="line">    <span class="string">&quot;Berlin&quot;</span>,<span class="string">&quot;New York&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">complex&lt;<span class="type">double</span>&gt; c&#123;<span class="number">3.0</span>,<span class="number">4.0</span>&#125;</span><br></pre></td></tr></table></figure></li>
<li>initializer_list<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//***********************//</span></span><br><span class="line"><span class="comment">//initializer_list 传递的是引用,拷贝是浅拷贝</span></span><br><span class="line"><span class="comment">//***********************//</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;<span class="comment">// 会被编译器构造成一个initializer_list</span></span><br><span class="line"><span class="comment">//如果函数只接收initializer_list 则调用者要自己准备一包initializer_list,来使用</span></span><br><span class="line"><span class="comment">//如果目标函数不接受initializer_list，会被编译器分开来传入</span></span><br><span class="line"><span class="type">int</span> i;<span class="comment">//i的值是未定义</span></span><br><span class="line"><span class="type">int</span> j&#123;&#125;;<span class="comment">//设置初值为0</span></span><br><span class="line"><span class="type">int</span>* p;<span class="comment">//未定义初值</span></span><br><span class="line"><span class="type">int</span>* q&#123;&#125;;<span class="comment">//设置初值为nullptr</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">x1</span><span class="params">(<span class="number">5.3</span>)</span></span>; <span class="comment">// x1=5</span></span><br><span class="line"><span class="type">int</span> x2 = <span class="number">5.3</span>;<span class="comment">//x2=5</span></span><br><span class="line"><span class="type">int</span> x3&#123;<span class="number">5.0</span>&#125;;<span class="comment">//Error:narrowing ||-&gt; GCC Warning</span></span><br><span class="line"><span class="type">int</span> x4 =&#123;<span class="number">5.3</span>&#125;; <span class="comment">// Error:narrowing ||-&gt; GCC Warning</span></span><br><span class="line"><span class="type">char</span> c1&#123;<span class="number">7</span>&#125;;<span class="comment">//ok</span></span><br><span class="line"><span class="type">char</span> c2&#123;<span class="number">99999</span>&#125;;<span class="comment">//Error:narrowing ||-&gt; GCC Warning</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v1&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;<span class="comment">//ok</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v1&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5.5</span>&#125;;<span class="comment">//Error:narrowing ||-&gt; GCC Warning</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">max</span>(&#123;<span class="built_in">stirng</span>(<span class="string">&quot;Ace&quot;</span>),<span class="built_in">string</span>(<span class="string">&quot;Stacy&quot;</span>),<span class="built_in">stirng</span>(<span class="string">&quot;qqq&quot;</span>),<span class="built_in">string</span>(<span class="string">&quot;ppp&quot;</span>)&#125;) <span class="comment">//函数可以接收initializer_list，作为入参</span></span><br><span class="line"><span class="built_in">min</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;)<span class="comment">//函数可以接收initializer_list，作为入参</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1 id="cpp-11-amp-14-统一初始化方式以及initializer-list"><a href="#cpp-11-amp-14-统一初始化方式以及initializer-list" class="headerlink" title="cpp 11&amp;14 统一初始化方式以及initializer_list"></a>cpp 11&amp;14 统一初始化方式以及initializer_list</h1><h2 id="一致初始化"><a href="#一致初始化" class="headerlink" title="一致初始化"></a>一致初始化</h2><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> values[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">vector&lt;string&gt; cities&#123;</span><br><span class="line">    <span class="string">&quot;Berlin&quot;</span>,<span class="string">&quot;New York&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">complex&lt;<span class="type">double</span>&gt; c&#123;<span class="number">3.0</span>,<span class="number">4.0</span>&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="initializer-list"><a href="#initializer-list" class="headerlink" title="initializer_list"></a>initializer_list</h2><h3 id="接受任意个参数，但类型要相同"><a href="#接受任意个参数，但类型要相同" class="headerlink" title="接受任意个参数，但类型要相同"></a><strong>接受任意个参数，但类型要相同</strong></h3><h3 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//***********************//</span></span><br><span class="line"><span class="comment">//initializer_list 传递的是引用,拷贝是浅拷贝</span></span><br><span class="line"><span class="comment">//***********************//</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i;<span class="comment">//i的值是未定义</span></span><br><span class="line"><span class="type">int</span> j&#123;&#125;;<span class="comment">//设置初值为0</span></span><br><span class="line"><span class="type">int</span>* p;<span class="comment">//未定义初值</span></span><br><span class="line"><span class="type">int</span>* q&#123;&#125;;<span class="comment">//设置初值为nullptr</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">x1</span><span class="params">(<span class="number">5.3</span>)</span></span>; <span class="comment">// x1=5</span></span><br><span class="line"><span class="type">int</span> x2 = <span class="number">5.3</span>;<span class="comment">//x2=5</span></span><br><span class="line"><span class="type">int</span> x3&#123;<span class="number">5.0</span>&#125;;<span class="comment">//Error:narrowing ||-&gt; GCC Warning</span></span><br><span class="line"><span class="type">int</span> x4 =&#123;<span class="number">5.3</span>&#125;; <span class="comment">// Error:narrowing ||-&gt; GCC Warning</span></span><br><span class="line"><span class="type">char</span> c1&#123;<span class="number">7</span>&#125;;<span class="comment">//ok</span></span><br><span class="line"><span class="type">char</span> c2&#123;<span class="number">99999</span>&#125;;<span class="comment">//Error:narrowing ||-&gt; GCC Warning</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v1&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;<span class="comment">//ok</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v1&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5.5</span>&#125;;<span class="comment">//Error:narrowing ||-&gt; GCC Warning</span></span><br></pre></td></tr></table></figure>
<h4 id="sample-正确"><a href="#sample-正确" class="headerlink" title="sample 正确"></a>sample 正确</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">P</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">P</span>(<span class="type">int</span> a,<span class="type">int</span> b)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;P(int,int),a=&quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; b=&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">P</span>(initializer_list&lt;<span class="type">int</span>&gt; initlist)&#123;</span><br><span class="line">         cout&lt;&lt;<span class="string">&quot;P(initializer_list&lt;int&gt;),values=&quot;</span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">auto</span> i:initializer_list)&#123;</span><br><span class="line">             cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">         cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">P <span class="title">p</span><span class="params">(<span class="number">77</span>,<span class="number">5</span>)</span></span>;<span class="comment">//P(int,int);</span></span><br><span class="line">P q&#123;<span class="number">77</span>,<span class="number">4</span>&#125;;<span class="comment">//P(initializer_list&lt;int&gt;); 形成一包,所以调用的是P(initializer_list&lt;int&gt;)</span></span><br><span class="line">P r&#123;<span class="number">77</span>,<span class="number">5</span>,<span class="number">42</span>&#125;;<span class="comment">//P(initializer_list&lt;int&gt;);</span></span><br><span class="line">P s=&#123;<span class="number">77</span>,<span class="number">5</span>&#125;;<span class="comment">//P(initializer_list&lt;int&gt;);</span></span><br></pre></td></tr></table></figure>

<h4 id="sample-错误"><a href="#sample-错误" class="headerlink" title="sample 错误"></a>sample 错误</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">P</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">P</span>(<span class="type">int</span> a,<span class="type">int</span> b)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;P(int,int),a=&quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; b=&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">P <span class="title">p</span><span class="params">(<span class="number">77</span>,<span class="number">5</span>)</span></span>;<span class="comment">//P(int,int);</span></span><br><span class="line">P q&#123;<span class="number">77</span>,<span class="number">4</span>&#125;;<span class="comment">//P(int,int);</span></span><br><span class="line">P r&#123;<span class="number">77</span>,<span class="number">5</span>,<span class="number">42</span>&#125;;<span class="comment">//Error</span></span><br><span class="line">P s=&#123;<span class="number">77</span>,<span class="number">5</span>&#125;;<span class="comment">//P(initializer_list&lt;int&gt;);</span></span><br></pre></td></tr></table></figure>
<h4 id="explicit-当构造函数含有多个入参时"><a href="#explicit-当构造函数含有多个入参时" class="headerlink" title="explicit 当构造函数含有多个入参时"></a>explicit 当构造函数含有多个入参时</h4><h5 id="explicit-应用在只有一个参数在构造函数时"><a href="#explicit-应用在只有一个参数在构造函数时" class="headerlink" title="explicit 应用在只有一个参数在构造函数时"></a>explicit 应用在只有一个参数在构造函数时</h5><h6 id="old-version"><a href="#old-version" class="headerlink" title="old version"></a>old version</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//*******************************</span></span><br><span class="line"><span class="comment">// 隐含调用含有一个参数的构造函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Complex</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> real,imag;</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">int</span> re,<span class="type">int</span> im=<span class="number">0</span>):<span class="built_in">real</span>(re),<span class="built_in">imag</span>(im)&#123;&#125;</span><br><span class="line">    Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>((real+x.real),(imag+x.imag))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Complex <span class="built_in">c1</span>(<span class="number">12</span>,<span class="number">5</span>);</span><br><span class="line">Complex c2=c1+<span class="number">5</span>;<span class="comment">// 隐含调用含有一个参数的构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//***************************</span></span><br><span class="line"><span class="comment">//禁止隐含调用构造，除非明确指出</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Complex</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> real,imag;</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">int</span> re,<span class="type">int</span> im=<span class="number">0</span>):<span class="built_in">real</span>(re),<span class="built_in">imag</span>(im)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">explicit</span></span><br><span class="line">    Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>((real+x.real),(imag+x.imag))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Complex <span class="built_in">c1</span>(<span class="number">12</span>,<span class="number">5</span>);</span><br><span class="line"><span class="comment">//禁止隐含调用构造，除非明确指出</span></span><br><span class="line">Complex c2=c1+<span class="number">5</span>;<span class="comment">// Erorr no match for &#x27;operator+&#x27;</span></span><br></pre></td></tr></table></figure>
<h6 id="c11-version"><a href="#c11-version" class="headerlink" title="c11 version"></a>c11 version</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">P</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">P</span>(<span class="type">int</span> a,<span class="type">int</span> b)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;P(int,int),a=&quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; b=&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">P</span>(initializer_list&lt;<span class="type">int</span>&gt; initlist)&#123;</span><br><span class="line">         cout&lt;&lt;<span class="string">&quot;P(initializer_list&lt;int&gt;),values=&quot;</span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">auto</span> i:initializer_list)&#123;</span><br><span class="line">             cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">         cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> </span></span><br><span class="line"><span class="function">    <span class="title">P</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;P(int,int),a=&quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; b=&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fp</span><span class="params">(<span class="type">const</span> P&amp;)</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">P <span class="title">p</span><span class="params">(<span class="number">77</span>,<span class="number">5</span>)</span></span>;<span class="comment">//P(int,int);</span></span><br><span class="line">P q&#123;<span class="number">77</span>,<span class="number">4</span>&#125;;<span class="comment">//P(initializer_list&lt;int&gt;); 形成一包,所以调用的是P(initializer_list&lt;int&gt;)</span></span><br><span class="line">P r&#123;<span class="number">77</span>,<span class="number">5</span>,<span class="number">42</span>&#125;;<span class="comment">//P(initializer_list&lt;int&gt;);</span></span><br><span class="line">P s=&#123;<span class="number">77</span>,<span class="number">5</span>&#125;;<span class="comment">//P(initializer_list&lt;int&gt;);</span></span><br><span class="line"><span class="comment">//Error ****************//</span></span><br><span class="line">P p5 = &#123;<span class="number">77</span>,<span class="number">88</span>,<span class="number">3</span>&#125;<span class="comment">//Error converting to &#x27;p&#x27; from initilizer list would use explicit constructor</span></span><br><span class="line"><span class="comment">//Error ****************//</span></span><br><span class="line">P p6 = &#123;<span class="number">77</span>,<span class="number">88</span>,<span class="number">3</span>,<span class="number">8</span>&#125;<span class="comment">//P(initializer_list&lt;int&gt;);</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">fp</span>(&#123;<span class="number">11</span>,<span class="number">22</span>&#125;)<span class="comment">//P(initializer_list&lt;int&gt;)</span></span><br><span class="line"><span class="comment">//Error ****************//</span></span><br><span class="line"><span class="built_in">fp</span>(&#123;<span class="number">47</span>,<span class="number">11</span>,<span class="number">3</span>&#125;)<span class="comment">//Error converting to &#x27;const p&#x27; from initilizer list would use explicit constructor</span></span><br><span class="line"><span class="comment">//Error ****************//</span></span><br><span class="line"><span class="built_in">fp</span>(P&#123;<span class="number">47</span>,<span class="number">11</span>&#125;)<span class="comment">//P(initializer_list&lt;int&gt;)</span></span><br><span class="line"><span class="built_in">fp</span>(P&#123;<span class="number">26</span>,<span class="number">11</span>,<span class="number">3</span>&#125;) <span class="comment">//P(initializer_list&lt;int&gt;)</span></span><br></pre></td></tr></table></figure>
<h4 id="技术实现细节"><a href="#技术实现细节" class="headerlink" title="技术实现细节"></a>技术实现细节</h4><h5 id="array-容器的TR1-版本"><a href="#array-容器的TR1-版本" class="headerlink" title="array 容器的TR1(版本)"></a>array 容器的TR1(版本)</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp,std::<span class="type">size_t</span> _Nm&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">array</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp value_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> value_type* iterator;</span><br><span class="line">    <span class="comment">//Support for zero-sized arrays mandatory;</span></span><br><span class="line">    value_type _M_instance[_Nm?_Nm:<span class="number">1</span>];</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">iterator</span>(&amp;_M_instance[<span class="number">0</span>]);&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">iterator</span>(&amp;_M_instance[_Nm]);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">array&lt;<span class="type">int</span>,10&gt; myArray;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="initializer-list的实现"><a href="#initializer-list的实现" class="headerlink" title="initializer_list的实现"></a>initializer_list的实现</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// std::initializer_list support -*- C++ -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Copyright (C) 2008-2022 Free Software Foundation, Inc.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This file is part of GCC.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// gcc/libstdc++-v3/libsupc++/initializer_list</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _INITIALIZER_LIST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _INITIALIZER_LIST</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC system_header</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __cplusplus &lt; 201103L</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;bits/c++0x_warning.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">// C++0x</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC visibility push(default)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/c++config.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/// initializer_list</span></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_E</span>&gt;</span><br><span class="line">    <span class="keyword">class</span> ##### <span class="built_in">TR1</span>(版本)</span><br><span class="line">```cpp</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp,std::<span class="type">size_t</span> _Nm&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">array</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp value_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> value_type* iterator;</span><br><span class="line">    <span class="comment">//Support for zero-sized arrays mandatory;</span></span><br><span class="line">    value_type _M_instance[_Nm?_Nm:<span class="number">1</span>];</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">iterator</span>(&amp;_M_instance[<span class="number">0</span>]);&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">iterator</span>(&amp;_M_instance[_Nm]);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">array&lt;<span class="type">int</span>,10&gt; myArray;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> _E 		value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">const</span> _E&amp; 	reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">const</span> _E&amp; 	const_reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">size_t</span> 		size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">const</span> _E* 	iterator;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">const</span> _E* 	const_iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">//**********************************************//</span></span><br><span class="line"><span class="comment">// 实现是依靠array 容器</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  iterator			_M_array;</span><br><span class="line">  size_type			_M_len;</span><br><span class="line"><span class="comment">//**********************************************//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//**********************************************//</span></span><br><span class="line"><span class="comment">// The compiler can call a private constructor.</span></span><br><span class="line"><span class="comment">// 当编译器看到&#123;&#125;时会调用下面的的构造，在调用initializer_list构造函数之前</span></span><br><span class="line"><span class="comment">// 编译器会先创建一个array容器，后会将array的容器的迭代器和长度，传入initializer_list 构造函数</span></span><br><span class="line"><span class="comment">//**********************************************//</span></span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="title">initializer_list</span><span class="params">(const_iterator __a, size_type __l)</span></span></span><br><span class="line"><span class="function">  : _M_array(__a), _M_len(__l) &#123;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="title">initializer_list</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  : _M_array(<span class="number">0</span>), _M_len(<span class="number">0</span>) &#123;</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Number of elements.</span></span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> size_type</span></span><br><span class="line"><span class="function">  <span class="title">size</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> _M_len; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// First element.</span></span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> const_iterator</span></span><br><span class="line"><span class="function">  <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> _M_array; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// One past the last element.</span></span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> const_iterator</span></span><br><span class="line"><span class="function">  <span class="title">end</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">begin</span>() + <span class="built_in">size</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="for-新的写法"><a href="#for-新的写法" class="headerlink" title="for 新的写法"></a>for 新的写法</h2><h3 id="使用引用可以使遍历更加快速-同时可以修改变量的值"><a href="#使用引用可以使遍历更加快速-同时可以修改变量的值" class="headerlink" title="使用引用可以使遍历更加快速,同时可以修改变量的值"></a><strong>使用引用可以使遍历更加快速,同时可以修改变量的值</strong></h3><h3 id="关联式容器不可以修改值"><a href="#关联式容器不可以修改值" class="headerlink" title="关联式容器不可以修改值"></a><strong>关联式容器不可以修改值</strong></h3><ul>
<li>set</li>
<li>map</li>
<li>unorder_set</li>
<li>unorder_map</li>
<li>multiset</li>
<li>multimap</li>
</ul>
<h3 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">vector&lt;<span class="type">double</span>&gt; vec;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> s:vec)&#123;</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 赋值速度更快，同时可以修改其中的值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; s:vec)&#123;</span><br><span class="line"></span><br><span class="line">    s*=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; s:vec)&#123;</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">double</span>&gt; vec;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> s:vec)&#123;</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> _pos=coll.<span class="built_in">begin</span>(),_end=<span class="built_in">end</span>(doll);_pos!=_end;++_pos)&#123;</span><br><span class="line">    decl=*_pos;</span><br><span class="line">    <span class="comment">//statement(cout&lt;&lt;s&lt;&lt;endl;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="转型实现"><a href="#转型实现" class="headerlink" title="转型实现"></a>转型实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">C</span><span class="params">(<span class="type">const</span> stirng&amp; s)</span></span>; <span class="comment">//禁止自动转换</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; vs;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> C&amp; elem:vs)&#123; <span class="comment">// Error,no conoversion from string to C defined</span></span><br><span class="line">    <span class="comment">// 类型不同时，会进行默认的类型转换</span></span><br><span class="line">    cout&lt;&lt;elem&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
        <category>cpp</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>cpp11&amp;14</tag>
        <tag>一致初始化</tag>
        <tag>initializer_list</tag>
        <tag>array容器</tag>
        <tag>explicit</tag>
        <tag>for 特殊的写法</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp 构造与析构（侯捷）</title>
    <url>/2022/03/20/cpp-%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84/</url>
    <content><![CDATA[<h2 id="inline（内联函数）"><a href="#inline（内联函数）" class="headerlink" title="inline（内联函数）"></a>inline（内联函数）</h2><p><em>若在函数体内定义完成，变为内联函数的候选人</em><br>inline 函数运行更快，inline 只是建议，具体是否使用由编译器决定</p>
<span id="more"></span>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>函数重载 :由编译器负责将函数命名唯一化，使用<strong>函数名</strong>和<strong>参数</strong> 有关</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __COMPLEX__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __COMPLEX__</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">complex</span>(T r=<span class="number">0</span>,T i=<span class="number">0</span>):<span class="built_in">re</span>(r),<span class="built_in">im</span>(i)&#123;&#125; <span class="comment">//inline 使用初始化构造列表,优点构造函数运行更快：因为在变量初始化时就进行了赋值</span></span><br><span class="line">    <span class="comment">// (T r=0,T i=0) 默认实参</span></span><br><span class="line">    <span class="built_in">complex</span>():<span class="built_in">re</span>(<span class="number">0</span>),<span class="built_in">im</span>(<span class="number">0</span>)&#123;&#125;<span class="comment">// 与 上面的构造函数冲突，因此这种构造不允许存在</span></span><br><span class="line">	complex&amp; <span class="keyword">operator</span> +=(<span class="type">const</span> complex&amp;);</span><br><span class="line">	<span class="function">T <span class="title">real</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> re;&#125; <span class="comment">//inline</span></span><br><span class="line">	<span class="function">T <span class="title">imag</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> im;&#125;<span class="comment">//inline</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T re,im;</span><br><span class="line">	<span class="keyword">friend</span> complex&amp; __doapl(complex*,<span class="type">const</span> complex&amp;); <span class="comment">//友元 可以直接访问类的私有成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>尽量inline由编译器决定</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">imag</span><span class="params">(<span class="type">const</span> conplex&amp; x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.<span class="built_in">imag</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> complex&amp;</span><br><span class="line">__doapl (complex* ths,<span class="type">const</span> comlex&amp; r)&#123;</span><br><span class="line">    ths-&gt;re +=r.re;</span><br><span class="line">    ths-&gt;im +=r.im;</span><br><span class="line">    <span class="keyword">return</span> *ths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p><strong>同一个class的各个objects互为友元</strong></p>
<h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><h3 id="尽量使用引用传递，入参以及返回值"><a href="#尽量使用引用传递，入参以及返回值" class="headerlink" title="尽量使用引用传递，入参以及返回值"></a>尽量使用引用传递，入参以及返回值</h3><p><em>引用实际上是由编译器使用指针实现</em></p>
<h3 id="返回值不能使用引用，若返回的值在离开函数后不存在"><a href="#返回值不能使用引用，若返回的值在离开函数后不存在" class="headerlink" title="返回值不能使用引用，若返回的值在离开函数后不存在"></a>返回值不能使用引用，若返回的值在离开函数后不存在</h3><p>使用引用的方式<strong>传递着</strong>，无需知道<strong>接受者是以引用</strong>的方式接受的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> complex&amp;</span><br><span class="line">comolex::operayor += (<span class="type">const</span> comlex&amp; r)&#123;</span><br><span class="line">   <span class="keyword">return</span> __doapl(<span class="keyword">this</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c2 +=c1;</span><br><span class="line">c2+=c2+=c1;<span class="comment">// 因为是引用的方式，所以这种写法是可以的。既传递着无需关心接受者的接收方式</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h2><h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">complex c1;</span><br><span class="line">complex c2;</span><br><span class="line">c2+=c1;<span class="comment">//操作符被作用到左侧的这个类型上</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">inline</span> complex&amp;</span><br><span class="line"><span class="comment">//由于这个函数其他地方可能会用到，因此我们需要把它独立出来</span></span><br><span class="line">__doapl (complex* ths,<span class="type">const</span> comlex&amp; r)&#123;<span class="comment">//第二个参数不会改动，因此添加const关键字</span></span><br><span class="line">    ths-&gt;re +=r.re;</span><br><span class="line">    ths-&gt;im +=r.im;</span><br><span class="line">    <span class="keyword">return</span> *ths;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> complex&amp;</span><br><span class="line">comolex::operayor += (<span class="type">const</span> comlex&amp; r)&#123;</span><br><span class="line">   <span class="keyword">return</span> __doapl(<span class="keyword">this</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="非成员函数"><a href="#非成员函数" class="headerlink" title="非成员函数"></a>非成员函数</h3><p><em>临时对象</em><br>特殊操作符要使用全局的操作符重载<br>cout&lt;&lt; conj(c1);<br>cout&lt;&lt; c1&lt;&lt; conj(c1);</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局函数</span></span><br><span class="line"><span class="keyword">inline</span> compelx</span><br><span class="line"><span class="keyword">operator</span> +(<span class="type">const</span> compelx&amp;x,<span class="type">const</span> complex&amp;y)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span>(<span class="built_in">real</span>(x)+<span class="built_in">real</span>(y),<span class="built_in">imag</span>(x)+<span class="built_in">imag</span>(y));<span class="comment">//类型（）创建临时变量。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> compelx</span><br><span class="line"><span class="keyword">operator</span> +(<span class="type">const</span> compelx&amp;x, <span class="type">double</span> y)&#123;</span><br><span class="line">    <span class="built_in">complex</span>(<span class="built_in">real</span>(x)+<span class="built_in">real</span>(y),<span class="built_in">imag</span>(x)+y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> compelx</span><br><span class="line"><span class="keyword">operator</span> +( <span class="type">double</span> x, <span class="type">const</span> complex&amp;y)&#123;</span><br><span class="line">    <span class="built_in">complex</span>(x+<span class="built_in">real</span>(y),<span class="built_in">imag</span>(x)+<span class="built_in">imag</span>(y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> complex <span class="keyword">operator</span> +(<span class="type">const</span> complex&amp;x)&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> complex <span class="keyword">operator</span> -(<span class="type">const</span> complex&amp;x)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span>(-<span class="built_in">real</span>(x),-<span class="built_in">imag</span>(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">operator</span> ==(<span class="type">const</span> comolex&amp; x,<span class="type">const</span> comolex&amp; y)&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">real</span>(x)==<span class="built_in">real</span>(y) &amp;&amp;<span class="built_in">imag</span>(x)==<span class="built_in">imag</span>(y);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">operator</span> ==(<span class="type">const</span> comolex&amp; x,<span class="type">double</span> y)&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">real</span>(x)==y &amp;&amp;<span class="built_in">imag</span>(x)==<span class="number">0</span>;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">operator</span> ==(<span class="type">double</span> x,<span class="type">const</span> comolex&amp; y)&#123;</span><br><span class="line"> <span class="keyword">return</span> x==<span class="built_in">real</span>(y) &amp;&amp;<span class="built_in">imag</span>(x)==<span class="number">0</span>;  </span><br><span class="line">&#125;</span><br><span class="line">ostream &amp;</span><br><span class="line"><span class="keyword">operator</span> &lt;&lt; (ostream&amp; os,<span class="type">const</span> compelx&amp;x)&#123;<span class="comment">//os 不能const，因为每次输出改变os的状态</span></span><br><span class="line">    <span class="keyword">return</span> os&lt;&lt;<span class="string">&quot;&quot;</span>&lt;&lt;<span class="built_in">real</span>(x)&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;<span class="built_in">imag</span>(x)&lt;&lt;<span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
        <category>cpp</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>构造</tag>
        <tag>析构</tag>
        <tag>侯捷</tag>
        <tag>内联函数</tag>
        <tag>操作符重载</tag>
        <tag>临时对象</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp 面向对象基础--基础与头文件声明</title>
    <url>/2022/03/19/cpp-%E4%BE%AF%E6%8D%B7Note/</url>
    <content><![CDATA[<!-- HTML方式: 直接在 Markdown 文件中编写 HTML 来调用 -->
<!-- 其中 class="blockquote-center" 是必须的 -->
<!-- <blockquote class="blockquote-center">this is note</blockquote> -->

<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="c与cpp-的区别"><a href="#c与cpp-的区别" class="headerlink" title="c与cpp 的区别"></a>c与cpp 的区别</h3><table>
<thead>
<tr>
<th>语言</th>
<th>c</th>
<th>cpp</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>Object Base(基于对象)</td>
<td>Object Oriented(面向对象)</td>
</tr>
<tr>
<td></td>
<td>面对**单一的class(类)**设计</td>
<td>面对多重classes的设计，着重于<strong>class之间的关系</strong></td>
</tr>
<tr>
<td>头文件的书写区别 注（头文件的后缀名在不同平台可能不同）引用c的头文件要在前面加c</td>
<td>&lt;stdio&gt;</td>
<td>&lt;cstdio&gt; &lt;iostream&gt;</td>
</tr>
</tbody></table>
<span id="more"></span>

<h3 id="防卫式生命"><a href="#防卫式生命" class="headerlink" title="防卫式生命"></a>防卫式生命</h3><p><em>为了解决引用顺序的问题</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __FILENAME__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __FILENAME__</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="头文件布局"><a href="#头文件布局" class="headerlink" title="头文件布局"></a>头文件布局</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __FILENAME__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __FILENAME__</span></span><br><span class="line"><span class="comment">// 前项生命</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类定义</span></span><br><span class="line">complex::<span class="built_in">method</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="class声明-模板类"><a href="#class声明-模板类" class="headerlink" title="class声明(模板类)"></a>class声明(模板类)</h2><ul>
<li>complex.h</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __COMPLEX__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __COMPLEX__</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">complex</span>(T r=<span class="number">0</span>,T i=<span class="number">0</span>):<span class="built_in">re</span>(r),<span class="built_in">im</span>(i)&#123;&#125;</span><br><span class="line">	complex&amp; <span class="keyword">operator</span> +=(<span class="type">const</span> complex&amp;);</span><br><span class="line">	<span class="function">T <span class="title">real</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> re;&#125; <span class="comment">//表示函数不会修改任何东西</span></span><br><span class="line">	<span class="function">T <span class="title">imag</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> im;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T re,im;</span><br><span class="line">	<span class="keyword">friend</span> complex&amp; __doapl(complex*,<span class="type">const</span> complex&amp;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>Complex 类的使用</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">complex&lt;<span class="type">double</span>&gt; <span class="title">complexDouble</span><span class="params">(<span class="number">1.0</span>,<span class="number">2.0</span>)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
        <category>cpp</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>侯捷</tag>
        <tag>头文件</tag>
      </tags>
  </entry>
  <entry>
    <title>variadic Template(可变参数模板)</title>
    <url>/2022/04/16/variadic-Template-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<!-- <blockquote class="blockquote-center">this is note</blockquote> -->
<p><strong>使用可变参数模板可以实现</strong></p>
<ul>
<li>递归调用</li>
<li>递归创建</li>
<li>递归继承</li>
<li>递归复合<span id="more"></span></li>
</ul>
<h1 id="variadic-template"><a href="#variadic-template" class="headerlink" title="variadic template"></a>variadic template</h1><ul>
<li>template<ul>
<li>function template</li>
<li>class tempalate</li>
</ul>
</li>
</ul>
<hr>
<p>变化的区别</p>
<ul>
<li>参数个数<ul>
<li>利用参数个数逐一递减的特性，实现递归函数调用，使用function template 完成</li>
</ul>
</li>
<li>参数类型<ul>
<li>利用参数个数逐一递减，导致参数函数类型也逐一递减实现递归集成,或递归复合，以class template 完成</li>
</ul>
</li>
</ul>
<h2 id="sample"><a href="#sample" class="headerlink" title="sample"></a>sample</h2><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><ul>
<li><p>例子1</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printX</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个是特化版本，当前版本存在时，下面的函数不会呗调用 既 void printX(const Types&amp; args) 不会被调用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... types&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printX</span><span class="params">(constT&amp; firstArg,<span class="type">const</span> Types&amp; args)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;fistArg&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">print</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... types&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printX</span><span class="params">(<span class="type">const</span> Types&amp; args)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;fistArg&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">print</span>(args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>例子2 重写printf function</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(*s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*s == <span class="string">&#x27;%&#x27;</span>&amp;&amp;*(++s) !+<span class="string">&#x27;%&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;invalid format string:missing argument&quot;</span>)</span><br><span class="line">        std::cout&lt;&lt;*s++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*s,T value,Args... args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(*s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*s == <span class="string">&#x27;%&#x27;</span> &amp;&amp; *(++s) !=<span class="string">&#x27;%&#x27;</span>)&#123;</span><br><span class="line">            std::cout&lt;&lt;value;</span><br><span class="line">            <span class="built_in">printf</span>(++s,args...);</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        &#125;</span><br><span class="line">        std::cout&lt;&lt;*s++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;extra argument provided to printf&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>例子3 max函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//stl_algo.h</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _ForwardIterator,<span class="keyword">typename</span> _Compare&gt;</span><br><span class="line">_ForwardIterator</span><br><span class="line">__max_element(_ForwardIterator __first,_ForwarIterator __last,_Compare __comp)&#123;</span><br><span class="line">    <span class="keyword">if</span>(__first==__last) <span class="keyword">return</span> __first;</span><br><span class="line">    _ForwardIterator __result=__first;</span><br><span class="line">    <span class="keyword">while</span>(++__first!=__last)</span><br><span class="line">        <span class="keyword">if</span>(__comp(result,__first))</span><br><span class="line">            __result =__first;</span><br><span class="line">    <span class="keyword">return</span> __result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _ForwardIterator&gt;</span></span><br><span class="line"><span class="function"> <span class="keyword">inline</span> _ForwardIterator</span></span><br><span class="line"><span class="function"> <span class="title">max_element</span><span class="params">(_ForwardIterator __first,_ForwarIterator __last)</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> __max_element(__first,__last,__iter_less_iter());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//stl_algo.h</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> __Tp&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Tp</span></span><br><span class="line"><span class="function"><span class="title">max</span><span class="params">(initializer_list&lt;__Tp&gt; __l)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="built_in">max_element</span>(_l.<span class="built_in">begin</span>(),_l.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//predefined_oops.h</span></span><br><span class="line"><span class="keyword">inline</span> _Iter_less_iter</span><br><span class="line">__iter_less_iter()&#123;</span><br><span class="line">    <span class="keyword">return</span> _Iter_less_iter();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//predefined_oops.h</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_Iter_less_iter</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Iterator1,</span></span><br><span class="line"><span class="function">             <span class="keyword">typename</span> _Iterator2&gt;</span></span><br><span class="line"><span class="function">    <span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(_Iterator1 __it1,_Iterator2 __it2)</span><span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *__it1&lt;*__it2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="built_in">max</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//改进</span></span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="built_in">max</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maximum</span><span class="params">(<span class="type">int</span> n,Args... args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">max</span>(n,<span class="built_in">max</span>(...args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="例子4-类模板"><a href="#例子4-类模板" class="headerlink" title="例子4 类模板"></a>例子4 类模板</h1><h2 id="用不同的方式处理first元素和last元素"><a href="#用不同的方式处理first元素和last元素" class="headerlink" title="用不同的方式处理first元素和last元素"></a>用不同的方式处理first元素和last元素</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout&lt;&lt; <span class="built_in">make_tuple</span>(<span class="number">7.5</span>,<span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>),<span class="built_in">bitset</span>&lt;<span class="number">16</span>&gt;(<span class="number">377</span>),<span class="number">42</span>);</span><br><span class="line"><span class="comment">//输出[7.5,hello,000000000101111001,42]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,<span class="type">const</span> tuple&lt;Args...&gt;&amp; t)&#123;</span><br><span class="line">    os&lt;&lt;<span class="string">&quot;[&quot;</span>;</span><br><span class="line">    PRINT_TUPLE&lt;<span class="number">0</span>,<span class="keyword">sizeof</span>...(Args),Args...&gt;<span class="built_in">print</span>(os,t);</span><br><span class="line">    os&lt;&lt;<span class="string">&quot;]&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> os&lt;&lt;<span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//boost: util/printtuple.hpp</span></span><br><span class="line"><span class="comment">//helper:print elment with index IDX of tuple</span></span><br><span class="line"><span class="comment">// with MAX element</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> IDX,<span class="type">int</span> MAX,<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PRINT_TUPLE</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">(ostream&amp; os,<span class="type">const</span> tuple&lt;Args...&gt;&amp; t)</span></span>&#123;</span><br><span class="line">        os&lt;&lt;<span class="built_in">get</span>&lt;IDX&gt;(t)&lt;&lt;(IDX+<span class="number">1</span>==MAX?<span class="string">&quot;&quot;</span>:<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        PRINT_TUPLE&lt;IDX+<span class="number">1</span>,MAX,Args...&gt;::<span class="built_in">print</span>(os,t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> MAX,<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PRINT_TUPLE</span>&lt;MAX,MAX,Args...&gt;&#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">(std::ostream&amp; os,<span class="type">const</span> tuple&lt;Args...&gt;&amp;t)</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="例子5-用于递归继承"><a href="#例子5-用于递归继承" class="headerlink" title="例子5 用于递归继承"></a>例子5 用于递归继承</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>...,Values&gt; <span class="keyword">class</span> <span class="title class_">tuple</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="keyword">class</span> <span class="title class_">tuple</span>&lt;&gt;&#123;&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head,typenmae... Tail&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tuple</span>&lt;Head,Tail...&gt;:<span class="keyword">private</span> tuple&lt;Tail...&gt;&#123;</span><br><span class="line">    <span class="keyword">typedef</span> tuple&lt;Tail...&gt; inherited;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">       <span class="built_in">tuple</span>()&#123;&#125;</span><br><span class="line">       <span class="built_in">tuple</span>(Head v,Tail... vtail):<span class="built_in">m_head</span>(v),<span class="built_in">inherited</span>(vtail...)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">typename</span> Head::type <span class="title">head</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_head;&#125;</span><br><span class="line">    <span class="function">inherited&amp; <span class="title">tail</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125; </span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">     Head m_head;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译不过，改进版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>...,Values&gt; <span class="keyword">class</span> <span class="title class_">tuple</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="keyword">class</span> <span class="title class_">tuple</span>&lt;&gt;&#123;&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head,typenmae... Tail&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tuple</span>&lt;Head,Tail...&gt;:<span class="keyword">private</span> tuple&lt;Tail...&gt;&#123;</span><br><span class="line">    <span class="keyword">typedef</span> tuple&lt;Tail...&gt; inherited;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">     Head m_head;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">       <span class="built_in">tuple</span>()&#123;&#125;</span><br><span class="line">       <span class="built_in">tuple</span>(Head v,Tail... vtail):<span class="built_in">m_head</span>(v),<span class="built_in">inherited</span>(vtail...)&#123;&#125;</span><br><span class="line">    <span class="comment">//typename Head::type head()&#123;return m_head;&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">head</span><span class="params">()</span>-&gt;<span class="title">decltype</span><span class="params">(m_head)</span></span>&#123;<span class="keyword">return</span> m_head;&#125;</span><br><span class="line">    <span class="function">inherited&amp; <span class="title">tail</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125; </span><br><span class="line">    <span class="comment">// protected:</span></span><br><span class="line">    <span class="comment">//  Head m_head;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 简化版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>...,Values&gt; <span class="keyword">class</span> <span class="title class_">tuple</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="keyword">class</span> <span class="title class_">tuple</span>&lt;&gt;&#123;&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head,typenmae... Tail&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tuple</span>&lt;Head,Tail...&gt;:<span class="keyword">private</span> tuple&lt;Tail...&gt;&#123;</span><br><span class="line">    <span class="keyword">typedef</span> tuple&lt;Tail...&gt; inherited;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">     Head m_head;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">       <span class="built_in">tuple</span>()&#123;&#125;</span><br><span class="line">       <span class="built_in">tuple</span>(Head v,Tail... vtail):<span class="built_in">m_head</span>(v),<span class="built_in">inherited</span>(vtail...)&#123;&#125;<span class="comment">//相当于调用父类的构造</span></span><br><span class="line">    <span class="comment">//typename Head::type head()&#123;return m_head;&#125;</span></span><br><span class="line">    <span class="function">Head <span class="title">head</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_head;&#125;</span><br><span class="line">    <span class="function">inherited&amp; <span class="title">tail</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125; <span class="comment">//相当于向上转型</span></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">     Head m_head;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="例子6"><a href="#例子6" class="headerlink" title="例子6"></a>例子6</h1><h2 id="用于递归复合"><a href="#用于递归复合" class="headerlink" title="用于递归复合"></a>用于递归复合</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Values&gt;<span class="keyword">class</span> <span class="title class_">tup</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="keyword">class</span> <span class="title class_">tup</span>&lt;&gt;&#123;&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head,<span class="keyword">typename</span>... Tail&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tup</span>&lt;Head,Tail...&gt;&#123;</span><br><span class="line">    <span class="keyword">typedef</span> tup&lt;Tail...&gt; composited;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        composited m_tail;</span><br><span class="line">        Head m_head;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">tup</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">tup</span>(Head v,Tail... vtail):<span class="built_in">m_tail</span>(vtail...),<span class="built_in">m_head</span>(v)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Head <span class="title">head</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_head;&#125;</span><br><span class="line">    <span class="function">composited&amp; <span class="title">tail</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_tail;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
        <category>cpp</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>variadic templates</tag>
      </tags>
  </entry>
</search>
